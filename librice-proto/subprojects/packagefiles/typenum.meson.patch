From 4f415753aafaf2220907073abc787267ce000774 Mon Sep 17 00:00:00 2001
From: Matthew Waters <matthew@centricular.com>
Date: Thu, 15 Feb 2024 14:33:44 +1100
Subject: [PATCH 1/2] Ship build.rs generated files

---
 src/consts.rs                 |  2248 ++++
 src/generic_const_mappings.rs |  5531 +++++++++
 src/lib.rs                    |    13 +-
 src/op.rs                     |  1030 ++
 src/tests.rs                  | 20565 ++++++++++++++++++++++++++++++++
 5 files changed, 29384 insertions(+), 3 deletions(-)
 create mode 100644 src/consts.rs
 create mode 100644 src/generic_const_mappings.rs
 create mode 100644 src/op.rs
 create mode 100644 src/tests.rs

diff --git a/src/consts.rs b/src/consts.rs
new file mode 100644
index 0000000..cbbb546
--- /dev/null
+++ b/src/consts.rs
@@ -0,0 +1,2248 @@
+
+/**
+Type aliases for many constants.
+
+This file is generated by typenum's build script.
+
+For unsigned integers, the format is `U` followed by the number. We define aliases for
+
+- Numbers 0 through 1024
+- Powers of 2 below `u64::MAX`
+- Powers of 10 below `u64::MAX`
+
+These alias definitions look like this:
+
+```rust
+use typenum::{B0, B1, UInt, UTerm};
+
+# #[allow(dead_code)]
+type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
+```
+
+For positive signed integers, the format is `P` followed by the number and for negative
+signed integers it is `N` followed by the number. For the signed integer zero, we use
+`Z0`. We define aliases for
+
+- Numbers -1024 through 1024
+- Powers of 2 between `i64::MIN` and `i64::MAX`
+- Powers of 10 between `i64::MIN` and `i64::MAX`
+
+These alias definitions look like this:
+
+```rust
+use typenum::{B0, B1, UInt, UTerm, PInt, NInt};
+
+# #[allow(dead_code)]
+type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+# #[allow(dead_code)]
+type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+```
+
+# Example
+```rust
+# #[allow(unused_imports)]
+use typenum::{U0, U1, U2, U3, U4, U5, U6};
+# #[allow(unused_imports)]
+use typenum::{N3, N2, N1, Z0, P1, P2, P3};
+# #[allow(unused_imports)]
+use typenum::{U774, N17, N10000, P1024, P4096};
+```
+
+We also define the aliases `False` and `True` for `B0` and `B1`, respectively.
+*/
+#[allow(missing_docs)]
+pub mod consts {
+    use crate::uint::{UInt, UTerm};
+    use crate::int::{PInt, NInt};
+
+    pub use crate::bit::{B0, B1};
+    pub use crate::int::Z0;
+
+    pub type True = B1;
+    pub type False = B0;
+    pub type U0 = UTerm;
+    pub type U1 = UInt<UTerm, B1>;
+    pub type P1 = PInt<U1>; pub type N1 = NInt<U1>;
+    pub type U2 = UInt<UInt<UTerm, B1>, B0>;
+    pub type P2 = PInt<U2>; pub type N2 = NInt<U2>;
+    pub type U3 = UInt<UInt<UTerm, B1>, B1>;
+    pub type P3 = PInt<U3>; pub type N3 = NInt<U3>;
+    pub type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    pub type P4 = PInt<U4>; pub type N4 = NInt<U4>;
+    pub type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    pub type P5 = PInt<U5>; pub type N5 = NInt<U5>;
+    pub type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
+    pub type P6 = PInt<U6>; pub type N6 = NInt<U6>;
+    pub type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;
+    pub type P7 = PInt<U7>; pub type N7 = NInt<U7>;
+    pub type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;
+    pub type P8 = PInt<U8>; pub type N8 = NInt<U8>;
+    pub type U9 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>;
+    pub type P9 = PInt<U9>; pub type N9 = NInt<U9>;
+    pub type U10 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>;
+    pub type P10 = PInt<U10>; pub type N10 = NInt<U10>;
+    pub type U11 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>;
+    pub type P11 = PInt<U11>; pub type N11 = NInt<U11>;
+    pub type U12 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>;
+    pub type P12 = PInt<U12>; pub type N12 = NInt<U12>;
+    pub type U13 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>;
+    pub type P13 = PInt<U13>; pub type N13 = NInt<U13>;
+    pub type U14 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>;
+    pub type P14 = PInt<U14>; pub type N14 = NInt<U14>;
+    pub type U15 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>;
+    pub type P15 = PInt<U15>; pub type N15 = NInt<U15>;
+    pub type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;
+    pub type P16 = PInt<U16>; pub type N16 = NInt<U16>;
+    pub type U17 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>;
+    pub type P17 = PInt<U17>; pub type N17 = NInt<U17>;
+    pub type U18 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>;
+    pub type P18 = PInt<U18>; pub type N18 = NInt<U18>;
+    pub type U19 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>;
+    pub type P19 = PInt<U19>; pub type N19 = NInt<U19>;
+    pub type U20 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>;
+    pub type P20 = PInt<U20>; pub type N20 = NInt<U20>;
+    pub type U21 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>;
+    pub type P21 = PInt<U21>; pub type N21 = NInt<U21>;
+    pub type U22 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>;
+    pub type P22 = PInt<U22>; pub type N22 = NInt<U22>;
+    pub type U23 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>;
+    pub type P23 = PInt<U23>; pub type N23 = NInt<U23>;
+    pub type U24 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>;
+    pub type P24 = PInt<U24>; pub type N24 = NInt<U24>;
+    pub type U25 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>;
+    pub type P25 = PInt<U25>; pub type N25 = NInt<U25>;
+    pub type U26 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>;
+    pub type P26 = PInt<U26>; pub type N26 = NInt<U26>;
+    pub type U27 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>;
+    pub type P27 = PInt<U27>; pub type N27 = NInt<U27>;
+    pub type U28 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>;
+    pub type P28 = PInt<U28>; pub type N28 = NInt<U28>;
+    pub type U29 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>;
+    pub type P29 = PInt<U29>; pub type N29 = NInt<U29>;
+    pub type U30 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>;
+    pub type P30 = PInt<U30>; pub type N30 = NInt<U30>;
+    pub type U31 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>;
+    pub type P31 = PInt<U31>; pub type N31 = NInt<U31>;
+    pub type U32 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>;
+    pub type P32 = PInt<U32>; pub type N32 = NInt<U32>;
+    pub type U33 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>;
+    pub type P33 = PInt<U33>; pub type N33 = NInt<U33>;
+    pub type U34 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>;
+    pub type P34 = PInt<U34>; pub type N34 = NInt<U34>;
+    pub type U35 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>;
+    pub type P35 = PInt<U35>; pub type N35 = NInt<U35>;
+    pub type U36 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>;
+    pub type P36 = PInt<U36>; pub type N36 = NInt<U36>;
+    pub type U37 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>;
+    pub type P37 = PInt<U37>; pub type N37 = NInt<U37>;
+    pub type U38 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>;
+    pub type P38 = PInt<U38>; pub type N38 = NInt<U38>;
+    pub type U39 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>;
+    pub type P39 = PInt<U39>; pub type N39 = NInt<U39>;
+    pub type U40 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>;
+    pub type P40 = PInt<U40>; pub type N40 = NInt<U40>;
+    pub type U41 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>;
+    pub type P41 = PInt<U41>; pub type N41 = NInt<U41>;
+    pub type U42 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>;
+    pub type P42 = PInt<U42>; pub type N42 = NInt<U42>;
+    pub type U43 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>;
+    pub type P43 = PInt<U43>; pub type N43 = NInt<U43>;
+    pub type U44 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>;
+    pub type P44 = PInt<U44>; pub type N44 = NInt<U44>;
+    pub type U45 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>;
+    pub type P45 = PInt<U45>; pub type N45 = NInt<U45>;
+    pub type U46 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>;
+    pub type P46 = PInt<U46>; pub type N46 = NInt<U46>;
+    pub type U47 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>;
+    pub type P47 = PInt<U47>; pub type N47 = NInt<U47>;
+    pub type U48 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>;
+    pub type P48 = PInt<U48>; pub type N48 = NInt<U48>;
+    pub type U49 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>;
+    pub type P49 = PInt<U49>; pub type N49 = NInt<U49>;
+    pub type U50 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>;
+    pub type P50 = PInt<U50>; pub type N50 = NInt<U50>;
+    pub type U51 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>;
+    pub type P51 = PInt<U51>; pub type N51 = NInt<U51>;
+    pub type U52 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>;
+    pub type P52 = PInt<U52>; pub type N52 = NInt<U52>;
+    pub type U53 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>;
+    pub type P53 = PInt<U53>; pub type N53 = NInt<U53>;
+    pub type U54 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>;
+    pub type P54 = PInt<U54>; pub type N54 = NInt<U54>;
+    pub type U55 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>;
+    pub type P55 = PInt<U55>; pub type N55 = NInt<U55>;
+    pub type U56 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>;
+    pub type P56 = PInt<U56>; pub type N56 = NInt<U56>;
+    pub type U57 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>;
+    pub type P57 = PInt<U57>; pub type N57 = NInt<U57>;
+    pub type U58 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>;
+    pub type P58 = PInt<U58>; pub type N58 = NInt<U58>;
+    pub type U59 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>;
+    pub type P59 = PInt<U59>; pub type N59 = NInt<U59>;
+    pub type U60 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>;
+    pub type P60 = PInt<U60>; pub type N60 = NInt<U60>;
+    pub type U61 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>;
+    pub type P61 = PInt<U61>; pub type N61 = NInt<U61>;
+    pub type U62 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>;
+    pub type P62 = PInt<U62>; pub type N62 = NInt<U62>;
+    pub type U63 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>;
+    pub type P63 = PInt<U63>; pub type N63 = NInt<U63>;
+    pub type U64 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P64 = PInt<U64>; pub type N64 = NInt<U64>;
+    pub type U65 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>;
+    pub type P65 = PInt<U65>; pub type N65 = NInt<U65>;
+    pub type U66 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>;
+    pub type P66 = PInt<U66>; pub type N66 = NInt<U66>;
+    pub type U67 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>;
+    pub type P67 = PInt<U67>; pub type N67 = NInt<U67>;
+    pub type U68 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>;
+    pub type P68 = PInt<U68>; pub type N68 = NInt<U68>;
+    pub type U69 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>;
+    pub type P69 = PInt<U69>; pub type N69 = NInt<U69>;
+    pub type U70 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>;
+    pub type P70 = PInt<U70>; pub type N70 = NInt<U70>;
+    pub type U71 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>;
+    pub type P71 = PInt<U71>; pub type N71 = NInt<U71>;
+    pub type U72 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>;
+    pub type P72 = PInt<U72>; pub type N72 = NInt<U72>;
+    pub type U73 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>;
+    pub type P73 = PInt<U73>; pub type N73 = NInt<U73>;
+    pub type U74 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>;
+    pub type P74 = PInt<U74>; pub type N74 = NInt<U74>;
+    pub type U75 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>;
+    pub type P75 = PInt<U75>; pub type N75 = NInt<U75>;
+    pub type U76 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>;
+    pub type P76 = PInt<U76>; pub type N76 = NInt<U76>;
+    pub type U77 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>;
+    pub type P77 = PInt<U77>; pub type N77 = NInt<U77>;
+    pub type U78 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>;
+    pub type P78 = PInt<U78>; pub type N78 = NInt<U78>;
+    pub type U79 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>;
+    pub type P79 = PInt<U79>; pub type N79 = NInt<U79>;
+    pub type U80 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>;
+    pub type P80 = PInt<U80>; pub type N80 = NInt<U80>;
+    pub type U81 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>;
+    pub type P81 = PInt<U81>; pub type N81 = NInt<U81>;
+    pub type U82 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>;
+    pub type P82 = PInt<U82>; pub type N82 = NInt<U82>;
+    pub type U83 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>;
+    pub type P83 = PInt<U83>; pub type N83 = NInt<U83>;
+    pub type U84 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>;
+    pub type P84 = PInt<U84>; pub type N84 = NInt<U84>;
+    pub type U85 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>;
+    pub type P85 = PInt<U85>; pub type N85 = NInt<U85>;
+    pub type U86 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>;
+    pub type P86 = PInt<U86>; pub type N86 = NInt<U86>;
+    pub type U87 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>;
+    pub type P87 = PInt<U87>; pub type N87 = NInt<U87>;
+    pub type U88 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>;
+    pub type P88 = PInt<U88>; pub type N88 = NInt<U88>;
+    pub type U89 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>;
+    pub type P89 = PInt<U89>; pub type N89 = NInt<U89>;
+    pub type U90 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>;
+    pub type P90 = PInt<U90>; pub type N90 = NInt<U90>;
+    pub type U91 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>;
+    pub type P91 = PInt<U91>; pub type N91 = NInt<U91>;
+    pub type U92 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>;
+    pub type P92 = PInt<U92>; pub type N92 = NInt<U92>;
+    pub type U93 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>;
+    pub type P93 = PInt<U93>; pub type N93 = NInt<U93>;
+    pub type U94 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>;
+    pub type P94 = PInt<U94>; pub type N94 = NInt<U94>;
+    pub type U95 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>;
+    pub type P95 = PInt<U95>; pub type N95 = NInt<U95>;
+    pub type U96 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>;
+    pub type P96 = PInt<U96>; pub type N96 = NInt<U96>;
+    pub type U97 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>;
+    pub type P97 = PInt<U97>; pub type N97 = NInt<U97>;
+    pub type U98 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>;
+    pub type P98 = PInt<U98>; pub type N98 = NInt<U98>;
+    pub type U99 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>;
+    pub type P99 = PInt<U99>; pub type N99 = NInt<U99>;
+    pub type U100 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>;
+    pub type P100 = PInt<U100>; pub type N100 = NInt<U100>;
+    pub type U101 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>;
+    pub type P101 = PInt<U101>; pub type N101 = NInt<U101>;
+    pub type U102 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>;
+    pub type P102 = PInt<U102>; pub type N102 = NInt<U102>;
+    pub type U103 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>;
+    pub type P103 = PInt<U103>; pub type N103 = NInt<U103>;
+    pub type U104 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>;
+    pub type P104 = PInt<U104>; pub type N104 = NInt<U104>;
+    pub type U105 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>;
+    pub type P105 = PInt<U105>; pub type N105 = NInt<U105>;
+    pub type U106 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>;
+    pub type P106 = PInt<U106>; pub type N106 = NInt<U106>;
+    pub type U107 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>;
+    pub type P107 = PInt<U107>; pub type N107 = NInt<U107>;
+    pub type U108 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>;
+    pub type P108 = PInt<U108>; pub type N108 = NInt<U108>;
+    pub type U109 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>;
+    pub type P109 = PInt<U109>; pub type N109 = NInt<U109>;
+    pub type U110 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>;
+    pub type P110 = PInt<U110>; pub type N110 = NInt<U110>;
+    pub type U111 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>;
+    pub type P111 = PInt<U111>; pub type N111 = NInt<U111>;
+    pub type U112 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>;
+    pub type P112 = PInt<U112>; pub type N112 = NInt<U112>;
+    pub type U113 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>;
+    pub type P113 = PInt<U113>; pub type N113 = NInt<U113>;
+    pub type U114 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>;
+    pub type P114 = PInt<U114>; pub type N114 = NInt<U114>;
+    pub type U115 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>;
+    pub type P115 = PInt<U115>; pub type N115 = NInt<U115>;
+    pub type U116 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>;
+    pub type P116 = PInt<U116>; pub type N116 = NInt<U116>;
+    pub type U117 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>;
+    pub type P117 = PInt<U117>; pub type N117 = NInt<U117>;
+    pub type U118 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>;
+    pub type P118 = PInt<U118>; pub type N118 = NInt<U118>;
+    pub type U119 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>;
+    pub type P119 = PInt<U119>; pub type N119 = NInt<U119>;
+    pub type U120 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>;
+    pub type P120 = PInt<U120>; pub type N120 = NInt<U120>;
+    pub type U121 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>;
+    pub type P121 = PInt<U121>; pub type N121 = NInt<U121>;
+    pub type U122 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>;
+    pub type P122 = PInt<U122>; pub type N122 = NInt<U122>;
+    pub type U123 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>;
+    pub type P123 = PInt<U123>; pub type N123 = NInt<U123>;
+    pub type U124 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>;
+    pub type P124 = PInt<U124>; pub type N124 = NInt<U124>;
+    pub type U125 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>;
+    pub type P125 = PInt<U125>; pub type N125 = NInt<U125>;
+    pub type U126 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>;
+    pub type P126 = PInt<U126>; pub type N126 = NInt<U126>;
+    pub type U127 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>;
+    pub type P127 = PInt<U127>; pub type N127 = NInt<U127>;
+    pub type U128 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P128 = PInt<U128>; pub type N128 = NInt<U128>;
+    pub type U129 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>;
+    pub type P129 = PInt<U129>; pub type N129 = NInt<U129>;
+    pub type U130 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>;
+    pub type P130 = PInt<U130>; pub type N130 = NInt<U130>;
+    pub type U131 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>;
+    pub type P131 = PInt<U131>; pub type N131 = NInt<U131>;
+    pub type U132 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>;
+    pub type P132 = PInt<U132>; pub type N132 = NInt<U132>;
+    pub type U133 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>;
+    pub type P133 = PInt<U133>; pub type N133 = NInt<U133>;
+    pub type U134 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>;
+    pub type P134 = PInt<U134>; pub type N134 = NInt<U134>;
+    pub type U135 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>;
+    pub type P135 = PInt<U135>; pub type N135 = NInt<U135>;
+    pub type U136 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>;
+    pub type P136 = PInt<U136>; pub type N136 = NInt<U136>;
+    pub type U137 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>;
+    pub type P137 = PInt<U137>; pub type N137 = NInt<U137>;
+    pub type U138 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>;
+    pub type P138 = PInt<U138>; pub type N138 = NInt<U138>;
+    pub type U139 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>;
+    pub type P139 = PInt<U139>; pub type N139 = NInt<U139>;
+    pub type U140 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>;
+    pub type P140 = PInt<U140>; pub type N140 = NInt<U140>;
+    pub type U141 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>;
+    pub type P141 = PInt<U141>; pub type N141 = NInt<U141>;
+    pub type U142 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>;
+    pub type P142 = PInt<U142>; pub type N142 = NInt<U142>;
+    pub type U143 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>;
+    pub type P143 = PInt<U143>; pub type N143 = NInt<U143>;
+    pub type U144 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>;
+    pub type P144 = PInt<U144>; pub type N144 = NInt<U144>;
+    pub type U145 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>;
+    pub type P145 = PInt<U145>; pub type N145 = NInt<U145>;
+    pub type U146 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>;
+    pub type P146 = PInt<U146>; pub type N146 = NInt<U146>;
+    pub type U147 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>;
+    pub type P147 = PInt<U147>; pub type N147 = NInt<U147>;
+    pub type U148 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>;
+    pub type P148 = PInt<U148>; pub type N148 = NInt<U148>;
+    pub type U149 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>;
+    pub type P149 = PInt<U149>; pub type N149 = NInt<U149>;
+    pub type U150 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>;
+    pub type P150 = PInt<U150>; pub type N150 = NInt<U150>;
+    pub type U151 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>;
+    pub type P151 = PInt<U151>; pub type N151 = NInt<U151>;
+    pub type U152 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>;
+    pub type P152 = PInt<U152>; pub type N152 = NInt<U152>;
+    pub type U153 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>;
+    pub type P153 = PInt<U153>; pub type N153 = NInt<U153>;
+    pub type U154 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>;
+    pub type P154 = PInt<U154>; pub type N154 = NInt<U154>;
+    pub type U155 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>;
+    pub type P155 = PInt<U155>; pub type N155 = NInt<U155>;
+    pub type U156 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>;
+    pub type P156 = PInt<U156>; pub type N156 = NInt<U156>;
+    pub type U157 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>;
+    pub type P157 = PInt<U157>; pub type N157 = NInt<U157>;
+    pub type U158 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>;
+    pub type P158 = PInt<U158>; pub type N158 = NInt<U158>;
+    pub type U159 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>;
+    pub type P159 = PInt<U159>; pub type N159 = NInt<U159>;
+    pub type U160 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;
+    pub type P160 = PInt<U160>; pub type N160 = NInt<U160>;
+    pub type U161 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>;
+    pub type P161 = PInt<U161>; pub type N161 = NInt<U161>;
+    pub type U162 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>;
+    pub type P162 = PInt<U162>; pub type N162 = NInt<U162>;
+    pub type U163 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>;
+    pub type P163 = PInt<U163>; pub type N163 = NInt<U163>;
+    pub type U164 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>;
+    pub type P164 = PInt<U164>; pub type N164 = NInt<U164>;
+    pub type U165 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>;
+    pub type P165 = PInt<U165>; pub type N165 = NInt<U165>;
+    pub type U166 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>;
+    pub type P166 = PInt<U166>; pub type N166 = NInt<U166>;
+    pub type U167 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>;
+    pub type P167 = PInt<U167>; pub type N167 = NInt<U167>;
+    pub type U168 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>;
+    pub type P168 = PInt<U168>; pub type N168 = NInt<U168>;
+    pub type U169 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>;
+    pub type P169 = PInt<U169>; pub type N169 = NInt<U169>;
+    pub type U170 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>;
+    pub type P170 = PInt<U170>; pub type N170 = NInt<U170>;
+    pub type U171 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>;
+    pub type P171 = PInt<U171>; pub type N171 = NInt<U171>;
+    pub type U172 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>;
+    pub type P172 = PInt<U172>; pub type N172 = NInt<U172>;
+    pub type U173 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>;
+    pub type P173 = PInt<U173>; pub type N173 = NInt<U173>;
+    pub type U174 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>;
+    pub type P174 = PInt<U174>; pub type N174 = NInt<U174>;
+    pub type U175 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>;
+    pub type P175 = PInt<U175>; pub type N175 = NInt<U175>;
+    pub type U176 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>;
+    pub type P176 = PInt<U176>; pub type N176 = NInt<U176>;
+    pub type U177 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>;
+    pub type P177 = PInt<U177>; pub type N177 = NInt<U177>;
+    pub type U178 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>;
+    pub type P178 = PInt<U178>; pub type N178 = NInt<U178>;
+    pub type U179 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>;
+    pub type P179 = PInt<U179>; pub type N179 = NInt<U179>;
+    pub type U180 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>;
+    pub type P180 = PInt<U180>; pub type N180 = NInt<U180>;
+    pub type U181 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>;
+    pub type P181 = PInt<U181>; pub type N181 = NInt<U181>;
+    pub type U182 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>;
+    pub type P182 = PInt<U182>; pub type N182 = NInt<U182>;
+    pub type U183 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>;
+    pub type P183 = PInt<U183>; pub type N183 = NInt<U183>;
+    pub type U184 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>;
+    pub type P184 = PInt<U184>; pub type N184 = NInt<U184>;
+    pub type U185 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>;
+    pub type P185 = PInt<U185>; pub type N185 = NInt<U185>;
+    pub type U186 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>;
+    pub type P186 = PInt<U186>; pub type N186 = NInt<U186>;
+    pub type U187 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>;
+    pub type P187 = PInt<U187>; pub type N187 = NInt<U187>;
+    pub type U188 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>;
+    pub type P188 = PInt<U188>; pub type N188 = NInt<U188>;
+    pub type U189 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>;
+    pub type P189 = PInt<U189>; pub type N189 = NInt<U189>;
+    pub type U190 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>;
+    pub type P190 = PInt<U190>; pub type N190 = NInt<U190>;
+    pub type U191 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>;
+    pub type P191 = PInt<U191>; pub type N191 = NInt<U191>;
+    pub type U192 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P192 = PInt<U192>; pub type N192 = NInt<U192>;
+    pub type U193 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>;
+    pub type P193 = PInt<U193>; pub type N193 = NInt<U193>;
+    pub type U194 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>;
+    pub type P194 = PInt<U194>; pub type N194 = NInt<U194>;
+    pub type U195 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>;
+    pub type P195 = PInt<U195>; pub type N195 = NInt<U195>;
+    pub type U196 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>;
+    pub type P196 = PInt<U196>; pub type N196 = NInt<U196>;
+    pub type U197 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>;
+    pub type P197 = PInt<U197>; pub type N197 = NInt<U197>;
+    pub type U198 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>;
+    pub type P198 = PInt<U198>; pub type N198 = NInt<U198>;
+    pub type U199 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>;
+    pub type P199 = PInt<U199>; pub type N199 = NInt<U199>;
+    pub type U200 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>;
+    pub type P200 = PInt<U200>; pub type N200 = NInt<U200>;
+    pub type U201 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>;
+    pub type P201 = PInt<U201>; pub type N201 = NInt<U201>;
+    pub type U202 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>;
+    pub type P202 = PInt<U202>; pub type N202 = NInt<U202>;
+    pub type U203 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>;
+    pub type P203 = PInt<U203>; pub type N203 = NInt<U203>;
+    pub type U204 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>;
+    pub type P204 = PInt<U204>; pub type N204 = NInt<U204>;
+    pub type U205 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>;
+    pub type P205 = PInt<U205>; pub type N205 = NInt<U205>;
+    pub type U206 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>;
+    pub type P206 = PInt<U206>; pub type N206 = NInt<U206>;
+    pub type U207 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>;
+    pub type P207 = PInt<U207>; pub type N207 = NInt<U207>;
+    pub type U208 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>;
+    pub type P208 = PInt<U208>; pub type N208 = NInt<U208>;
+    pub type U209 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>;
+    pub type P209 = PInt<U209>; pub type N209 = NInt<U209>;
+    pub type U210 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>;
+    pub type P210 = PInt<U210>; pub type N210 = NInt<U210>;
+    pub type U211 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>;
+    pub type P211 = PInt<U211>; pub type N211 = NInt<U211>;
+    pub type U212 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>;
+    pub type P212 = PInt<U212>; pub type N212 = NInt<U212>;
+    pub type U213 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>;
+    pub type P213 = PInt<U213>; pub type N213 = NInt<U213>;
+    pub type U214 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>;
+    pub type P214 = PInt<U214>; pub type N214 = NInt<U214>;
+    pub type U215 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>;
+    pub type P215 = PInt<U215>; pub type N215 = NInt<U215>;
+    pub type U216 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>;
+    pub type P216 = PInt<U216>; pub type N216 = NInt<U216>;
+    pub type U217 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>;
+    pub type P217 = PInt<U217>; pub type N217 = NInt<U217>;
+    pub type U218 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>;
+    pub type P218 = PInt<U218>; pub type N218 = NInt<U218>;
+    pub type U219 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>;
+    pub type P219 = PInt<U219>; pub type N219 = NInt<U219>;
+    pub type U220 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>;
+    pub type P220 = PInt<U220>; pub type N220 = NInt<U220>;
+    pub type U221 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>;
+    pub type P221 = PInt<U221>; pub type N221 = NInt<U221>;
+    pub type U222 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>;
+    pub type P222 = PInt<U222>; pub type N222 = NInt<U222>;
+    pub type U223 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>;
+    pub type P223 = PInt<U223>; pub type N223 = NInt<U223>;
+    pub type U224 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>;
+    pub type P224 = PInt<U224>; pub type N224 = NInt<U224>;
+    pub type U225 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>;
+    pub type P225 = PInt<U225>; pub type N225 = NInt<U225>;
+    pub type U226 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>;
+    pub type P226 = PInt<U226>; pub type N226 = NInt<U226>;
+    pub type U227 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>;
+    pub type P227 = PInt<U227>; pub type N227 = NInt<U227>;
+    pub type U228 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>;
+    pub type P228 = PInt<U228>; pub type N228 = NInt<U228>;
+    pub type U229 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>;
+    pub type P229 = PInt<U229>; pub type N229 = NInt<U229>;
+    pub type U230 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>;
+    pub type P230 = PInt<U230>; pub type N230 = NInt<U230>;
+    pub type U231 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>;
+    pub type P231 = PInt<U231>; pub type N231 = NInt<U231>;
+    pub type U232 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>;
+    pub type P232 = PInt<U232>; pub type N232 = NInt<U232>;
+    pub type U233 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>;
+    pub type P233 = PInt<U233>; pub type N233 = NInt<U233>;
+    pub type U234 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>;
+    pub type P234 = PInt<U234>; pub type N234 = NInt<U234>;
+    pub type U235 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>;
+    pub type P235 = PInt<U235>; pub type N235 = NInt<U235>;
+    pub type U236 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>;
+    pub type P236 = PInt<U236>; pub type N236 = NInt<U236>;
+    pub type U237 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>;
+    pub type P237 = PInt<U237>; pub type N237 = NInt<U237>;
+    pub type U238 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>;
+    pub type P238 = PInt<U238>; pub type N238 = NInt<U238>;
+    pub type U239 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>;
+    pub type P239 = PInt<U239>; pub type N239 = NInt<U239>;
+    pub type U240 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>;
+    pub type P240 = PInt<U240>; pub type N240 = NInt<U240>;
+    pub type U241 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>;
+    pub type P241 = PInt<U241>; pub type N241 = NInt<U241>;
+    pub type U242 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>;
+    pub type P242 = PInt<U242>; pub type N242 = NInt<U242>;
+    pub type U243 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>;
+    pub type P243 = PInt<U243>; pub type N243 = NInt<U243>;
+    pub type U244 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>;
+    pub type P244 = PInt<U244>; pub type N244 = NInt<U244>;
+    pub type U245 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>;
+    pub type P245 = PInt<U245>; pub type N245 = NInt<U245>;
+    pub type U246 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>;
+    pub type P246 = PInt<U246>; pub type N246 = NInt<U246>;
+    pub type U247 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>;
+    pub type P247 = PInt<U247>; pub type N247 = NInt<U247>;
+    pub type U248 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>;
+    pub type P248 = PInt<U248>; pub type N248 = NInt<U248>;
+    pub type U249 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>;
+    pub type P249 = PInt<U249>; pub type N249 = NInt<U249>;
+    pub type U250 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>;
+    pub type P250 = PInt<U250>; pub type N250 = NInt<U250>;
+    pub type U251 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>;
+    pub type P251 = PInt<U251>; pub type N251 = NInt<U251>;
+    pub type U252 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>;
+    pub type P252 = PInt<U252>; pub type N252 = NInt<U252>;
+    pub type U253 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>;
+    pub type P253 = PInt<U253>; pub type N253 = NInt<U253>;
+    pub type U254 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>;
+    pub type P254 = PInt<U254>; pub type N254 = NInt<U254>;
+    pub type U255 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>;
+    pub type P255 = PInt<U255>; pub type N255 = NInt<U255>;
+    pub type U256 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P256 = PInt<U256>; pub type N256 = NInt<U256>;
+    pub type U257 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B1>;
+    pub type P257 = PInt<U257>; pub type N257 = NInt<U257>;
+    pub type U258 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B0>;
+    pub type P258 = PInt<U258>; pub type N258 = NInt<U258>;
+    pub type U259 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B1>;
+    pub type P259 = PInt<U259>; pub type N259 = NInt<U259>;
+    pub type U260 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B0>;
+    pub type P260 = PInt<U260>; pub type N260 = NInt<U260>;
+    pub type U261 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B1>;
+    pub type P261 = PInt<U261>; pub type N261 = NInt<U261>;
+    pub type U262 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B0>;
+    pub type P262 = PInt<U262>; pub type N262 = NInt<U262>;
+    pub type U263 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B1>;
+    pub type P263 = PInt<U263>; pub type N263 = NInt<U263>;
+    pub type U264 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B0>;
+    pub type P264 = PInt<U264>; pub type N264 = NInt<U264>;
+    pub type U265 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B1>;
+    pub type P265 = PInt<U265>; pub type N265 = NInt<U265>;
+    pub type U266 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B0>;
+    pub type P266 = PInt<U266>; pub type N266 = NInt<U266>;
+    pub type U267 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B1>;
+    pub type P267 = PInt<U267>; pub type N267 = NInt<U267>;
+    pub type U268 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B0>;
+    pub type P268 = PInt<U268>; pub type N268 = NInt<U268>;
+    pub type U269 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>;
+    pub type P269 = PInt<U269>; pub type N269 = NInt<U269>;
+    pub type U270 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B0>;
+    pub type P270 = PInt<U270>; pub type N270 = NInt<U270>;
+    pub type U271 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B1>;
+    pub type P271 = PInt<U271>; pub type N271 = NInt<U271>;
+    pub type U272 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>;
+    pub type P272 = PInt<U272>; pub type N272 = NInt<U272>;
+    pub type U273 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B1>;
+    pub type P273 = PInt<U273>; pub type N273 = NInt<U273>;
+    pub type U274 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B0>;
+    pub type P274 = PInt<U274>; pub type N274 = NInt<U274>;
+    pub type U275 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B1>;
+    pub type P275 = PInt<U275>; pub type N275 = NInt<U275>;
+    pub type U276 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B0>;
+    pub type P276 = PInt<U276>; pub type N276 = NInt<U276>;
+    pub type U277 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B1>;
+    pub type P277 = PInt<U277>; pub type N277 = NInt<U277>;
+    pub type U278 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B0>;
+    pub type P278 = PInt<U278>; pub type N278 = NInt<U278>;
+    pub type U279 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B1>;
+    pub type P279 = PInt<U279>; pub type N279 = NInt<U279>;
+    pub type U280 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B0>;
+    pub type P280 = PInt<U280>; pub type N280 = NInt<U280>;
+    pub type U281 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B1>;
+    pub type P281 = PInt<U281>; pub type N281 = NInt<U281>;
+    pub type U282 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>;
+    pub type P282 = PInt<U282>; pub type N282 = NInt<U282>;
+    pub type U283 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B1>;
+    pub type P283 = PInt<U283>; pub type N283 = NInt<U283>;
+    pub type U284 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B0>;
+    pub type P284 = PInt<U284>; pub type N284 = NInt<U284>;
+    pub type U285 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B1>;
+    pub type P285 = PInt<U285>; pub type N285 = NInt<U285>;
+    pub type U286 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B0>;
+    pub type P286 = PInt<U286>; pub type N286 = NInt<U286>;
+    pub type U287 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B1>;
+    pub type P287 = PInt<U287>; pub type N287 = NInt<U287>;
+    pub type U288 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;
+    pub type P288 = PInt<U288>; pub type N288 = NInt<U288>;
+    pub type U289 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B1>;
+    pub type P289 = PInt<U289>; pub type N289 = NInt<U289>;
+    pub type U290 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B0>;
+    pub type P290 = PInt<U290>; pub type N290 = NInt<U290>;
+    pub type U291 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B1>;
+    pub type P291 = PInt<U291>; pub type N291 = NInt<U291>;
+    pub type U292 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B0>;
+    pub type P292 = PInt<U292>; pub type N292 = NInt<U292>;
+    pub type U293 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B1>;
+    pub type P293 = PInt<U293>; pub type N293 = NInt<U293>;
+    pub type U294 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B0>;
+    pub type P294 = PInt<U294>; pub type N294 = NInt<U294>;
+    pub type U295 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B1>;
+    pub type P295 = PInt<U295>; pub type N295 = NInt<U295>;
+    pub type U296 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B0>;
+    pub type P296 = PInt<U296>; pub type N296 = NInt<U296>;
+    pub type U297 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B1>;
+    pub type P297 = PInt<U297>; pub type N297 = NInt<U297>;
+    pub type U298 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B0>;
+    pub type P298 = PInt<U298>; pub type N298 = NInt<U298>;
+    pub type U299 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B1>;
+    pub type P299 = PInt<U299>; pub type N299 = NInt<U299>;
+    pub type U300 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B0>;
+    pub type P300 = PInt<U300>; pub type N300 = NInt<U300>;
+    pub type U301 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B1>;
+    pub type P301 = PInt<U301>; pub type N301 = NInt<U301>;
+    pub type U302 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B0>;
+    pub type P302 = PInt<U302>; pub type N302 = NInt<U302>;
+    pub type U303 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B1>;
+    pub type P303 = PInt<U303>; pub type N303 = NInt<U303>;
+    pub type U304 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B0>;
+    pub type P304 = PInt<U304>; pub type N304 = NInt<U304>;
+    pub type U305 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B1>;
+    pub type P305 = PInt<U305>; pub type N305 = NInt<U305>;
+    pub type U306 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B0>;
+    pub type P306 = PInt<U306>; pub type N306 = NInt<U306>;
+    pub type U307 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B1>;
+    pub type P307 = PInt<U307>; pub type N307 = NInt<U307>;
+    pub type U308 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B0>;
+    pub type P308 = PInt<U308>; pub type N308 = NInt<U308>;
+    pub type U309 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>;
+    pub type P309 = PInt<U309>; pub type N309 = NInt<U309>;
+    pub type U310 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B0>;
+    pub type P310 = PInt<U310>; pub type N310 = NInt<U310>;
+    pub type U311 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B1>;
+    pub type P311 = PInt<U311>; pub type N311 = NInt<U311>;
+    pub type U312 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>;
+    pub type P312 = PInt<U312>; pub type N312 = NInt<U312>;
+    pub type U313 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B1>;
+    pub type P313 = PInt<U313>; pub type N313 = NInt<U313>;
+    pub type U314 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B0>;
+    pub type P314 = PInt<U314>; pub type N314 = NInt<U314>;
+    pub type U315 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B1>;
+    pub type P315 = PInt<U315>; pub type N315 = NInt<U315>;
+    pub type U316 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B0>;
+    pub type P316 = PInt<U316>; pub type N316 = NInt<U316>;
+    pub type U317 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B1>;
+    pub type P317 = PInt<U317>; pub type N317 = NInt<U317>;
+    pub type U318 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B0>;
+    pub type P318 = PInt<U318>; pub type N318 = NInt<U318>;
+    pub type U319 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B1>;
+    pub type P319 = PInt<U319>; pub type N319 = NInt<U319>;
+    pub type U320 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P320 = PInt<U320>; pub type N320 = NInt<U320>;
+    pub type U321 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B1>;
+    pub type P321 = PInt<U321>; pub type N321 = NInt<U321>;
+    pub type U322 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B0>;
+    pub type P322 = PInt<U322>; pub type N322 = NInt<U322>;
+    pub type U323 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B1>;
+    pub type P323 = PInt<U323>; pub type N323 = NInt<U323>;
+    pub type U324 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B0>;
+    pub type P324 = PInt<U324>; pub type N324 = NInt<U324>;
+    pub type U325 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B1>;
+    pub type P325 = PInt<U325>; pub type N325 = NInt<U325>;
+    pub type U326 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B0>;
+    pub type P326 = PInt<U326>; pub type N326 = NInt<U326>;
+    pub type U327 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B1>;
+    pub type P327 = PInt<U327>; pub type N327 = NInt<U327>;
+    pub type U328 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B0>;
+    pub type P328 = PInt<U328>; pub type N328 = NInt<U328>;
+    pub type U329 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B1>;
+    pub type P329 = PInt<U329>; pub type N329 = NInt<U329>;
+    pub type U330 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B0>;
+    pub type P330 = PInt<U330>; pub type N330 = NInt<U330>;
+    pub type U331 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B1>;
+    pub type P331 = PInt<U331>; pub type N331 = NInt<U331>;
+    pub type U332 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B0>;
+    pub type P332 = PInt<U332>; pub type N332 = NInt<U332>;
+    pub type U333 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B1>;
+    pub type P333 = PInt<U333>; pub type N333 = NInt<U333>;
+    pub type U334 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B0>;
+    pub type P334 = PInt<U334>; pub type N334 = NInt<U334>;
+    pub type U335 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B1>;
+    pub type P335 = PInt<U335>; pub type N335 = NInt<U335>;
+    pub type U336 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>;
+    pub type P336 = PInt<U336>; pub type N336 = NInt<U336>;
+    pub type U337 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B1>;
+    pub type P337 = PInt<U337>; pub type N337 = NInt<U337>;
+    pub type U338 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B0>;
+    pub type P338 = PInt<U338>; pub type N338 = NInt<U338>;
+    pub type U339 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B1>;
+    pub type P339 = PInt<U339>; pub type N339 = NInt<U339>;
+    pub type U340 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B0>;
+    pub type P340 = PInt<U340>; pub type N340 = NInt<U340>;
+    pub type U341 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B1>;
+    pub type P341 = PInt<U341>; pub type N341 = NInt<U341>;
+    pub type U342 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B0>;
+    pub type P342 = PInt<U342>; pub type N342 = NInt<U342>;
+    pub type U343 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B1>;
+    pub type P343 = PInt<U343>; pub type N343 = NInt<U343>;
+    pub type U344 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B0>;
+    pub type P344 = PInt<U344>; pub type N344 = NInt<U344>;
+    pub type U345 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B1>;
+    pub type P345 = PInt<U345>; pub type N345 = NInt<U345>;
+    pub type U346 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B0>;
+    pub type P346 = PInt<U346>; pub type N346 = NInt<U346>;
+    pub type U347 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B1>;
+    pub type P347 = PInt<U347>; pub type N347 = NInt<U347>;
+    pub type U348 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B0>;
+    pub type P348 = PInt<U348>; pub type N348 = NInt<U348>;
+    pub type U349 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B1>;
+    pub type P349 = PInt<U349>; pub type N349 = NInt<U349>;
+    pub type U350 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B0>;
+    pub type P350 = PInt<U350>; pub type N350 = NInt<U350>;
+    pub type U351 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B1>;
+    pub type P351 = PInt<U351>; pub type N351 = NInt<U351>;
+    pub type U352 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B0>;
+    pub type P352 = PInt<U352>; pub type N352 = NInt<U352>;
+    pub type U353 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B1>;
+    pub type P353 = PInt<U353>; pub type N353 = NInt<U353>;
+    pub type U354 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B0>;
+    pub type P354 = PInt<U354>; pub type N354 = NInt<U354>;
+    pub type U355 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B1>;
+    pub type P355 = PInt<U355>; pub type N355 = NInt<U355>;
+    pub type U356 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B0>;
+    pub type P356 = PInt<U356>; pub type N356 = NInt<U356>;
+    pub type U357 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B1>;
+    pub type P357 = PInt<U357>; pub type N357 = NInt<U357>;
+    pub type U358 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B0>;
+    pub type P358 = PInt<U358>; pub type N358 = NInt<U358>;
+    pub type U359 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B1>;
+    pub type P359 = PInt<U359>; pub type N359 = NInt<U359>;
+    pub type U360 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B0>;
+    pub type P360 = PInt<U360>; pub type N360 = NInt<U360>;
+    pub type U361 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B1>;
+    pub type P361 = PInt<U361>; pub type N361 = NInt<U361>;
+    pub type U362 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B0>;
+    pub type P362 = PInt<U362>; pub type N362 = NInt<U362>;
+    pub type U363 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B1>;
+    pub type P363 = PInt<U363>; pub type N363 = NInt<U363>;
+    pub type U364 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B0>;
+    pub type P364 = PInt<U364>; pub type N364 = NInt<U364>;
+    pub type U365 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B1>;
+    pub type P365 = PInt<U365>; pub type N365 = NInt<U365>;
+    pub type U366 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B0>;
+    pub type P366 = PInt<U366>; pub type N366 = NInt<U366>;
+    pub type U367 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B1>;
+    pub type P367 = PInt<U367>; pub type N367 = NInt<U367>;
+    pub type U368 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B0>;
+    pub type P368 = PInt<U368>; pub type N368 = NInt<U368>;
+    pub type U369 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>;
+    pub type P369 = PInt<U369>; pub type N369 = NInt<U369>;
+    pub type U370 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B0>;
+    pub type P370 = PInt<U370>; pub type N370 = NInt<U370>;
+    pub type U371 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B1>;
+    pub type P371 = PInt<U371>; pub type N371 = NInt<U371>;
+    pub type U372 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B0>;
+    pub type P372 = PInt<U372>; pub type N372 = NInt<U372>;
+    pub type U373 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B1>;
+    pub type P373 = PInt<U373>; pub type N373 = NInt<U373>;
+    pub type U374 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B0>;
+    pub type P374 = PInt<U374>; pub type N374 = NInt<U374>;
+    pub type U375 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B1>;
+    pub type P375 = PInt<U375>; pub type N375 = NInt<U375>;
+    pub type U376 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B0>;
+    pub type P376 = PInt<U376>; pub type N376 = NInt<U376>;
+    pub type U377 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B1>;
+    pub type P377 = PInt<U377>; pub type N377 = NInt<U377>;
+    pub type U378 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B0>;
+    pub type P378 = PInt<U378>; pub type N378 = NInt<U378>;
+    pub type U379 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B1>;
+    pub type P379 = PInt<U379>; pub type N379 = NInt<U379>;
+    pub type U380 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B0>;
+    pub type P380 = PInt<U380>; pub type N380 = NInt<U380>;
+    pub type U381 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B1>;
+    pub type P381 = PInt<U381>; pub type N381 = NInt<U381>;
+    pub type U382 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B0>;
+    pub type P382 = PInt<U382>; pub type N382 = NInt<U382>;
+    pub type U383 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B1>;
+    pub type P383 = PInt<U383>; pub type N383 = NInt<U383>;
+    pub type U384 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P384 = PInt<U384>; pub type N384 = NInt<U384>;
+    pub type U385 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>;
+    pub type P385 = PInt<U385>; pub type N385 = NInt<U385>;
+    pub type U386 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>;
+    pub type P386 = PInt<U386>; pub type N386 = NInt<U386>;
+    pub type U387 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>;
+    pub type P387 = PInt<U387>; pub type N387 = NInt<U387>;
+    pub type U388 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>;
+    pub type P388 = PInt<U388>; pub type N388 = NInt<U388>;
+    pub type U389 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>;
+    pub type P389 = PInt<U389>; pub type N389 = NInt<U389>;
+    pub type U390 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>;
+    pub type P390 = PInt<U390>; pub type N390 = NInt<U390>;
+    pub type U391 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>;
+    pub type P391 = PInt<U391>; pub type N391 = NInt<U391>;
+    pub type U392 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>;
+    pub type P392 = PInt<U392>; pub type N392 = NInt<U392>;
+    pub type U393 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>;
+    pub type P393 = PInt<U393>; pub type N393 = NInt<U393>;
+    pub type U394 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>;
+    pub type P394 = PInt<U394>; pub type N394 = NInt<U394>;
+    pub type U395 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>;
+    pub type P395 = PInt<U395>; pub type N395 = NInt<U395>;
+    pub type U396 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>;
+    pub type P396 = PInt<U396>; pub type N396 = NInt<U396>;
+    pub type U397 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>;
+    pub type P397 = PInt<U397>; pub type N397 = NInt<U397>;
+    pub type U398 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>;
+    pub type P398 = PInt<U398>; pub type N398 = NInt<U398>;
+    pub type U399 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>;
+    pub type P399 = PInt<U399>; pub type N399 = NInt<U399>;
+    pub type U400 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>;
+    pub type P400 = PInt<U400>; pub type N400 = NInt<U400>;
+    pub type U401 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>;
+    pub type P401 = PInt<U401>; pub type N401 = NInt<U401>;
+    pub type U402 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>;
+    pub type P402 = PInt<U402>; pub type N402 = NInt<U402>;
+    pub type U403 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>;
+    pub type P403 = PInt<U403>; pub type N403 = NInt<U403>;
+    pub type U404 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>;
+    pub type P404 = PInt<U404>; pub type N404 = NInt<U404>;
+    pub type U405 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>;
+    pub type P405 = PInt<U405>; pub type N405 = NInt<U405>;
+    pub type U406 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>;
+    pub type P406 = PInt<U406>; pub type N406 = NInt<U406>;
+    pub type U407 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>;
+    pub type P407 = PInt<U407>; pub type N407 = NInt<U407>;
+    pub type U408 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>;
+    pub type P408 = PInt<U408>; pub type N408 = NInt<U408>;
+    pub type U409 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>;
+    pub type P409 = PInt<U409>; pub type N409 = NInt<U409>;
+    pub type U410 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>;
+    pub type P410 = PInt<U410>; pub type N410 = NInt<U410>;
+    pub type U411 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>;
+    pub type P411 = PInt<U411>; pub type N411 = NInt<U411>;
+    pub type U412 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>;
+    pub type P412 = PInt<U412>; pub type N412 = NInt<U412>;
+    pub type U413 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>;
+    pub type P413 = PInt<U413>; pub type N413 = NInt<U413>;
+    pub type U414 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>;
+    pub type P414 = PInt<U414>; pub type N414 = NInt<U414>;
+    pub type U415 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>;
+    pub type P415 = PInt<U415>; pub type N415 = NInt<U415>;
+    pub type U416 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;
+    pub type P416 = PInt<U416>; pub type N416 = NInt<U416>;
+    pub type U417 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>;
+    pub type P417 = PInt<U417>; pub type N417 = NInt<U417>;
+    pub type U418 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>;
+    pub type P418 = PInt<U418>; pub type N418 = NInt<U418>;
+    pub type U419 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>;
+    pub type P419 = PInt<U419>; pub type N419 = NInt<U419>;
+    pub type U420 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>;
+    pub type P420 = PInt<U420>; pub type N420 = NInt<U420>;
+    pub type U421 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>;
+    pub type P421 = PInt<U421>; pub type N421 = NInt<U421>;
+    pub type U422 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>;
+    pub type P422 = PInt<U422>; pub type N422 = NInt<U422>;
+    pub type U423 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>;
+    pub type P423 = PInt<U423>; pub type N423 = NInt<U423>;
+    pub type U424 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>;
+    pub type P424 = PInt<U424>; pub type N424 = NInt<U424>;
+    pub type U425 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>;
+    pub type P425 = PInt<U425>; pub type N425 = NInt<U425>;
+    pub type U426 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>;
+    pub type P426 = PInt<U426>; pub type N426 = NInt<U426>;
+    pub type U427 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>;
+    pub type P427 = PInt<U427>; pub type N427 = NInt<U427>;
+    pub type U428 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>;
+    pub type P428 = PInt<U428>; pub type N428 = NInt<U428>;
+    pub type U429 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>;
+    pub type P429 = PInt<U429>; pub type N429 = NInt<U429>;
+    pub type U430 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>;
+    pub type P430 = PInt<U430>; pub type N430 = NInt<U430>;
+    pub type U431 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>;
+    pub type P431 = PInt<U431>; pub type N431 = NInt<U431>;
+    pub type U432 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>;
+    pub type P432 = PInt<U432>; pub type N432 = NInt<U432>;
+    pub type U433 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>;
+    pub type P433 = PInt<U433>; pub type N433 = NInt<U433>;
+    pub type U434 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>;
+    pub type P434 = PInt<U434>; pub type N434 = NInt<U434>;
+    pub type U435 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>;
+    pub type P435 = PInt<U435>; pub type N435 = NInt<U435>;
+    pub type U436 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>;
+    pub type P436 = PInt<U436>; pub type N436 = NInt<U436>;
+    pub type U437 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>;
+    pub type P437 = PInt<U437>; pub type N437 = NInt<U437>;
+    pub type U438 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>;
+    pub type P438 = PInt<U438>; pub type N438 = NInt<U438>;
+    pub type U439 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>;
+    pub type P439 = PInt<U439>; pub type N439 = NInt<U439>;
+    pub type U440 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>;
+    pub type P440 = PInt<U440>; pub type N440 = NInt<U440>;
+    pub type U441 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>;
+    pub type P441 = PInt<U441>; pub type N441 = NInt<U441>;
+    pub type U442 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>;
+    pub type P442 = PInt<U442>; pub type N442 = NInt<U442>;
+    pub type U443 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>;
+    pub type P443 = PInt<U443>; pub type N443 = NInt<U443>;
+    pub type U444 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>;
+    pub type P444 = PInt<U444>; pub type N444 = NInt<U444>;
+    pub type U445 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>;
+    pub type P445 = PInt<U445>; pub type N445 = NInt<U445>;
+    pub type U446 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>;
+    pub type P446 = PInt<U446>; pub type N446 = NInt<U446>;
+    pub type U447 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>;
+    pub type P447 = PInt<U447>; pub type N447 = NInt<U447>;
+    pub type U448 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P448 = PInt<U448>; pub type N448 = NInt<U448>;
+    pub type U449 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>;
+    pub type P449 = PInt<U449>; pub type N449 = NInt<U449>;
+    pub type U450 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>;
+    pub type P450 = PInt<U450>; pub type N450 = NInt<U450>;
+    pub type U451 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>;
+    pub type P451 = PInt<U451>; pub type N451 = NInt<U451>;
+    pub type U452 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>;
+    pub type P452 = PInt<U452>; pub type N452 = NInt<U452>;
+    pub type U453 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>;
+    pub type P453 = PInt<U453>; pub type N453 = NInt<U453>;
+    pub type U454 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>;
+    pub type P454 = PInt<U454>; pub type N454 = NInt<U454>;
+    pub type U455 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>;
+    pub type P455 = PInt<U455>; pub type N455 = NInt<U455>;
+    pub type U456 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>;
+    pub type P456 = PInt<U456>; pub type N456 = NInt<U456>;
+    pub type U457 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>;
+    pub type P457 = PInt<U457>; pub type N457 = NInt<U457>;
+    pub type U458 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>;
+    pub type P458 = PInt<U458>; pub type N458 = NInt<U458>;
+    pub type U459 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>;
+    pub type P459 = PInt<U459>; pub type N459 = NInt<U459>;
+    pub type U460 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>;
+    pub type P460 = PInt<U460>; pub type N460 = NInt<U460>;
+    pub type U461 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>;
+    pub type P461 = PInt<U461>; pub type N461 = NInt<U461>;
+    pub type U462 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>;
+    pub type P462 = PInt<U462>; pub type N462 = NInt<U462>;
+    pub type U463 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>;
+    pub type P463 = PInt<U463>; pub type N463 = NInt<U463>;
+    pub type U464 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>;
+    pub type P464 = PInt<U464>; pub type N464 = NInt<U464>;
+    pub type U465 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>;
+    pub type P465 = PInt<U465>; pub type N465 = NInt<U465>;
+    pub type U466 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>;
+    pub type P466 = PInt<U466>; pub type N466 = NInt<U466>;
+    pub type U467 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>;
+    pub type P467 = PInt<U467>; pub type N467 = NInt<U467>;
+    pub type U468 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>;
+    pub type P468 = PInt<U468>; pub type N468 = NInt<U468>;
+    pub type U469 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>;
+    pub type P469 = PInt<U469>; pub type N469 = NInt<U469>;
+    pub type U470 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>;
+    pub type P470 = PInt<U470>; pub type N470 = NInt<U470>;
+    pub type U471 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>;
+    pub type P471 = PInt<U471>; pub type N471 = NInt<U471>;
+    pub type U472 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>;
+    pub type P472 = PInt<U472>; pub type N472 = NInt<U472>;
+    pub type U473 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>;
+    pub type P473 = PInt<U473>; pub type N473 = NInt<U473>;
+    pub type U474 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>;
+    pub type P474 = PInt<U474>; pub type N474 = NInt<U474>;
+    pub type U475 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>;
+    pub type P475 = PInt<U475>; pub type N475 = NInt<U475>;
+    pub type U476 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>;
+    pub type P476 = PInt<U476>; pub type N476 = NInt<U476>;
+    pub type U477 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>;
+    pub type P477 = PInt<U477>; pub type N477 = NInt<U477>;
+    pub type U478 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>;
+    pub type P478 = PInt<U478>; pub type N478 = NInt<U478>;
+    pub type U479 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>;
+    pub type P479 = PInt<U479>; pub type N479 = NInt<U479>;
+    pub type U480 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>;
+    pub type P480 = PInt<U480>; pub type N480 = NInt<U480>;
+    pub type U481 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>;
+    pub type P481 = PInt<U481>; pub type N481 = NInt<U481>;
+    pub type U482 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>;
+    pub type P482 = PInt<U482>; pub type N482 = NInt<U482>;
+    pub type U483 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>;
+    pub type P483 = PInt<U483>; pub type N483 = NInt<U483>;
+    pub type U484 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>;
+    pub type P484 = PInt<U484>; pub type N484 = NInt<U484>;
+    pub type U485 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>;
+    pub type P485 = PInt<U485>; pub type N485 = NInt<U485>;
+    pub type U486 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>;
+    pub type P486 = PInt<U486>; pub type N486 = NInt<U486>;
+    pub type U487 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>;
+    pub type P487 = PInt<U487>; pub type N487 = NInt<U487>;
+    pub type U488 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>;
+    pub type P488 = PInt<U488>; pub type N488 = NInt<U488>;
+    pub type U489 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>;
+    pub type P489 = PInt<U489>; pub type N489 = NInt<U489>;
+    pub type U490 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>;
+    pub type P490 = PInt<U490>; pub type N490 = NInt<U490>;
+    pub type U491 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>;
+    pub type P491 = PInt<U491>; pub type N491 = NInt<U491>;
+    pub type U492 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>;
+    pub type P492 = PInt<U492>; pub type N492 = NInt<U492>;
+    pub type U493 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>;
+    pub type P493 = PInt<U493>; pub type N493 = NInt<U493>;
+    pub type U494 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>;
+    pub type P494 = PInt<U494>; pub type N494 = NInt<U494>;
+    pub type U495 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>;
+    pub type P495 = PInt<U495>; pub type N495 = NInt<U495>;
+    pub type U496 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>;
+    pub type P496 = PInt<U496>; pub type N496 = NInt<U496>;
+    pub type U497 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>;
+    pub type P497 = PInt<U497>; pub type N497 = NInt<U497>;
+    pub type U498 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>;
+    pub type P498 = PInt<U498>; pub type N498 = NInt<U498>;
+    pub type U499 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>;
+    pub type P499 = PInt<U499>; pub type N499 = NInt<U499>;
+    pub type U500 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>;
+    pub type P500 = PInt<U500>; pub type N500 = NInt<U500>;
+    pub type U501 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>;
+    pub type P501 = PInt<U501>; pub type N501 = NInt<U501>;
+    pub type U502 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>;
+    pub type P502 = PInt<U502>; pub type N502 = NInt<U502>;
+    pub type U503 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>;
+    pub type P503 = PInt<U503>; pub type N503 = NInt<U503>;
+    pub type U504 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>;
+    pub type P504 = PInt<U504>; pub type N504 = NInt<U504>;
+    pub type U505 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>;
+    pub type P505 = PInt<U505>; pub type N505 = NInt<U505>;
+    pub type U506 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>;
+    pub type P506 = PInt<U506>; pub type N506 = NInt<U506>;
+    pub type U507 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>;
+    pub type P507 = PInt<U507>; pub type N507 = NInt<U507>;
+    pub type U508 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>;
+    pub type P508 = PInt<U508>; pub type N508 = NInt<U508>;
+    pub type U509 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>;
+    pub type P509 = PInt<U509>; pub type N509 = NInt<U509>;
+    pub type U510 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>;
+    pub type P510 = PInt<U510>; pub type N510 = NInt<U510>;
+    pub type U511 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>;
+    pub type P511 = PInt<U511>; pub type N511 = NInt<U511>;
+    pub type U512 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P512 = PInt<U512>; pub type N512 = NInt<U512>;
+    pub type U513 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B1>;
+    pub type P513 = PInt<U513>; pub type N513 = NInt<U513>;
+    pub type U514 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B0>;
+    pub type P514 = PInt<U514>; pub type N514 = NInt<U514>;
+    pub type U515 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B1>;
+    pub type P515 = PInt<U515>; pub type N515 = NInt<U515>;
+    pub type U516 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B0>;
+    pub type P516 = PInt<U516>; pub type N516 = NInt<U516>;
+    pub type U517 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B1>;
+    pub type P517 = PInt<U517>; pub type N517 = NInt<U517>;
+    pub type U518 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B0>;
+    pub type P518 = PInt<U518>; pub type N518 = NInt<U518>;
+    pub type U519 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B1>;
+    pub type P519 = PInt<U519>; pub type N519 = NInt<U519>;
+    pub type U520 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B0>;
+    pub type P520 = PInt<U520>; pub type N520 = NInt<U520>;
+    pub type U521 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B1>;
+    pub type P521 = PInt<U521>; pub type N521 = NInt<U521>;
+    pub type U522 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B0>;
+    pub type P522 = PInt<U522>; pub type N522 = NInt<U522>;
+    pub type U523 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B1>;
+    pub type P523 = PInt<U523>; pub type N523 = NInt<U523>;
+    pub type U524 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B0>;
+    pub type P524 = PInt<U524>; pub type N524 = NInt<U524>;
+    pub type U525 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>;
+    pub type P525 = PInt<U525>; pub type N525 = NInt<U525>;
+    pub type U526 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B0>;
+    pub type P526 = PInt<U526>; pub type N526 = NInt<U526>;
+    pub type U527 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B1>;
+    pub type P527 = PInt<U527>; pub type N527 = NInt<U527>;
+    pub type U528 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>;
+    pub type P528 = PInt<U528>; pub type N528 = NInt<U528>;
+    pub type U529 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B1>;
+    pub type P529 = PInt<U529>; pub type N529 = NInt<U529>;
+    pub type U530 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B0>;
+    pub type P530 = PInt<U530>; pub type N530 = NInt<U530>;
+    pub type U531 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B1>;
+    pub type P531 = PInt<U531>; pub type N531 = NInt<U531>;
+    pub type U532 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B0>;
+    pub type P532 = PInt<U532>; pub type N532 = NInt<U532>;
+    pub type U533 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B1>;
+    pub type P533 = PInt<U533>; pub type N533 = NInt<U533>;
+    pub type U534 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B0>;
+    pub type P534 = PInt<U534>; pub type N534 = NInt<U534>;
+    pub type U535 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B1>;
+    pub type P535 = PInt<U535>; pub type N535 = NInt<U535>;
+    pub type U536 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B0>;
+    pub type P536 = PInt<U536>; pub type N536 = NInt<U536>;
+    pub type U537 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B1>;
+    pub type P537 = PInt<U537>; pub type N537 = NInt<U537>;
+    pub type U538 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>;
+    pub type P538 = PInt<U538>; pub type N538 = NInt<U538>;
+    pub type U539 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B1>;
+    pub type P539 = PInt<U539>; pub type N539 = NInt<U539>;
+    pub type U540 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B0>;
+    pub type P540 = PInt<U540>; pub type N540 = NInt<U540>;
+    pub type U541 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B1>;
+    pub type P541 = PInt<U541>; pub type N541 = NInt<U541>;
+    pub type U542 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B0>;
+    pub type P542 = PInt<U542>; pub type N542 = NInt<U542>;
+    pub type U543 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B1>;
+    pub type P543 = PInt<U543>; pub type N543 = NInt<U543>;
+    pub type U544 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;
+    pub type P544 = PInt<U544>; pub type N544 = NInt<U544>;
+    pub type U545 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B1>;
+    pub type P545 = PInt<U545>; pub type N545 = NInt<U545>;
+    pub type U546 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B0>;
+    pub type P546 = PInt<U546>; pub type N546 = NInt<U546>;
+    pub type U547 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B1>;
+    pub type P547 = PInt<U547>; pub type N547 = NInt<U547>;
+    pub type U548 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B0>;
+    pub type P548 = PInt<U548>; pub type N548 = NInt<U548>;
+    pub type U549 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B1>;
+    pub type P549 = PInt<U549>; pub type N549 = NInt<U549>;
+    pub type U550 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B0>;
+    pub type P550 = PInt<U550>; pub type N550 = NInt<U550>;
+    pub type U551 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B1>;
+    pub type P551 = PInt<U551>; pub type N551 = NInt<U551>;
+    pub type U552 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B0>;
+    pub type P552 = PInt<U552>; pub type N552 = NInt<U552>;
+    pub type U553 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B1>;
+    pub type P553 = PInt<U553>; pub type N553 = NInt<U553>;
+    pub type U554 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B0>;
+    pub type P554 = PInt<U554>; pub type N554 = NInt<U554>;
+    pub type U555 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B1>;
+    pub type P555 = PInt<U555>; pub type N555 = NInt<U555>;
+    pub type U556 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B0>;
+    pub type P556 = PInt<U556>; pub type N556 = NInt<U556>;
+    pub type U557 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B1>;
+    pub type P557 = PInt<U557>; pub type N557 = NInt<U557>;
+    pub type U558 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B0>;
+    pub type P558 = PInt<U558>; pub type N558 = NInt<U558>;
+    pub type U559 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B1>;
+    pub type P559 = PInt<U559>; pub type N559 = NInt<U559>;
+    pub type U560 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B0>;
+    pub type P560 = PInt<U560>; pub type N560 = NInt<U560>;
+    pub type U561 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B1>;
+    pub type P561 = PInt<U561>; pub type N561 = NInt<U561>;
+    pub type U562 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B0>;
+    pub type P562 = PInt<U562>; pub type N562 = NInt<U562>;
+    pub type U563 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B1>;
+    pub type P563 = PInt<U563>; pub type N563 = NInt<U563>;
+    pub type U564 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B0>;
+    pub type P564 = PInt<U564>; pub type N564 = NInt<U564>;
+    pub type U565 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>;
+    pub type P565 = PInt<U565>; pub type N565 = NInt<U565>;
+    pub type U566 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B0>;
+    pub type P566 = PInt<U566>; pub type N566 = NInt<U566>;
+    pub type U567 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B1>;
+    pub type P567 = PInt<U567>; pub type N567 = NInt<U567>;
+    pub type U568 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>;
+    pub type P568 = PInt<U568>; pub type N568 = NInt<U568>;
+    pub type U569 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B1>;
+    pub type P569 = PInt<U569>; pub type N569 = NInt<U569>;
+    pub type U570 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B0>;
+    pub type P570 = PInt<U570>; pub type N570 = NInt<U570>;
+    pub type U571 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B1>;
+    pub type P571 = PInt<U571>; pub type N571 = NInt<U571>;
+    pub type U572 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B0>;
+    pub type P572 = PInt<U572>; pub type N572 = NInt<U572>;
+    pub type U573 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B1>;
+    pub type P573 = PInt<U573>; pub type N573 = NInt<U573>;
+    pub type U574 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B0>;
+    pub type P574 = PInt<U574>; pub type N574 = NInt<U574>;
+    pub type U575 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B1>;
+    pub type P575 = PInt<U575>; pub type N575 = NInt<U575>;
+    pub type U576 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P576 = PInt<U576>; pub type N576 = NInt<U576>;
+    pub type U577 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B1>;
+    pub type P577 = PInt<U577>; pub type N577 = NInt<U577>;
+    pub type U578 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B0>;
+    pub type P578 = PInt<U578>; pub type N578 = NInt<U578>;
+    pub type U579 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B1>;
+    pub type P579 = PInt<U579>; pub type N579 = NInt<U579>;
+    pub type U580 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B0>;
+    pub type P580 = PInt<U580>; pub type N580 = NInt<U580>;
+    pub type U581 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B1>;
+    pub type P581 = PInt<U581>; pub type N581 = NInt<U581>;
+    pub type U582 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B0>;
+    pub type P582 = PInt<U582>; pub type N582 = NInt<U582>;
+    pub type U583 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B1>;
+    pub type P583 = PInt<U583>; pub type N583 = NInt<U583>;
+    pub type U584 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B0>;
+    pub type P584 = PInt<U584>; pub type N584 = NInt<U584>;
+    pub type U585 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B1>;
+    pub type P585 = PInt<U585>; pub type N585 = NInt<U585>;
+    pub type U586 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B0>;
+    pub type P586 = PInt<U586>; pub type N586 = NInt<U586>;
+    pub type U587 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B1>;
+    pub type P587 = PInt<U587>; pub type N587 = NInt<U587>;
+    pub type U588 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B0>;
+    pub type P588 = PInt<U588>; pub type N588 = NInt<U588>;
+    pub type U589 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B1>;
+    pub type P589 = PInt<U589>; pub type N589 = NInt<U589>;
+    pub type U590 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B0>;
+    pub type P590 = PInt<U590>; pub type N590 = NInt<U590>;
+    pub type U591 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B1>;
+    pub type P591 = PInt<U591>; pub type N591 = NInt<U591>;
+    pub type U592 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>;
+    pub type P592 = PInt<U592>; pub type N592 = NInt<U592>;
+    pub type U593 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B1>;
+    pub type P593 = PInt<U593>; pub type N593 = NInt<U593>;
+    pub type U594 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B0>;
+    pub type P594 = PInt<U594>; pub type N594 = NInt<U594>;
+    pub type U595 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B1>;
+    pub type P595 = PInt<U595>; pub type N595 = NInt<U595>;
+    pub type U596 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B0>;
+    pub type P596 = PInt<U596>; pub type N596 = NInt<U596>;
+    pub type U597 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B1>;
+    pub type P597 = PInt<U597>; pub type N597 = NInt<U597>;
+    pub type U598 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B0>;
+    pub type P598 = PInt<U598>; pub type N598 = NInt<U598>;
+    pub type U599 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B1>;
+    pub type P599 = PInt<U599>; pub type N599 = NInt<U599>;
+    pub type U600 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B0>;
+    pub type P600 = PInt<U600>; pub type N600 = NInt<U600>;
+    pub type U601 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B1>;
+    pub type P601 = PInt<U601>; pub type N601 = NInt<U601>;
+    pub type U602 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B0>;
+    pub type P602 = PInt<U602>; pub type N602 = NInt<U602>;
+    pub type U603 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B1>;
+    pub type P603 = PInt<U603>; pub type N603 = NInt<U603>;
+    pub type U604 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B0>;
+    pub type P604 = PInt<U604>; pub type N604 = NInt<U604>;
+    pub type U605 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B1>;
+    pub type P605 = PInt<U605>; pub type N605 = NInt<U605>;
+    pub type U606 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B0>;
+    pub type P606 = PInt<U606>; pub type N606 = NInt<U606>;
+    pub type U607 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B1>;
+    pub type P607 = PInt<U607>; pub type N607 = NInt<U607>;
+    pub type U608 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B0>;
+    pub type P608 = PInt<U608>; pub type N608 = NInt<U608>;
+    pub type U609 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B1>;
+    pub type P609 = PInt<U609>; pub type N609 = NInt<U609>;
+    pub type U610 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B0>;
+    pub type P610 = PInt<U610>; pub type N610 = NInt<U610>;
+    pub type U611 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B1>;
+    pub type P611 = PInt<U611>; pub type N611 = NInt<U611>;
+    pub type U612 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B0>;
+    pub type P612 = PInt<U612>; pub type N612 = NInt<U612>;
+    pub type U613 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B1>;
+    pub type P613 = PInt<U613>; pub type N613 = NInt<U613>;
+    pub type U614 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B0>;
+    pub type P614 = PInt<U614>; pub type N614 = NInt<U614>;
+    pub type U615 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B1>;
+    pub type P615 = PInt<U615>; pub type N615 = NInt<U615>;
+    pub type U616 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B0>;
+    pub type P616 = PInt<U616>; pub type N616 = NInt<U616>;
+    pub type U617 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B1>;
+    pub type P617 = PInt<U617>; pub type N617 = NInt<U617>;
+    pub type U618 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B0>;
+    pub type P618 = PInt<U618>; pub type N618 = NInt<U618>;
+    pub type U619 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B1>;
+    pub type P619 = PInt<U619>; pub type N619 = NInt<U619>;
+    pub type U620 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B0>;
+    pub type P620 = PInt<U620>; pub type N620 = NInt<U620>;
+    pub type U621 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B1>;
+    pub type P621 = PInt<U621>; pub type N621 = NInt<U621>;
+    pub type U622 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B0>;
+    pub type P622 = PInt<U622>; pub type N622 = NInt<U622>;
+    pub type U623 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B1>;
+    pub type P623 = PInt<U623>; pub type N623 = NInt<U623>;
+    pub type U624 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B0>;
+    pub type P624 = PInt<U624>; pub type N624 = NInt<U624>;
+    pub type U625 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>;
+    pub type P625 = PInt<U625>; pub type N625 = NInt<U625>;
+    pub type U626 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B0>;
+    pub type P626 = PInt<U626>; pub type N626 = NInt<U626>;
+    pub type U627 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B1>;
+    pub type P627 = PInt<U627>; pub type N627 = NInt<U627>;
+    pub type U628 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B0>;
+    pub type P628 = PInt<U628>; pub type N628 = NInt<U628>;
+    pub type U629 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B1>;
+    pub type P629 = PInt<U629>; pub type N629 = NInt<U629>;
+    pub type U630 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B0>;
+    pub type P630 = PInt<U630>; pub type N630 = NInt<U630>;
+    pub type U631 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B1>;
+    pub type P631 = PInt<U631>; pub type N631 = NInt<U631>;
+    pub type U632 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B0>;
+    pub type P632 = PInt<U632>; pub type N632 = NInt<U632>;
+    pub type U633 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B1>;
+    pub type P633 = PInt<U633>; pub type N633 = NInt<U633>;
+    pub type U634 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B0>;
+    pub type P634 = PInt<U634>; pub type N634 = NInt<U634>;
+    pub type U635 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B1>;
+    pub type P635 = PInt<U635>; pub type N635 = NInt<U635>;
+    pub type U636 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B0>;
+    pub type P636 = PInt<U636>; pub type N636 = NInt<U636>;
+    pub type U637 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B1>;
+    pub type P637 = PInt<U637>; pub type N637 = NInt<U637>;
+    pub type U638 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B0>;
+    pub type P638 = PInt<U638>; pub type N638 = NInt<U638>;
+    pub type U639 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B1>;
+    pub type P639 = PInt<U639>; pub type N639 = NInt<U639>;
+    pub type U640 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P640 = PInt<U640>; pub type N640 = NInt<U640>;
+    pub type U641 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>;
+    pub type P641 = PInt<U641>; pub type N641 = NInt<U641>;
+    pub type U642 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>;
+    pub type P642 = PInt<U642>; pub type N642 = NInt<U642>;
+    pub type U643 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>;
+    pub type P643 = PInt<U643>; pub type N643 = NInt<U643>;
+    pub type U644 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>;
+    pub type P644 = PInt<U644>; pub type N644 = NInt<U644>;
+    pub type U645 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>;
+    pub type P645 = PInt<U645>; pub type N645 = NInt<U645>;
+    pub type U646 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>;
+    pub type P646 = PInt<U646>; pub type N646 = NInt<U646>;
+    pub type U647 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>;
+    pub type P647 = PInt<U647>; pub type N647 = NInt<U647>;
+    pub type U648 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>;
+    pub type P648 = PInt<U648>; pub type N648 = NInt<U648>;
+    pub type U649 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>;
+    pub type P649 = PInt<U649>; pub type N649 = NInt<U649>;
+    pub type U650 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>;
+    pub type P650 = PInt<U650>; pub type N650 = NInt<U650>;
+    pub type U651 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>;
+    pub type P651 = PInt<U651>; pub type N651 = NInt<U651>;
+    pub type U652 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>;
+    pub type P652 = PInt<U652>; pub type N652 = NInt<U652>;
+    pub type U653 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>;
+    pub type P653 = PInt<U653>; pub type N653 = NInt<U653>;
+    pub type U654 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>;
+    pub type P654 = PInt<U654>; pub type N654 = NInt<U654>;
+    pub type U655 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>;
+    pub type P655 = PInt<U655>; pub type N655 = NInt<U655>;
+    pub type U656 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>;
+    pub type P656 = PInt<U656>; pub type N656 = NInt<U656>;
+    pub type U657 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>;
+    pub type P657 = PInt<U657>; pub type N657 = NInt<U657>;
+    pub type U658 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>;
+    pub type P658 = PInt<U658>; pub type N658 = NInt<U658>;
+    pub type U659 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>;
+    pub type P659 = PInt<U659>; pub type N659 = NInt<U659>;
+    pub type U660 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>;
+    pub type P660 = PInt<U660>; pub type N660 = NInt<U660>;
+    pub type U661 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>;
+    pub type P661 = PInt<U661>; pub type N661 = NInt<U661>;
+    pub type U662 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>;
+    pub type P662 = PInt<U662>; pub type N662 = NInt<U662>;
+    pub type U663 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>;
+    pub type P663 = PInt<U663>; pub type N663 = NInt<U663>;
+    pub type U664 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>;
+    pub type P664 = PInt<U664>; pub type N664 = NInt<U664>;
+    pub type U665 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>;
+    pub type P665 = PInt<U665>; pub type N665 = NInt<U665>;
+    pub type U666 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>;
+    pub type P666 = PInt<U666>; pub type N666 = NInt<U666>;
+    pub type U667 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>;
+    pub type P667 = PInt<U667>; pub type N667 = NInt<U667>;
+    pub type U668 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>;
+    pub type P668 = PInt<U668>; pub type N668 = NInt<U668>;
+    pub type U669 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>;
+    pub type P669 = PInt<U669>; pub type N669 = NInt<U669>;
+    pub type U670 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>;
+    pub type P670 = PInt<U670>; pub type N670 = NInt<U670>;
+    pub type U671 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>;
+    pub type P671 = PInt<U671>; pub type N671 = NInt<U671>;
+    pub type U672 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;
+    pub type P672 = PInt<U672>; pub type N672 = NInt<U672>;
+    pub type U673 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>;
+    pub type P673 = PInt<U673>; pub type N673 = NInt<U673>;
+    pub type U674 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>;
+    pub type P674 = PInt<U674>; pub type N674 = NInt<U674>;
+    pub type U675 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>;
+    pub type P675 = PInt<U675>; pub type N675 = NInt<U675>;
+    pub type U676 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>;
+    pub type P676 = PInt<U676>; pub type N676 = NInt<U676>;
+    pub type U677 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>;
+    pub type P677 = PInt<U677>; pub type N677 = NInt<U677>;
+    pub type U678 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>;
+    pub type P678 = PInt<U678>; pub type N678 = NInt<U678>;
+    pub type U679 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>;
+    pub type P679 = PInt<U679>; pub type N679 = NInt<U679>;
+    pub type U680 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>;
+    pub type P680 = PInt<U680>; pub type N680 = NInt<U680>;
+    pub type U681 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>;
+    pub type P681 = PInt<U681>; pub type N681 = NInt<U681>;
+    pub type U682 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>;
+    pub type P682 = PInt<U682>; pub type N682 = NInt<U682>;
+    pub type U683 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>;
+    pub type P683 = PInt<U683>; pub type N683 = NInt<U683>;
+    pub type U684 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>;
+    pub type P684 = PInt<U684>; pub type N684 = NInt<U684>;
+    pub type U685 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>;
+    pub type P685 = PInt<U685>; pub type N685 = NInt<U685>;
+    pub type U686 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>;
+    pub type P686 = PInt<U686>; pub type N686 = NInt<U686>;
+    pub type U687 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>;
+    pub type P687 = PInt<U687>; pub type N687 = NInt<U687>;
+    pub type U688 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>;
+    pub type P688 = PInt<U688>; pub type N688 = NInt<U688>;
+    pub type U689 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>;
+    pub type P689 = PInt<U689>; pub type N689 = NInt<U689>;
+    pub type U690 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>;
+    pub type P690 = PInt<U690>; pub type N690 = NInt<U690>;
+    pub type U691 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>;
+    pub type P691 = PInt<U691>; pub type N691 = NInt<U691>;
+    pub type U692 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>;
+    pub type P692 = PInt<U692>; pub type N692 = NInt<U692>;
+    pub type U693 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>;
+    pub type P693 = PInt<U693>; pub type N693 = NInt<U693>;
+    pub type U694 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>;
+    pub type P694 = PInt<U694>; pub type N694 = NInt<U694>;
+    pub type U695 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>;
+    pub type P695 = PInt<U695>; pub type N695 = NInt<U695>;
+    pub type U696 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>;
+    pub type P696 = PInt<U696>; pub type N696 = NInt<U696>;
+    pub type U697 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>;
+    pub type P697 = PInt<U697>; pub type N697 = NInt<U697>;
+    pub type U698 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>;
+    pub type P698 = PInt<U698>; pub type N698 = NInt<U698>;
+    pub type U699 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>;
+    pub type P699 = PInt<U699>; pub type N699 = NInt<U699>;
+    pub type U700 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>;
+    pub type P700 = PInt<U700>; pub type N700 = NInt<U700>;
+    pub type U701 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>;
+    pub type P701 = PInt<U701>; pub type N701 = NInt<U701>;
+    pub type U702 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>;
+    pub type P702 = PInt<U702>; pub type N702 = NInt<U702>;
+    pub type U703 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>;
+    pub type P703 = PInt<U703>; pub type N703 = NInt<U703>;
+    pub type U704 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P704 = PInt<U704>; pub type N704 = NInt<U704>;
+    pub type U705 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>;
+    pub type P705 = PInt<U705>; pub type N705 = NInt<U705>;
+    pub type U706 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>;
+    pub type P706 = PInt<U706>; pub type N706 = NInt<U706>;
+    pub type U707 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>;
+    pub type P707 = PInt<U707>; pub type N707 = NInt<U707>;
+    pub type U708 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>;
+    pub type P708 = PInt<U708>; pub type N708 = NInt<U708>;
+    pub type U709 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>;
+    pub type P709 = PInt<U709>; pub type N709 = NInt<U709>;
+    pub type U710 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>;
+    pub type P710 = PInt<U710>; pub type N710 = NInt<U710>;
+    pub type U711 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>;
+    pub type P711 = PInt<U711>; pub type N711 = NInt<U711>;
+    pub type U712 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>;
+    pub type P712 = PInt<U712>; pub type N712 = NInt<U712>;
+    pub type U713 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>;
+    pub type P713 = PInt<U713>; pub type N713 = NInt<U713>;
+    pub type U714 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>;
+    pub type P714 = PInt<U714>; pub type N714 = NInt<U714>;
+    pub type U715 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>;
+    pub type P715 = PInt<U715>; pub type N715 = NInt<U715>;
+    pub type U716 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>;
+    pub type P716 = PInt<U716>; pub type N716 = NInt<U716>;
+    pub type U717 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>;
+    pub type P717 = PInt<U717>; pub type N717 = NInt<U717>;
+    pub type U718 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>;
+    pub type P718 = PInt<U718>; pub type N718 = NInt<U718>;
+    pub type U719 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>;
+    pub type P719 = PInt<U719>; pub type N719 = NInt<U719>;
+    pub type U720 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>;
+    pub type P720 = PInt<U720>; pub type N720 = NInt<U720>;
+    pub type U721 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>;
+    pub type P721 = PInt<U721>; pub type N721 = NInt<U721>;
+    pub type U722 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>;
+    pub type P722 = PInt<U722>; pub type N722 = NInt<U722>;
+    pub type U723 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>;
+    pub type P723 = PInt<U723>; pub type N723 = NInt<U723>;
+    pub type U724 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>;
+    pub type P724 = PInt<U724>; pub type N724 = NInt<U724>;
+    pub type U725 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>;
+    pub type P725 = PInt<U725>; pub type N725 = NInt<U725>;
+    pub type U726 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>;
+    pub type P726 = PInt<U726>; pub type N726 = NInt<U726>;
+    pub type U727 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>;
+    pub type P727 = PInt<U727>; pub type N727 = NInt<U727>;
+    pub type U728 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>;
+    pub type P728 = PInt<U728>; pub type N728 = NInt<U728>;
+    pub type U729 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>;
+    pub type P729 = PInt<U729>; pub type N729 = NInt<U729>;
+    pub type U730 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>;
+    pub type P730 = PInt<U730>; pub type N730 = NInt<U730>;
+    pub type U731 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>;
+    pub type P731 = PInt<U731>; pub type N731 = NInt<U731>;
+    pub type U732 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>;
+    pub type P732 = PInt<U732>; pub type N732 = NInt<U732>;
+    pub type U733 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>;
+    pub type P733 = PInt<U733>; pub type N733 = NInt<U733>;
+    pub type U734 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>;
+    pub type P734 = PInt<U734>; pub type N734 = NInt<U734>;
+    pub type U735 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>;
+    pub type P735 = PInt<U735>; pub type N735 = NInt<U735>;
+    pub type U736 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>;
+    pub type P736 = PInt<U736>; pub type N736 = NInt<U736>;
+    pub type U737 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>;
+    pub type P737 = PInt<U737>; pub type N737 = NInt<U737>;
+    pub type U738 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>;
+    pub type P738 = PInt<U738>; pub type N738 = NInt<U738>;
+    pub type U739 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>;
+    pub type P739 = PInt<U739>; pub type N739 = NInt<U739>;
+    pub type U740 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>;
+    pub type P740 = PInt<U740>; pub type N740 = NInt<U740>;
+    pub type U741 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>;
+    pub type P741 = PInt<U741>; pub type N741 = NInt<U741>;
+    pub type U742 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>;
+    pub type P742 = PInt<U742>; pub type N742 = NInt<U742>;
+    pub type U743 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>;
+    pub type P743 = PInt<U743>; pub type N743 = NInt<U743>;
+    pub type U744 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>;
+    pub type P744 = PInt<U744>; pub type N744 = NInt<U744>;
+    pub type U745 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>;
+    pub type P745 = PInt<U745>; pub type N745 = NInt<U745>;
+    pub type U746 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>;
+    pub type P746 = PInt<U746>; pub type N746 = NInt<U746>;
+    pub type U747 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>;
+    pub type P747 = PInt<U747>; pub type N747 = NInt<U747>;
+    pub type U748 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>;
+    pub type P748 = PInt<U748>; pub type N748 = NInt<U748>;
+    pub type U749 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>;
+    pub type P749 = PInt<U749>; pub type N749 = NInt<U749>;
+    pub type U750 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>;
+    pub type P750 = PInt<U750>; pub type N750 = NInt<U750>;
+    pub type U751 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>;
+    pub type P751 = PInt<U751>; pub type N751 = NInt<U751>;
+    pub type U752 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>;
+    pub type P752 = PInt<U752>; pub type N752 = NInt<U752>;
+    pub type U753 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>;
+    pub type P753 = PInt<U753>; pub type N753 = NInt<U753>;
+    pub type U754 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>;
+    pub type P754 = PInt<U754>; pub type N754 = NInt<U754>;
+    pub type U755 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>;
+    pub type P755 = PInt<U755>; pub type N755 = NInt<U755>;
+    pub type U756 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>;
+    pub type P756 = PInt<U756>; pub type N756 = NInt<U756>;
+    pub type U757 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>;
+    pub type P757 = PInt<U757>; pub type N757 = NInt<U757>;
+    pub type U758 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>;
+    pub type P758 = PInt<U758>; pub type N758 = NInt<U758>;
+    pub type U759 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>;
+    pub type P759 = PInt<U759>; pub type N759 = NInt<U759>;
+    pub type U760 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>;
+    pub type P760 = PInt<U760>; pub type N760 = NInt<U760>;
+    pub type U761 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>;
+    pub type P761 = PInt<U761>; pub type N761 = NInt<U761>;
+    pub type U762 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>;
+    pub type P762 = PInt<U762>; pub type N762 = NInt<U762>;
+    pub type U763 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>;
+    pub type P763 = PInt<U763>; pub type N763 = NInt<U763>;
+    pub type U764 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>;
+    pub type P764 = PInt<U764>; pub type N764 = NInt<U764>;
+    pub type U765 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>;
+    pub type P765 = PInt<U765>; pub type N765 = NInt<U765>;
+    pub type U766 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>;
+    pub type P766 = PInt<U766>; pub type N766 = NInt<U766>;
+    pub type U767 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>;
+    pub type P767 = PInt<U767>; pub type N767 = NInt<U767>;
+    pub type U768 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P768 = PInt<U768>; pub type N768 = NInt<U768>;
+    pub type U769 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B1>;
+    pub type P769 = PInt<U769>; pub type N769 = NInt<U769>;
+    pub type U770 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B0>;
+    pub type P770 = PInt<U770>; pub type N770 = NInt<U770>;
+    pub type U771 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B1>;
+    pub type P771 = PInt<U771>; pub type N771 = NInt<U771>;
+    pub type U772 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B0>;
+    pub type P772 = PInt<U772>; pub type N772 = NInt<U772>;
+    pub type U773 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B1>;
+    pub type P773 = PInt<U773>; pub type N773 = NInt<U773>;
+    pub type U774 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B0>;
+    pub type P774 = PInt<U774>; pub type N774 = NInt<U774>;
+    pub type U775 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B1>;
+    pub type P775 = PInt<U775>; pub type N775 = NInt<U775>;
+    pub type U776 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B0>;
+    pub type P776 = PInt<U776>; pub type N776 = NInt<U776>;
+    pub type U777 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B1>;
+    pub type P777 = PInt<U777>; pub type N777 = NInt<U777>;
+    pub type U778 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B0>;
+    pub type P778 = PInt<U778>; pub type N778 = NInt<U778>;
+    pub type U779 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B1>;
+    pub type P779 = PInt<U779>; pub type N779 = NInt<U779>;
+    pub type U780 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B0>;
+    pub type P780 = PInt<U780>; pub type N780 = NInt<U780>;
+    pub type U781 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>;
+    pub type P781 = PInt<U781>; pub type N781 = NInt<U781>;
+    pub type U782 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B0>;
+    pub type P782 = PInt<U782>; pub type N782 = NInt<U782>;
+    pub type U783 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B1>;
+    pub type P783 = PInt<U783>; pub type N783 = NInt<U783>;
+    pub type U784 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>;
+    pub type P784 = PInt<U784>; pub type N784 = NInt<U784>;
+    pub type U785 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B1>;
+    pub type P785 = PInt<U785>; pub type N785 = NInt<U785>;
+    pub type U786 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B0>;
+    pub type P786 = PInt<U786>; pub type N786 = NInt<U786>;
+    pub type U787 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B1>;
+    pub type P787 = PInt<U787>; pub type N787 = NInt<U787>;
+    pub type U788 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B0>;
+    pub type P788 = PInt<U788>; pub type N788 = NInt<U788>;
+    pub type U789 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B1>;
+    pub type P789 = PInt<U789>; pub type N789 = NInt<U789>;
+    pub type U790 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B0>;
+    pub type P790 = PInt<U790>; pub type N790 = NInt<U790>;
+    pub type U791 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B1>;
+    pub type P791 = PInt<U791>; pub type N791 = NInt<U791>;
+    pub type U792 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B0>;
+    pub type P792 = PInt<U792>; pub type N792 = NInt<U792>;
+    pub type U793 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B1>;
+    pub type P793 = PInt<U793>; pub type N793 = NInt<U793>;
+    pub type U794 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>;
+    pub type P794 = PInt<U794>; pub type N794 = NInt<U794>;
+    pub type U795 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B1>;
+    pub type P795 = PInt<U795>; pub type N795 = NInt<U795>;
+    pub type U796 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B0>;
+    pub type P796 = PInt<U796>; pub type N796 = NInt<U796>;
+    pub type U797 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B1>;
+    pub type P797 = PInt<U797>; pub type N797 = NInt<U797>;
+    pub type U798 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B0>;
+    pub type P798 = PInt<U798>; pub type N798 = NInt<U798>;
+    pub type U799 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B1>;
+    pub type P799 = PInt<U799>; pub type N799 = NInt<U799>;
+    pub type U800 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;
+    pub type P800 = PInt<U800>; pub type N800 = NInt<U800>;
+    pub type U801 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B1>;
+    pub type P801 = PInt<U801>; pub type N801 = NInt<U801>;
+    pub type U802 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B0>;
+    pub type P802 = PInt<U802>; pub type N802 = NInt<U802>;
+    pub type U803 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B1>;
+    pub type P803 = PInt<U803>; pub type N803 = NInt<U803>;
+    pub type U804 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B0>;
+    pub type P804 = PInt<U804>; pub type N804 = NInt<U804>;
+    pub type U805 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B1>;
+    pub type P805 = PInt<U805>; pub type N805 = NInt<U805>;
+    pub type U806 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B0>;
+    pub type P806 = PInt<U806>; pub type N806 = NInt<U806>;
+    pub type U807 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B1>;
+    pub type P807 = PInt<U807>; pub type N807 = NInt<U807>;
+    pub type U808 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B0>;
+    pub type P808 = PInt<U808>; pub type N808 = NInt<U808>;
+    pub type U809 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B1>;
+    pub type P809 = PInt<U809>; pub type N809 = NInt<U809>;
+    pub type U810 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B0>;
+    pub type P810 = PInt<U810>; pub type N810 = NInt<U810>;
+    pub type U811 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B1>;
+    pub type P811 = PInt<U811>; pub type N811 = NInt<U811>;
+    pub type U812 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B0>;
+    pub type P812 = PInt<U812>; pub type N812 = NInt<U812>;
+    pub type U813 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B1>;
+    pub type P813 = PInt<U813>; pub type N813 = NInt<U813>;
+    pub type U814 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B0>;
+    pub type P814 = PInt<U814>; pub type N814 = NInt<U814>;
+    pub type U815 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B1>;
+    pub type P815 = PInt<U815>; pub type N815 = NInt<U815>;
+    pub type U816 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B0>;
+    pub type P816 = PInt<U816>; pub type N816 = NInt<U816>;
+    pub type U817 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B1>;
+    pub type P817 = PInt<U817>; pub type N817 = NInt<U817>;
+    pub type U818 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B0>;
+    pub type P818 = PInt<U818>; pub type N818 = NInt<U818>;
+    pub type U819 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B1>;
+    pub type P819 = PInt<U819>; pub type N819 = NInt<U819>;
+    pub type U820 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B0>;
+    pub type P820 = PInt<U820>; pub type N820 = NInt<U820>;
+    pub type U821 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>;
+    pub type P821 = PInt<U821>; pub type N821 = NInt<U821>;
+    pub type U822 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B0>;
+    pub type P822 = PInt<U822>; pub type N822 = NInt<U822>;
+    pub type U823 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B1>;
+    pub type P823 = PInt<U823>; pub type N823 = NInt<U823>;
+    pub type U824 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>;
+    pub type P824 = PInt<U824>; pub type N824 = NInt<U824>;
+    pub type U825 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B1>;
+    pub type P825 = PInt<U825>; pub type N825 = NInt<U825>;
+    pub type U826 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B0>;
+    pub type P826 = PInt<U826>; pub type N826 = NInt<U826>;
+    pub type U827 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B1>;
+    pub type P827 = PInt<U827>; pub type N827 = NInt<U827>;
+    pub type U828 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B0>;
+    pub type P828 = PInt<U828>; pub type N828 = NInt<U828>;
+    pub type U829 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B1>;
+    pub type P829 = PInt<U829>; pub type N829 = NInt<U829>;
+    pub type U830 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B0>;
+    pub type P830 = PInt<U830>; pub type N830 = NInt<U830>;
+    pub type U831 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B1>;
+    pub type P831 = PInt<U831>; pub type N831 = NInt<U831>;
+    pub type U832 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P832 = PInt<U832>; pub type N832 = NInt<U832>;
+    pub type U833 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B1>;
+    pub type P833 = PInt<U833>; pub type N833 = NInt<U833>;
+    pub type U834 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B0>;
+    pub type P834 = PInt<U834>; pub type N834 = NInt<U834>;
+    pub type U835 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B1>;
+    pub type P835 = PInt<U835>; pub type N835 = NInt<U835>;
+    pub type U836 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B0>;
+    pub type P836 = PInt<U836>; pub type N836 = NInt<U836>;
+    pub type U837 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B1>;
+    pub type P837 = PInt<U837>; pub type N837 = NInt<U837>;
+    pub type U838 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B0>;
+    pub type P838 = PInt<U838>; pub type N838 = NInt<U838>;
+    pub type U839 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B1>;
+    pub type P839 = PInt<U839>; pub type N839 = NInt<U839>;
+    pub type U840 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B0>;
+    pub type P840 = PInt<U840>; pub type N840 = NInt<U840>;
+    pub type U841 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B1>;
+    pub type P841 = PInt<U841>; pub type N841 = NInt<U841>;
+    pub type U842 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B0>;
+    pub type P842 = PInt<U842>; pub type N842 = NInt<U842>;
+    pub type U843 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B1>;
+    pub type P843 = PInt<U843>; pub type N843 = NInt<U843>;
+    pub type U844 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B0>;
+    pub type P844 = PInt<U844>; pub type N844 = NInt<U844>;
+    pub type U845 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B1>;
+    pub type P845 = PInt<U845>; pub type N845 = NInt<U845>;
+    pub type U846 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B0>;
+    pub type P846 = PInt<U846>; pub type N846 = NInt<U846>;
+    pub type U847 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B1>;
+    pub type P847 = PInt<U847>; pub type N847 = NInt<U847>;
+    pub type U848 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>;
+    pub type P848 = PInt<U848>; pub type N848 = NInt<U848>;
+    pub type U849 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B1>;
+    pub type P849 = PInt<U849>; pub type N849 = NInt<U849>;
+    pub type U850 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B0>;
+    pub type P850 = PInt<U850>; pub type N850 = NInt<U850>;
+    pub type U851 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B1>;
+    pub type P851 = PInt<U851>; pub type N851 = NInt<U851>;
+    pub type U852 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B0>;
+    pub type P852 = PInt<U852>; pub type N852 = NInt<U852>;
+    pub type U853 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B1>;
+    pub type P853 = PInt<U853>; pub type N853 = NInt<U853>;
+    pub type U854 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B0>;
+    pub type P854 = PInt<U854>; pub type N854 = NInt<U854>;
+    pub type U855 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B1>;
+    pub type P855 = PInt<U855>; pub type N855 = NInt<U855>;
+    pub type U856 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B0>;
+    pub type P856 = PInt<U856>; pub type N856 = NInt<U856>;
+    pub type U857 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B1>;
+    pub type P857 = PInt<U857>; pub type N857 = NInt<U857>;
+    pub type U858 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B0>;
+    pub type P858 = PInt<U858>; pub type N858 = NInt<U858>;
+    pub type U859 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B1>;
+    pub type P859 = PInt<U859>; pub type N859 = NInt<U859>;
+    pub type U860 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B0>;
+    pub type P860 = PInt<U860>; pub type N860 = NInt<U860>;
+    pub type U861 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B1>;
+    pub type P861 = PInt<U861>; pub type N861 = NInt<U861>;
+    pub type U862 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B0>;
+    pub type P862 = PInt<U862>; pub type N862 = NInt<U862>;
+    pub type U863 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B1>;
+    pub type P863 = PInt<U863>; pub type N863 = NInt<U863>;
+    pub type U864 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B0>;
+    pub type P864 = PInt<U864>; pub type N864 = NInt<U864>;
+    pub type U865 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B1>;
+    pub type P865 = PInt<U865>; pub type N865 = NInt<U865>;
+    pub type U866 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B0>;
+    pub type P866 = PInt<U866>; pub type N866 = NInt<U866>;
+    pub type U867 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B1>;
+    pub type P867 = PInt<U867>; pub type N867 = NInt<U867>;
+    pub type U868 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B0>;
+    pub type P868 = PInt<U868>; pub type N868 = NInt<U868>;
+    pub type U869 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B1>;
+    pub type P869 = PInt<U869>; pub type N869 = NInt<U869>;
+    pub type U870 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B0>;
+    pub type P870 = PInt<U870>; pub type N870 = NInt<U870>;
+    pub type U871 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B1>;
+    pub type P871 = PInt<U871>; pub type N871 = NInt<U871>;
+    pub type U872 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B0>;
+    pub type P872 = PInt<U872>; pub type N872 = NInt<U872>;
+    pub type U873 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B1>;
+    pub type P873 = PInt<U873>; pub type N873 = NInt<U873>;
+    pub type U874 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B0>;
+    pub type P874 = PInt<U874>; pub type N874 = NInt<U874>;
+    pub type U875 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B1>;
+    pub type P875 = PInt<U875>; pub type N875 = NInt<U875>;
+    pub type U876 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B0>;
+    pub type P876 = PInt<U876>; pub type N876 = NInt<U876>;
+    pub type U877 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B1>;
+    pub type P877 = PInt<U877>; pub type N877 = NInt<U877>;
+    pub type U878 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B0>;
+    pub type P878 = PInt<U878>; pub type N878 = NInt<U878>;
+    pub type U879 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B1>;
+    pub type P879 = PInt<U879>; pub type N879 = NInt<U879>;
+    pub type U880 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B0>;
+    pub type P880 = PInt<U880>; pub type N880 = NInt<U880>;
+    pub type U881 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>;
+    pub type P881 = PInt<U881>; pub type N881 = NInt<U881>;
+    pub type U882 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B0>;
+    pub type P882 = PInt<U882>; pub type N882 = NInt<U882>;
+    pub type U883 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B1>;
+    pub type P883 = PInt<U883>; pub type N883 = NInt<U883>;
+    pub type U884 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B0>;
+    pub type P884 = PInt<U884>; pub type N884 = NInt<U884>;
+    pub type U885 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B1>;
+    pub type P885 = PInt<U885>; pub type N885 = NInt<U885>;
+    pub type U886 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B0>;
+    pub type P886 = PInt<U886>; pub type N886 = NInt<U886>;
+    pub type U887 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B1>;
+    pub type P887 = PInt<U887>; pub type N887 = NInt<U887>;
+    pub type U888 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B0>;
+    pub type P888 = PInt<U888>; pub type N888 = NInt<U888>;
+    pub type U889 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B1>;
+    pub type P889 = PInt<U889>; pub type N889 = NInt<U889>;
+    pub type U890 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B0>;
+    pub type P890 = PInt<U890>; pub type N890 = NInt<U890>;
+    pub type U891 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B1>;
+    pub type P891 = PInt<U891>; pub type N891 = NInt<U891>;
+    pub type U892 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B0>;
+    pub type P892 = PInt<U892>; pub type N892 = NInt<U892>;
+    pub type U893 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B1>;
+    pub type P893 = PInt<U893>; pub type N893 = NInt<U893>;
+    pub type U894 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B0>;
+    pub type P894 = PInt<U894>; pub type N894 = NInt<U894>;
+    pub type U895 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B1>;
+    pub type P895 = PInt<U895>; pub type N895 = NInt<U895>;
+    pub type U896 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P896 = PInt<U896>; pub type N896 = NInt<U896>;
+    pub type U897 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>;
+    pub type P897 = PInt<U897>; pub type N897 = NInt<U897>;
+    pub type U898 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>;
+    pub type P898 = PInt<U898>; pub type N898 = NInt<U898>;
+    pub type U899 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>;
+    pub type P899 = PInt<U899>; pub type N899 = NInt<U899>;
+    pub type U900 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>;
+    pub type P900 = PInt<U900>; pub type N900 = NInt<U900>;
+    pub type U901 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>;
+    pub type P901 = PInt<U901>; pub type N901 = NInt<U901>;
+    pub type U902 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>;
+    pub type P902 = PInt<U902>; pub type N902 = NInt<U902>;
+    pub type U903 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>;
+    pub type P903 = PInt<U903>; pub type N903 = NInt<U903>;
+    pub type U904 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>;
+    pub type P904 = PInt<U904>; pub type N904 = NInt<U904>;
+    pub type U905 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>;
+    pub type P905 = PInt<U905>; pub type N905 = NInt<U905>;
+    pub type U906 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>;
+    pub type P906 = PInt<U906>; pub type N906 = NInt<U906>;
+    pub type U907 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>;
+    pub type P907 = PInt<U907>; pub type N907 = NInt<U907>;
+    pub type U908 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>;
+    pub type P908 = PInt<U908>; pub type N908 = NInt<U908>;
+    pub type U909 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>;
+    pub type P909 = PInt<U909>; pub type N909 = NInt<U909>;
+    pub type U910 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>;
+    pub type P910 = PInt<U910>; pub type N910 = NInt<U910>;
+    pub type U911 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>;
+    pub type P911 = PInt<U911>; pub type N911 = NInt<U911>;
+    pub type U912 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>;
+    pub type P912 = PInt<U912>; pub type N912 = NInt<U912>;
+    pub type U913 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>;
+    pub type P913 = PInt<U913>; pub type N913 = NInt<U913>;
+    pub type U914 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>;
+    pub type P914 = PInt<U914>; pub type N914 = NInt<U914>;
+    pub type U915 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>;
+    pub type P915 = PInt<U915>; pub type N915 = NInt<U915>;
+    pub type U916 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>;
+    pub type P916 = PInt<U916>; pub type N916 = NInt<U916>;
+    pub type U917 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>;
+    pub type P917 = PInt<U917>; pub type N917 = NInt<U917>;
+    pub type U918 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>;
+    pub type P918 = PInt<U918>; pub type N918 = NInt<U918>;
+    pub type U919 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>;
+    pub type P919 = PInt<U919>; pub type N919 = NInt<U919>;
+    pub type U920 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>;
+    pub type P920 = PInt<U920>; pub type N920 = NInt<U920>;
+    pub type U921 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>;
+    pub type P921 = PInt<U921>; pub type N921 = NInt<U921>;
+    pub type U922 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>;
+    pub type P922 = PInt<U922>; pub type N922 = NInt<U922>;
+    pub type U923 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>;
+    pub type P923 = PInt<U923>; pub type N923 = NInt<U923>;
+    pub type U924 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>;
+    pub type P924 = PInt<U924>; pub type N924 = NInt<U924>;
+    pub type U925 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>;
+    pub type P925 = PInt<U925>; pub type N925 = NInt<U925>;
+    pub type U926 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>;
+    pub type P926 = PInt<U926>; pub type N926 = NInt<U926>;
+    pub type U927 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>;
+    pub type P927 = PInt<U927>; pub type N927 = NInt<U927>;
+    pub type U928 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;
+    pub type P928 = PInt<U928>; pub type N928 = NInt<U928>;
+    pub type U929 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>;
+    pub type P929 = PInt<U929>; pub type N929 = NInt<U929>;
+    pub type U930 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>;
+    pub type P930 = PInt<U930>; pub type N930 = NInt<U930>;
+    pub type U931 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>;
+    pub type P931 = PInt<U931>; pub type N931 = NInt<U931>;
+    pub type U932 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>;
+    pub type P932 = PInt<U932>; pub type N932 = NInt<U932>;
+    pub type U933 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>;
+    pub type P933 = PInt<U933>; pub type N933 = NInt<U933>;
+    pub type U934 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>;
+    pub type P934 = PInt<U934>; pub type N934 = NInt<U934>;
+    pub type U935 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>;
+    pub type P935 = PInt<U935>; pub type N935 = NInt<U935>;
+    pub type U936 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>;
+    pub type P936 = PInt<U936>; pub type N936 = NInt<U936>;
+    pub type U937 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>;
+    pub type P937 = PInt<U937>; pub type N937 = NInt<U937>;
+    pub type U938 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>;
+    pub type P938 = PInt<U938>; pub type N938 = NInt<U938>;
+    pub type U939 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>;
+    pub type P939 = PInt<U939>; pub type N939 = NInt<U939>;
+    pub type U940 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>;
+    pub type P940 = PInt<U940>; pub type N940 = NInt<U940>;
+    pub type U941 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>;
+    pub type P941 = PInt<U941>; pub type N941 = NInt<U941>;
+    pub type U942 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>;
+    pub type P942 = PInt<U942>; pub type N942 = NInt<U942>;
+    pub type U943 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>;
+    pub type P943 = PInt<U943>; pub type N943 = NInt<U943>;
+    pub type U944 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>;
+    pub type P944 = PInt<U944>; pub type N944 = NInt<U944>;
+    pub type U945 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>;
+    pub type P945 = PInt<U945>; pub type N945 = NInt<U945>;
+    pub type U946 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>;
+    pub type P946 = PInt<U946>; pub type N946 = NInt<U946>;
+    pub type U947 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>;
+    pub type P947 = PInt<U947>; pub type N947 = NInt<U947>;
+    pub type U948 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>;
+    pub type P948 = PInt<U948>; pub type N948 = NInt<U948>;
+    pub type U949 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>;
+    pub type P949 = PInt<U949>; pub type N949 = NInt<U949>;
+    pub type U950 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>;
+    pub type P950 = PInt<U950>; pub type N950 = NInt<U950>;
+    pub type U951 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>;
+    pub type P951 = PInt<U951>; pub type N951 = NInt<U951>;
+    pub type U952 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>;
+    pub type P952 = PInt<U952>; pub type N952 = NInt<U952>;
+    pub type U953 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>;
+    pub type P953 = PInt<U953>; pub type N953 = NInt<U953>;
+    pub type U954 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>;
+    pub type P954 = PInt<U954>; pub type N954 = NInt<U954>;
+    pub type U955 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>;
+    pub type P955 = PInt<U955>; pub type N955 = NInt<U955>;
+    pub type U956 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>;
+    pub type P956 = PInt<U956>; pub type N956 = NInt<U956>;
+    pub type U957 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>;
+    pub type P957 = PInt<U957>; pub type N957 = NInt<U957>;
+    pub type U958 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>;
+    pub type P958 = PInt<U958>; pub type N958 = NInt<U958>;
+    pub type U959 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>;
+    pub type P959 = PInt<U959>; pub type N959 = NInt<U959>;
+    pub type U960 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P960 = PInt<U960>; pub type N960 = NInt<U960>;
+    pub type U961 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>;
+    pub type P961 = PInt<U961>; pub type N961 = NInt<U961>;
+    pub type U962 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>;
+    pub type P962 = PInt<U962>; pub type N962 = NInt<U962>;
+    pub type U963 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>;
+    pub type P963 = PInt<U963>; pub type N963 = NInt<U963>;
+    pub type U964 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>;
+    pub type P964 = PInt<U964>; pub type N964 = NInt<U964>;
+    pub type U965 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>;
+    pub type P965 = PInt<U965>; pub type N965 = NInt<U965>;
+    pub type U966 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>;
+    pub type P966 = PInt<U966>; pub type N966 = NInt<U966>;
+    pub type U967 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>;
+    pub type P967 = PInt<U967>; pub type N967 = NInt<U967>;
+    pub type U968 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>;
+    pub type P968 = PInt<U968>; pub type N968 = NInt<U968>;
+    pub type U969 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>;
+    pub type P969 = PInt<U969>; pub type N969 = NInt<U969>;
+    pub type U970 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>;
+    pub type P970 = PInt<U970>; pub type N970 = NInt<U970>;
+    pub type U971 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>;
+    pub type P971 = PInt<U971>; pub type N971 = NInt<U971>;
+    pub type U972 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>;
+    pub type P972 = PInt<U972>; pub type N972 = NInt<U972>;
+    pub type U973 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>;
+    pub type P973 = PInt<U973>; pub type N973 = NInt<U973>;
+    pub type U974 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>;
+    pub type P974 = PInt<U974>; pub type N974 = NInt<U974>;
+    pub type U975 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>;
+    pub type P975 = PInt<U975>; pub type N975 = NInt<U975>;
+    pub type U976 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>;
+    pub type P976 = PInt<U976>; pub type N976 = NInt<U976>;
+    pub type U977 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>;
+    pub type P977 = PInt<U977>; pub type N977 = NInt<U977>;
+    pub type U978 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>;
+    pub type P978 = PInt<U978>; pub type N978 = NInt<U978>;
+    pub type U979 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>;
+    pub type P979 = PInt<U979>; pub type N979 = NInt<U979>;
+    pub type U980 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>;
+    pub type P980 = PInt<U980>; pub type N980 = NInt<U980>;
+    pub type U981 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>;
+    pub type P981 = PInt<U981>; pub type N981 = NInt<U981>;
+    pub type U982 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>;
+    pub type P982 = PInt<U982>; pub type N982 = NInt<U982>;
+    pub type U983 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>;
+    pub type P983 = PInt<U983>; pub type N983 = NInt<U983>;
+    pub type U984 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>;
+    pub type P984 = PInt<U984>; pub type N984 = NInt<U984>;
+    pub type U985 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>;
+    pub type P985 = PInt<U985>; pub type N985 = NInt<U985>;
+    pub type U986 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>;
+    pub type P986 = PInt<U986>; pub type N986 = NInt<U986>;
+    pub type U987 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>;
+    pub type P987 = PInt<U987>; pub type N987 = NInt<U987>;
+    pub type U988 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>;
+    pub type P988 = PInt<U988>; pub type N988 = NInt<U988>;
+    pub type U989 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>;
+    pub type P989 = PInt<U989>; pub type N989 = NInt<U989>;
+    pub type U990 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>;
+    pub type P990 = PInt<U990>; pub type N990 = NInt<U990>;
+    pub type U991 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>;
+    pub type P991 = PInt<U991>; pub type N991 = NInt<U991>;
+    pub type U992 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>;
+    pub type P992 = PInt<U992>; pub type N992 = NInt<U992>;
+    pub type U993 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>;
+    pub type P993 = PInt<U993>; pub type N993 = NInt<U993>;
+    pub type U994 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>;
+    pub type P994 = PInt<U994>; pub type N994 = NInt<U994>;
+    pub type U995 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>;
+    pub type P995 = PInt<U995>; pub type N995 = NInt<U995>;
+    pub type U996 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>;
+    pub type P996 = PInt<U996>; pub type N996 = NInt<U996>;
+    pub type U997 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>;
+    pub type P997 = PInt<U997>; pub type N997 = NInt<U997>;
+    pub type U998 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>;
+    pub type P998 = PInt<U998>; pub type N998 = NInt<U998>;
+    pub type U999 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>;
+    pub type P999 = PInt<U999>; pub type N999 = NInt<U999>;
+    pub type U1000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>;
+    pub type P1000 = PInt<U1000>; pub type N1000 = NInt<U1000>;
+    pub type U1001 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>;
+    pub type P1001 = PInt<U1001>; pub type N1001 = NInt<U1001>;
+    pub type U1002 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>;
+    pub type P1002 = PInt<U1002>; pub type N1002 = NInt<U1002>;
+    pub type U1003 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>;
+    pub type P1003 = PInt<U1003>; pub type N1003 = NInt<U1003>;
+    pub type U1004 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>;
+    pub type P1004 = PInt<U1004>; pub type N1004 = NInt<U1004>;
+    pub type U1005 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>;
+    pub type P1005 = PInt<U1005>; pub type N1005 = NInt<U1005>;
+    pub type U1006 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>;
+    pub type P1006 = PInt<U1006>; pub type N1006 = NInt<U1006>;
+    pub type U1007 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>;
+    pub type P1007 = PInt<U1007>; pub type N1007 = NInt<U1007>;
+    pub type U1008 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>;
+    pub type P1008 = PInt<U1008>; pub type N1008 = NInt<U1008>;
+    pub type U1009 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>;
+    pub type P1009 = PInt<U1009>; pub type N1009 = NInt<U1009>;
+    pub type U1010 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>;
+    pub type P1010 = PInt<U1010>; pub type N1010 = NInt<U1010>;
+    pub type U1011 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>;
+    pub type P1011 = PInt<U1011>; pub type N1011 = NInt<U1011>;
+    pub type U1012 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>;
+    pub type P1012 = PInt<U1012>; pub type N1012 = NInt<U1012>;
+    pub type U1013 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>;
+    pub type P1013 = PInt<U1013>; pub type N1013 = NInt<U1013>;
+    pub type U1014 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>;
+    pub type P1014 = PInt<U1014>; pub type N1014 = NInt<U1014>;
+    pub type U1015 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>;
+    pub type P1015 = PInt<U1015>; pub type N1015 = NInt<U1015>;
+    pub type U1016 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>;
+    pub type P1016 = PInt<U1016>; pub type N1016 = NInt<U1016>;
+    pub type U1017 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>;
+    pub type P1017 = PInt<U1017>; pub type N1017 = NInt<U1017>;
+    pub type U1018 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>;
+    pub type P1018 = PInt<U1018>; pub type N1018 = NInt<U1018>;
+    pub type U1019 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>;
+    pub type P1019 = PInt<U1019>; pub type N1019 = NInt<U1019>;
+    pub type U1020 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>;
+    pub type P1020 = PInt<U1020>; pub type N1020 = NInt<U1020>;
+    pub type U1021 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>;
+    pub type P1021 = PInt<U1021>; pub type N1021 = NInt<U1021>;
+    pub type U1022 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>;
+    pub type P1022 = PInt<U1022>; pub type N1022 = NInt<U1022>;
+    pub type U1023 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>;
+    pub type P1023 = PInt<U1023>; pub type N1023 = NInt<U1023>;
+    pub type U1024 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P1024 = PInt<U1024>; pub type N1024 = NInt<U1024>;
+    pub type U2048 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P2048 = PInt<U2048>; pub type N2048 = NInt<U2048>;
+    pub type U4096 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P4096 = PInt<U4096>; pub type N4096 = NInt<U4096>;
+    pub type U8192 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P8192 = PInt<U8192>; pub type N8192 = NInt<U8192>;
+    pub type U16384 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P16384 = PInt<U16384>; pub type N16384 = NInt<U16384>;
+    pub type U32768 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P32768 = PInt<U32768>; pub type N32768 = NInt<U32768>;
+    pub type U65536 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P65536 = PInt<U65536>; pub type N65536 = NInt<U65536>;
+    pub type U131072 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P131072 = PInt<U131072>; pub type N131072 = NInt<U131072>;
+    pub type U262144 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P262144 = PInt<U262144>; pub type N262144 = NInt<U262144>;
+    pub type U524288 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P524288 = PInt<U524288>; pub type N524288 = NInt<U524288>;
+    pub type U1048576 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P1048576 = PInt<U1048576>; pub type N1048576 = NInt<U1048576>;
+    pub type U2097152 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P2097152 = PInt<U2097152>; pub type N2097152 = NInt<U2097152>;
+    pub type U4194304 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P4194304 = PInt<U4194304>; pub type N4194304 = NInt<U4194304>;
+    pub type U8388608 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P8388608 = PInt<U8388608>; pub type N8388608 = NInt<U8388608>;
+    pub type U16777216 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P16777216 = PInt<U16777216>; pub type N16777216 = NInt<U16777216>;
+    pub type U33554432 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P33554432 = PInt<U33554432>; pub type N33554432 = NInt<U33554432>;
+    pub type U67108864 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P67108864 = PInt<U67108864>; pub type N67108864 = NInt<U67108864>;
+    pub type U134217728 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P134217728 = PInt<U134217728>; pub type N134217728 = NInt<U134217728>;
+    pub type U268435456 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P268435456 = PInt<U268435456>; pub type N268435456 = NInt<U268435456>;
+    pub type U536870912 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P536870912 = PInt<U536870912>; pub type N536870912 = NInt<U536870912>;
+    pub type U1073741824 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P1073741824 = PInt<U1073741824>; pub type N1073741824 = NInt<U1073741824>;
+    pub type U2147483648 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P2147483648 = PInt<U2147483648>; pub type N2147483648 = NInt<U2147483648>;
+    pub type U4294967296 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P4294967296 = PInt<U4294967296>; pub type N4294967296 = NInt<U4294967296>;
+    pub type U8589934592 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P8589934592 = PInt<U8589934592>; pub type N8589934592 = NInt<U8589934592>;
+    pub type U17179869184 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P17179869184 = PInt<U17179869184>; pub type N17179869184 = NInt<U17179869184>;
+    pub type U34359738368 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P34359738368 = PInt<U34359738368>; pub type N34359738368 = NInt<U34359738368>;
+    pub type U68719476736 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P68719476736 = PInt<U68719476736>; pub type N68719476736 = NInt<U68719476736>;
+    pub type U137438953472 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P137438953472 = PInt<U137438953472>; pub type N137438953472 = NInt<U137438953472>;
+    pub type U274877906944 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P274877906944 = PInt<U274877906944>; pub type N274877906944 = NInt<U274877906944>;
+    pub type U549755813888 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P549755813888 = PInt<U549755813888>; pub type N549755813888 = NInt<U549755813888>;
+    pub type U1099511627776 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P1099511627776 = PInt<U1099511627776>; pub type N1099511627776 = NInt<U1099511627776>;
+    pub type U2199023255552 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P2199023255552 = PInt<U2199023255552>; pub type N2199023255552 = NInt<U2199023255552>;
+    pub type U4398046511104 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P4398046511104 = PInt<U4398046511104>; pub type N4398046511104 = NInt<U4398046511104>;
+    pub type U8796093022208 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P8796093022208 = PInt<U8796093022208>; pub type N8796093022208 = NInt<U8796093022208>;
+    pub type U17592186044416 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P17592186044416 = PInt<U17592186044416>; pub type N17592186044416 = NInt<U17592186044416>;
+    pub type U35184372088832 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P35184372088832 = PInt<U35184372088832>; pub type N35184372088832 = NInt<U35184372088832>;
+    pub type U70368744177664 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P70368744177664 = PInt<U70368744177664>; pub type N70368744177664 = NInt<U70368744177664>;
+    pub type U140737488355328 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P140737488355328 = PInt<U140737488355328>; pub type N140737488355328 = NInt<U140737488355328>;
+    pub type U281474976710656 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P281474976710656 = PInt<U281474976710656>; pub type N281474976710656 = NInt<U281474976710656>;
+    pub type U562949953421312 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P562949953421312 = PInt<U562949953421312>; pub type N562949953421312 = NInt<U562949953421312>;
+    pub type U1125899906842624 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P1125899906842624 = PInt<U1125899906842624>; pub type N1125899906842624 = NInt<U1125899906842624>;
+    pub type U2251799813685248 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P2251799813685248 = PInt<U2251799813685248>; pub type N2251799813685248 = NInt<U2251799813685248>;
+    pub type U4503599627370496 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P4503599627370496 = PInt<U4503599627370496>; pub type N4503599627370496 = NInt<U4503599627370496>;
+    pub type U9007199254740992 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P9007199254740992 = PInt<U9007199254740992>; pub type N9007199254740992 = NInt<U9007199254740992>;
+    pub type U18014398509481984 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P18014398509481984 = PInt<U18014398509481984>; pub type N18014398509481984 = NInt<U18014398509481984>;
+    pub type U36028797018963968 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P36028797018963968 = PInt<U36028797018963968>; pub type N36028797018963968 = NInt<U36028797018963968>;
+    pub type U72057594037927936 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P72057594037927936 = PInt<U72057594037927936>; pub type N72057594037927936 = NInt<U72057594037927936>;
+    pub type U144115188075855872 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P144115188075855872 = PInt<U144115188075855872>; pub type N144115188075855872 = NInt<U144115188075855872>;
+    pub type U288230376151711744 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P288230376151711744 = PInt<U288230376151711744>; pub type N288230376151711744 = NInt<U288230376151711744>;
+    pub type U576460752303423488 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P576460752303423488 = PInt<U576460752303423488>; pub type N576460752303423488 = NInt<U576460752303423488>;
+    pub type U1152921504606846976 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P1152921504606846976 = PInt<U1152921504606846976>; pub type N1152921504606846976 = NInt<U1152921504606846976>;
+    pub type U2305843009213693952 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P2305843009213693952 = PInt<U2305843009213693952>; pub type N2305843009213693952 = NInt<U2305843009213693952>;
+    pub type U4611686018427387904 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P4611686018427387904 = PInt<U4611686018427387904>; pub type N4611686018427387904 = NInt<U4611686018427387904>;
+    pub type U9223372036854775808 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type U10000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>;
+    pub type P10000 = PInt<U10000>; pub type N10000 = NInt<U10000>;
+    pub type U100000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;
+    pub type P100000 = PInt<U100000>; pub type N100000 = NInt<U100000>;
+    pub type U1000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P1000000 = PInt<U1000000>; pub type N1000000 = NInt<U1000000>;
+    pub type U10000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P10000000 = PInt<U10000000>; pub type N10000000 = NInt<U10000000>;
+    pub type U100000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P100000000 = PInt<U100000000>; pub type N100000000 = NInt<U100000000>;
+    pub type U1000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P1000000000 = PInt<U1000000000>; pub type N1000000000 = NInt<U1000000000>;
+    pub type U10000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P10000000000 = PInt<U10000000000>; pub type N10000000000 = NInt<U10000000000>;
+    pub type U100000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P100000000000 = PInt<U100000000000>; pub type N100000000000 = NInt<U100000000000>;
+    pub type U1000000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P1000000000000 = PInt<U1000000000000>; pub type N1000000000000 = NInt<U1000000000000>;
+    pub type U10000000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P10000000000000 = PInt<U10000000000000>; pub type N10000000000000 = NInt<U10000000000000>;
+    pub type U100000000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P100000000000000 = PInt<U100000000000000>; pub type N100000000000000 = NInt<U100000000000000>;
+    pub type U1000000000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P1000000000000000 = PInt<U1000000000000000>; pub type N1000000000000000 = NInt<U1000000000000000>;
+    pub type U10000000000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P10000000000000000 = PInt<U10000000000000000>; pub type N10000000000000000 = NInt<U10000000000000000>;
+    pub type U100000000000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P100000000000000000 = PInt<U100000000000000000>; pub type N100000000000000000 = NInt<U100000000000000000>;
+    pub type U1000000000000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+    pub type P1000000000000000000 = PInt<U1000000000000000000>; pub type N1000000000000000000 = NInt<U1000000000000000000>;
+    pub type U10000000000000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+}
\ No newline at end of file
diff --git a/src/generic_const_mappings.rs b/src/generic_const_mappings.rs
new file mode 100644
index 0000000..2a8098c
--- /dev/null
+++ b/src/generic_const_mappings.rs
@@ -0,0 +1,5531 @@
+#[cfg(doc)]
+use generic_const_mappings::*;
+
+/// Module with some `const`-generics-friendly definitions, to help bridge the gap
+/// between those and `typenum` types.
+///
+///   - It requires the `const-generics` crate feature to be enabled.
+///
+/// The main type to use here is [`U`], although [`Const`] and [`ToUInt`] may be needed
+/// in a generic context.
+#[allow(warnings)] // script-generated code
+#[cfg(feature = "const-generics")] // hints at doc_auto_cfg
+pub mod generic_const_mappings {
+    use crate::*;
+
+    /// The main mapping from a generic `const: usize` to a [`UInt`]: [`U<N>`] is expected to work like [`UN`].
+    ///
+    ///   - It requires the `const-generics` crate feature to be enabled.
+    ///
+    /// [`U<N>`]: `U`
+    /// [`UN`]: `U42`
+    ///
+    /// # Example
+    ///
+    /// ```rust
+    /// use typenum::*;
+    ///
+    /// assert_type_eq!(U<42>, U42);
+    /// ```
+    ///
+    /// This can even be used in a generic `const N: usize` context, provided the
+    /// genericity is guarded by a `where` clause:
+    ///
+    /// ```rust
+    /// use typenum::*;
+    ///
+    /// struct MyStruct<const N: usize>;
+    ///
+    /// trait MyTrait { type AssocType; }
+    ///
+    /// impl<const N: usize> MyTrait
+    ///     for MyStruct<N>
+    /// where
+    ///     Const<N> : ToUInt,
+    /// {
+    ///     type AssocType = U<N>;
+    /// }
+    ///
+    /// assert_type_eq!(<MyStruct<42> as MyTrait>::AssocType, U42);
+    /// ```
+    pub type U<const N: usize> = <Const<N> as ToUInt>::Output;
+
+    /// Used to allow the usage of [`U`] in a generic context.
+    pub struct Const<const N: usize>;
+
+    /// Used to allow the usage of [`U`] in a generic context.
+    pub trait ToUInt {
+        /// The [`UN`][`crate::U42`] type corresponding to `Self = Const<N>`.
+        type Output;
+    }
+
+    
+    impl ToUInt for Const<0> {
+        type Output = U0;
+    }
+
+    
+    impl ToUInt for Const<1> {
+        type Output = U1;
+    }
+
+    
+    impl ToUInt for Const<2> {
+        type Output = U2;
+    }
+
+    
+    impl ToUInt for Const<3> {
+        type Output = U3;
+    }
+
+    
+    impl ToUInt for Const<4> {
+        type Output = U4;
+    }
+
+    
+    impl ToUInt for Const<5> {
+        type Output = U5;
+    }
+
+    
+    impl ToUInt for Const<6> {
+        type Output = U6;
+    }
+
+    
+    impl ToUInt for Const<7> {
+        type Output = U7;
+    }
+
+    
+    impl ToUInt for Const<8> {
+        type Output = U8;
+    }
+
+    
+    impl ToUInt for Const<9> {
+        type Output = U9;
+    }
+
+    
+    impl ToUInt for Const<10> {
+        type Output = U10;
+    }
+
+    
+    impl ToUInt for Const<11> {
+        type Output = U11;
+    }
+
+    
+    impl ToUInt for Const<12> {
+        type Output = U12;
+    }
+
+    
+    impl ToUInt for Const<13> {
+        type Output = U13;
+    }
+
+    
+    impl ToUInt for Const<14> {
+        type Output = U14;
+    }
+
+    
+    impl ToUInt for Const<15> {
+        type Output = U15;
+    }
+
+    
+    impl ToUInt for Const<16> {
+        type Output = U16;
+    }
+
+    
+    impl ToUInt for Const<17> {
+        type Output = U17;
+    }
+
+    
+    impl ToUInt for Const<18> {
+        type Output = U18;
+    }
+
+    
+    impl ToUInt for Const<19> {
+        type Output = U19;
+    }
+
+    
+    impl ToUInt for Const<20> {
+        type Output = U20;
+    }
+
+    
+    impl ToUInt for Const<21> {
+        type Output = U21;
+    }
+
+    
+    impl ToUInt for Const<22> {
+        type Output = U22;
+    }
+
+    
+    impl ToUInt for Const<23> {
+        type Output = U23;
+    }
+
+    
+    impl ToUInt for Const<24> {
+        type Output = U24;
+    }
+
+    
+    impl ToUInt for Const<25> {
+        type Output = U25;
+    }
+
+    
+    impl ToUInt for Const<26> {
+        type Output = U26;
+    }
+
+    
+    impl ToUInt for Const<27> {
+        type Output = U27;
+    }
+
+    
+    impl ToUInt for Const<28> {
+        type Output = U28;
+    }
+
+    
+    impl ToUInt for Const<29> {
+        type Output = U29;
+    }
+
+    
+    impl ToUInt for Const<30> {
+        type Output = U30;
+    }
+
+    
+    impl ToUInt for Const<31> {
+        type Output = U31;
+    }
+
+    
+    impl ToUInt for Const<32> {
+        type Output = U32;
+    }
+
+    
+    impl ToUInt for Const<33> {
+        type Output = U33;
+    }
+
+    
+    impl ToUInt for Const<34> {
+        type Output = U34;
+    }
+
+    
+    impl ToUInt for Const<35> {
+        type Output = U35;
+    }
+
+    
+    impl ToUInt for Const<36> {
+        type Output = U36;
+    }
+
+    
+    impl ToUInt for Const<37> {
+        type Output = U37;
+    }
+
+    
+    impl ToUInt for Const<38> {
+        type Output = U38;
+    }
+
+    
+    impl ToUInt for Const<39> {
+        type Output = U39;
+    }
+
+    
+    impl ToUInt for Const<40> {
+        type Output = U40;
+    }
+
+    
+    impl ToUInt for Const<41> {
+        type Output = U41;
+    }
+
+    
+    impl ToUInt for Const<42> {
+        type Output = U42;
+    }
+
+    
+    impl ToUInt for Const<43> {
+        type Output = U43;
+    }
+
+    
+    impl ToUInt for Const<44> {
+        type Output = U44;
+    }
+
+    
+    impl ToUInt for Const<45> {
+        type Output = U45;
+    }
+
+    
+    impl ToUInt for Const<46> {
+        type Output = U46;
+    }
+
+    
+    impl ToUInt for Const<47> {
+        type Output = U47;
+    }
+
+    
+    impl ToUInt for Const<48> {
+        type Output = U48;
+    }
+
+    
+    impl ToUInt for Const<49> {
+        type Output = U49;
+    }
+
+    
+    impl ToUInt for Const<50> {
+        type Output = U50;
+    }
+
+    
+    impl ToUInt for Const<51> {
+        type Output = U51;
+    }
+
+    
+    impl ToUInt for Const<52> {
+        type Output = U52;
+    }
+
+    
+    impl ToUInt for Const<53> {
+        type Output = U53;
+    }
+
+    
+    impl ToUInt for Const<54> {
+        type Output = U54;
+    }
+
+    
+    impl ToUInt for Const<55> {
+        type Output = U55;
+    }
+
+    
+    impl ToUInt for Const<56> {
+        type Output = U56;
+    }
+
+    
+    impl ToUInt for Const<57> {
+        type Output = U57;
+    }
+
+    
+    impl ToUInt for Const<58> {
+        type Output = U58;
+    }
+
+    
+    impl ToUInt for Const<59> {
+        type Output = U59;
+    }
+
+    
+    impl ToUInt for Const<60> {
+        type Output = U60;
+    }
+
+    
+    impl ToUInt for Const<61> {
+        type Output = U61;
+    }
+
+    
+    impl ToUInt for Const<62> {
+        type Output = U62;
+    }
+
+    
+    impl ToUInt for Const<63> {
+        type Output = U63;
+    }
+
+    
+    impl ToUInt for Const<64> {
+        type Output = U64;
+    }
+
+    
+    impl ToUInt for Const<65> {
+        type Output = U65;
+    }
+
+    
+    impl ToUInt for Const<66> {
+        type Output = U66;
+    }
+
+    
+    impl ToUInt for Const<67> {
+        type Output = U67;
+    }
+
+    
+    impl ToUInt for Const<68> {
+        type Output = U68;
+    }
+
+    
+    impl ToUInt for Const<69> {
+        type Output = U69;
+    }
+
+    
+    impl ToUInt for Const<70> {
+        type Output = U70;
+    }
+
+    
+    impl ToUInt for Const<71> {
+        type Output = U71;
+    }
+
+    
+    impl ToUInt for Const<72> {
+        type Output = U72;
+    }
+
+    
+    impl ToUInt for Const<73> {
+        type Output = U73;
+    }
+
+    
+    impl ToUInt for Const<74> {
+        type Output = U74;
+    }
+
+    
+    impl ToUInt for Const<75> {
+        type Output = U75;
+    }
+
+    
+    impl ToUInt for Const<76> {
+        type Output = U76;
+    }
+
+    
+    impl ToUInt for Const<77> {
+        type Output = U77;
+    }
+
+    
+    impl ToUInt for Const<78> {
+        type Output = U78;
+    }
+
+    
+    impl ToUInt for Const<79> {
+        type Output = U79;
+    }
+
+    
+    impl ToUInt for Const<80> {
+        type Output = U80;
+    }
+
+    
+    impl ToUInt for Const<81> {
+        type Output = U81;
+    }
+
+    
+    impl ToUInt for Const<82> {
+        type Output = U82;
+    }
+
+    
+    impl ToUInt for Const<83> {
+        type Output = U83;
+    }
+
+    
+    impl ToUInt for Const<84> {
+        type Output = U84;
+    }
+
+    
+    impl ToUInt for Const<85> {
+        type Output = U85;
+    }
+
+    
+    impl ToUInt for Const<86> {
+        type Output = U86;
+    }
+
+    
+    impl ToUInt for Const<87> {
+        type Output = U87;
+    }
+
+    
+    impl ToUInt for Const<88> {
+        type Output = U88;
+    }
+
+    
+    impl ToUInt for Const<89> {
+        type Output = U89;
+    }
+
+    
+    impl ToUInt for Const<90> {
+        type Output = U90;
+    }
+
+    
+    impl ToUInt for Const<91> {
+        type Output = U91;
+    }
+
+    
+    impl ToUInt for Const<92> {
+        type Output = U92;
+    }
+
+    
+    impl ToUInt for Const<93> {
+        type Output = U93;
+    }
+
+    
+    impl ToUInt for Const<94> {
+        type Output = U94;
+    }
+
+    
+    impl ToUInt for Const<95> {
+        type Output = U95;
+    }
+
+    
+    impl ToUInt for Const<96> {
+        type Output = U96;
+    }
+
+    
+    impl ToUInt for Const<97> {
+        type Output = U97;
+    }
+
+    
+    impl ToUInt for Const<98> {
+        type Output = U98;
+    }
+
+    
+    impl ToUInt for Const<99> {
+        type Output = U99;
+    }
+
+    
+    impl ToUInt for Const<100> {
+        type Output = U100;
+    }
+
+    
+    impl ToUInt for Const<101> {
+        type Output = U101;
+    }
+
+    
+    impl ToUInt for Const<102> {
+        type Output = U102;
+    }
+
+    
+    impl ToUInt for Const<103> {
+        type Output = U103;
+    }
+
+    
+    impl ToUInt for Const<104> {
+        type Output = U104;
+    }
+
+    
+    impl ToUInt for Const<105> {
+        type Output = U105;
+    }
+
+    
+    impl ToUInt for Const<106> {
+        type Output = U106;
+    }
+
+    
+    impl ToUInt for Const<107> {
+        type Output = U107;
+    }
+
+    
+    impl ToUInt for Const<108> {
+        type Output = U108;
+    }
+
+    
+    impl ToUInt for Const<109> {
+        type Output = U109;
+    }
+
+    
+    impl ToUInt for Const<110> {
+        type Output = U110;
+    }
+
+    
+    impl ToUInt for Const<111> {
+        type Output = U111;
+    }
+
+    
+    impl ToUInt for Const<112> {
+        type Output = U112;
+    }
+
+    
+    impl ToUInt for Const<113> {
+        type Output = U113;
+    }
+
+    
+    impl ToUInt for Const<114> {
+        type Output = U114;
+    }
+
+    
+    impl ToUInt for Const<115> {
+        type Output = U115;
+    }
+
+    
+    impl ToUInt for Const<116> {
+        type Output = U116;
+    }
+
+    
+    impl ToUInt for Const<117> {
+        type Output = U117;
+    }
+
+    
+    impl ToUInt for Const<118> {
+        type Output = U118;
+    }
+
+    
+    impl ToUInt for Const<119> {
+        type Output = U119;
+    }
+
+    
+    impl ToUInt for Const<120> {
+        type Output = U120;
+    }
+
+    
+    impl ToUInt for Const<121> {
+        type Output = U121;
+    }
+
+    
+    impl ToUInt for Const<122> {
+        type Output = U122;
+    }
+
+    
+    impl ToUInt for Const<123> {
+        type Output = U123;
+    }
+
+    
+    impl ToUInt for Const<124> {
+        type Output = U124;
+    }
+
+    
+    impl ToUInt for Const<125> {
+        type Output = U125;
+    }
+
+    
+    impl ToUInt for Const<126> {
+        type Output = U126;
+    }
+
+    
+    impl ToUInt for Const<127> {
+        type Output = U127;
+    }
+
+    
+    impl ToUInt for Const<128> {
+        type Output = U128;
+    }
+
+    
+    impl ToUInt for Const<129> {
+        type Output = U129;
+    }
+
+    
+    impl ToUInt for Const<130> {
+        type Output = U130;
+    }
+
+    
+    impl ToUInt for Const<131> {
+        type Output = U131;
+    }
+
+    
+    impl ToUInt for Const<132> {
+        type Output = U132;
+    }
+
+    
+    impl ToUInt for Const<133> {
+        type Output = U133;
+    }
+
+    
+    impl ToUInt for Const<134> {
+        type Output = U134;
+    }
+
+    
+    impl ToUInt for Const<135> {
+        type Output = U135;
+    }
+
+    
+    impl ToUInt for Const<136> {
+        type Output = U136;
+    }
+
+    
+    impl ToUInt for Const<137> {
+        type Output = U137;
+    }
+
+    
+    impl ToUInt for Const<138> {
+        type Output = U138;
+    }
+
+    
+    impl ToUInt for Const<139> {
+        type Output = U139;
+    }
+
+    
+    impl ToUInt for Const<140> {
+        type Output = U140;
+    }
+
+    
+    impl ToUInt for Const<141> {
+        type Output = U141;
+    }
+
+    
+    impl ToUInt for Const<142> {
+        type Output = U142;
+    }
+
+    
+    impl ToUInt for Const<143> {
+        type Output = U143;
+    }
+
+    
+    impl ToUInt for Const<144> {
+        type Output = U144;
+    }
+
+    
+    impl ToUInt for Const<145> {
+        type Output = U145;
+    }
+
+    
+    impl ToUInt for Const<146> {
+        type Output = U146;
+    }
+
+    
+    impl ToUInt for Const<147> {
+        type Output = U147;
+    }
+
+    
+    impl ToUInt for Const<148> {
+        type Output = U148;
+    }
+
+    
+    impl ToUInt for Const<149> {
+        type Output = U149;
+    }
+
+    
+    impl ToUInt for Const<150> {
+        type Output = U150;
+    }
+
+    
+    impl ToUInt for Const<151> {
+        type Output = U151;
+    }
+
+    
+    impl ToUInt for Const<152> {
+        type Output = U152;
+    }
+
+    
+    impl ToUInt for Const<153> {
+        type Output = U153;
+    }
+
+    
+    impl ToUInt for Const<154> {
+        type Output = U154;
+    }
+
+    
+    impl ToUInt for Const<155> {
+        type Output = U155;
+    }
+
+    
+    impl ToUInt for Const<156> {
+        type Output = U156;
+    }
+
+    
+    impl ToUInt for Const<157> {
+        type Output = U157;
+    }
+
+    
+    impl ToUInt for Const<158> {
+        type Output = U158;
+    }
+
+    
+    impl ToUInt for Const<159> {
+        type Output = U159;
+    }
+
+    
+    impl ToUInt for Const<160> {
+        type Output = U160;
+    }
+
+    
+    impl ToUInt for Const<161> {
+        type Output = U161;
+    }
+
+    
+    impl ToUInt for Const<162> {
+        type Output = U162;
+    }
+
+    
+    impl ToUInt for Const<163> {
+        type Output = U163;
+    }
+
+    
+    impl ToUInt for Const<164> {
+        type Output = U164;
+    }
+
+    
+    impl ToUInt for Const<165> {
+        type Output = U165;
+    }
+
+    
+    impl ToUInt for Const<166> {
+        type Output = U166;
+    }
+
+    
+    impl ToUInt for Const<167> {
+        type Output = U167;
+    }
+
+    
+    impl ToUInt for Const<168> {
+        type Output = U168;
+    }
+
+    
+    impl ToUInt for Const<169> {
+        type Output = U169;
+    }
+
+    
+    impl ToUInt for Const<170> {
+        type Output = U170;
+    }
+
+    
+    impl ToUInt for Const<171> {
+        type Output = U171;
+    }
+
+    
+    impl ToUInt for Const<172> {
+        type Output = U172;
+    }
+
+    
+    impl ToUInt for Const<173> {
+        type Output = U173;
+    }
+
+    
+    impl ToUInt for Const<174> {
+        type Output = U174;
+    }
+
+    
+    impl ToUInt for Const<175> {
+        type Output = U175;
+    }
+
+    
+    impl ToUInt for Const<176> {
+        type Output = U176;
+    }
+
+    
+    impl ToUInt for Const<177> {
+        type Output = U177;
+    }
+
+    
+    impl ToUInt for Const<178> {
+        type Output = U178;
+    }
+
+    
+    impl ToUInt for Const<179> {
+        type Output = U179;
+    }
+
+    
+    impl ToUInt for Const<180> {
+        type Output = U180;
+    }
+
+    
+    impl ToUInt for Const<181> {
+        type Output = U181;
+    }
+
+    
+    impl ToUInt for Const<182> {
+        type Output = U182;
+    }
+
+    
+    impl ToUInt for Const<183> {
+        type Output = U183;
+    }
+
+    
+    impl ToUInt for Const<184> {
+        type Output = U184;
+    }
+
+    
+    impl ToUInt for Const<185> {
+        type Output = U185;
+    }
+
+    
+    impl ToUInt for Const<186> {
+        type Output = U186;
+    }
+
+    
+    impl ToUInt for Const<187> {
+        type Output = U187;
+    }
+
+    
+    impl ToUInt for Const<188> {
+        type Output = U188;
+    }
+
+    
+    impl ToUInt for Const<189> {
+        type Output = U189;
+    }
+
+    
+    impl ToUInt for Const<190> {
+        type Output = U190;
+    }
+
+    
+    impl ToUInt for Const<191> {
+        type Output = U191;
+    }
+
+    
+    impl ToUInt for Const<192> {
+        type Output = U192;
+    }
+
+    
+    impl ToUInt for Const<193> {
+        type Output = U193;
+    }
+
+    
+    impl ToUInt for Const<194> {
+        type Output = U194;
+    }
+
+    
+    impl ToUInt for Const<195> {
+        type Output = U195;
+    }
+
+    
+    impl ToUInt for Const<196> {
+        type Output = U196;
+    }
+
+    
+    impl ToUInt for Const<197> {
+        type Output = U197;
+    }
+
+    
+    impl ToUInt for Const<198> {
+        type Output = U198;
+    }
+
+    
+    impl ToUInt for Const<199> {
+        type Output = U199;
+    }
+
+    
+    impl ToUInt for Const<200> {
+        type Output = U200;
+    }
+
+    
+    impl ToUInt for Const<201> {
+        type Output = U201;
+    }
+
+    
+    impl ToUInt for Const<202> {
+        type Output = U202;
+    }
+
+    
+    impl ToUInt for Const<203> {
+        type Output = U203;
+    }
+
+    
+    impl ToUInt for Const<204> {
+        type Output = U204;
+    }
+
+    
+    impl ToUInt for Const<205> {
+        type Output = U205;
+    }
+
+    
+    impl ToUInt for Const<206> {
+        type Output = U206;
+    }
+
+    
+    impl ToUInt for Const<207> {
+        type Output = U207;
+    }
+
+    
+    impl ToUInt for Const<208> {
+        type Output = U208;
+    }
+
+    
+    impl ToUInt for Const<209> {
+        type Output = U209;
+    }
+
+    
+    impl ToUInt for Const<210> {
+        type Output = U210;
+    }
+
+    
+    impl ToUInt for Const<211> {
+        type Output = U211;
+    }
+
+    
+    impl ToUInt for Const<212> {
+        type Output = U212;
+    }
+
+    
+    impl ToUInt for Const<213> {
+        type Output = U213;
+    }
+
+    
+    impl ToUInt for Const<214> {
+        type Output = U214;
+    }
+
+    
+    impl ToUInt for Const<215> {
+        type Output = U215;
+    }
+
+    
+    impl ToUInt for Const<216> {
+        type Output = U216;
+    }
+
+    
+    impl ToUInt for Const<217> {
+        type Output = U217;
+    }
+
+    
+    impl ToUInt for Const<218> {
+        type Output = U218;
+    }
+
+    
+    impl ToUInt for Const<219> {
+        type Output = U219;
+    }
+
+    
+    impl ToUInt for Const<220> {
+        type Output = U220;
+    }
+
+    
+    impl ToUInt for Const<221> {
+        type Output = U221;
+    }
+
+    
+    impl ToUInt for Const<222> {
+        type Output = U222;
+    }
+
+    
+    impl ToUInt for Const<223> {
+        type Output = U223;
+    }
+
+    
+    impl ToUInt for Const<224> {
+        type Output = U224;
+    }
+
+    
+    impl ToUInt for Const<225> {
+        type Output = U225;
+    }
+
+    
+    impl ToUInt for Const<226> {
+        type Output = U226;
+    }
+
+    
+    impl ToUInt for Const<227> {
+        type Output = U227;
+    }
+
+    
+    impl ToUInt for Const<228> {
+        type Output = U228;
+    }
+
+    
+    impl ToUInt for Const<229> {
+        type Output = U229;
+    }
+
+    
+    impl ToUInt for Const<230> {
+        type Output = U230;
+    }
+
+    
+    impl ToUInt for Const<231> {
+        type Output = U231;
+    }
+
+    
+    impl ToUInt for Const<232> {
+        type Output = U232;
+    }
+
+    
+    impl ToUInt for Const<233> {
+        type Output = U233;
+    }
+
+    
+    impl ToUInt for Const<234> {
+        type Output = U234;
+    }
+
+    
+    impl ToUInt for Const<235> {
+        type Output = U235;
+    }
+
+    
+    impl ToUInt for Const<236> {
+        type Output = U236;
+    }
+
+    
+    impl ToUInt for Const<237> {
+        type Output = U237;
+    }
+
+    
+    impl ToUInt for Const<238> {
+        type Output = U238;
+    }
+
+    
+    impl ToUInt for Const<239> {
+        type Output = U239;
+    }
+
+    
+    impl ToUInt for Const<240> {
+        type Output = U240;
+    }
+
+    
+    impl ToUInt for Const<241> {
+        type Output = U241;
+    }
+
+    
+    impl ToUInt for Const<242> {
+        type Output = U242;
+    }
+
+    
+    impl ToUInt for Const<243> {
+        type Output = U243;
+    }
+
+    
+    impl ToUInt for Const<244> {
+        type Output = U244;
+    }
+
+    
+    impl ToUInt for Const<245> {
+        type Output = U245;
+    }
+
+    
+    impl ToUInt for Const<246> {
+        type Output = U246;
+    }
+
+    
+    impl ToUInt for Const<247> {
+        type Output = U247;
+    }
+
+    
+    impl ToUInt for Const<248> {
+        type Output = U248;
+    }
+
+    
+    impl ToUInt for Const<249> {
+        type Output = U249;
+    }
+
+    
+    impl ToUInt for Const<250> {
+        type Output = U250;
+    }
+
+    
+    impl ToUInt for Const<251> {
+        type Output = U251;
+    }
+
+    
+    impl ToUInt for Const<252> {
+        type Output = U252;
+    }
+
+    
+    impl ToUInt for Const<253> {
+        type Output = U253;
+    }
+
+    
+    impl ToUInt for Const<254> {
+        type Output = U254;
+    }
+
+    
+    impl ToUInt for Const<255> {
+        type Output = U255;
+    }
+
+    
+    impl ToUInt for Const<256> {
+        type Output = U256;
+    }
+
+    
+    impl ToUInt for Const<257> {
+        type Output = U257;
+    }
+
+    
+    impl ToUInt for Const<258> {
+        type Output = U258;
+    }
+
+    
+    impl ToUInt for Const<259> {
+        type Output = U259;
+    }
+
+    
+    impl ToUInt for Const<260> {
+        type Output = U260;
+    }
+
+    
+    impl ToUInt for Const<261> {
+        type Output = U261;
+    }
+
+    
+    impl ToUInt for Const<262> {
+        type Output = U262;
+    }
+
+    
+    impl ToUInt for Const<263> {
+        type Output = U263;
+    }
+
+    
+    impl ToUInt for Const<264> {
+        type Output = U264;
+    }
+
+    
+    impl ToUInt for Const<265> {
+        type Output = U265;
+    }
+
+    
+    impl ToUInt for Const<266> {
+        type Output = U266;
+    }
+
+    
+    impl ToUInt for Const<267> {
+        type Output = U267;
+    }
+
+    
+    impl ToUInt for Const<268> {
+        type Output = U268;
+    }
+
+    
+    impl ToUInt for Const<269> {
+        type Output = U269;
+    }
+
+    
+    impl ToUInt for Const<270> {
+        type Output = U270;
+    }
+
+    
+    impl ToUInt for Const<271> {
+        type Output = U271;
+    }
+
+    
+    impl ToUInt for Const<272> {
+        type Output = U272;
+    }
+
+    
+    impl ToUInt for Const<273> {
+        type Output = U273;
+    }
+
+    
+    impl ToUInt for Const<274> {
+        type Output = U274;
+    }
+
+    
+    impl ToUInt for Const<275> {
+        type Output = U275;
+    }
+
+    
+    impl ToUInt for Const<276> {
+        type Output = U276;
+    }
+
+    
+    impl ToUInt for Const<277> {
+        type Output = U277;
+    }
+
+    
+    impl ToUInt for Const<278> {
+        type Output = U278;
+    }
+
+    
+    impl ToUInt for Const<279> {
+        type Output = U279;
+    }
+
+    
+    impl ToUInt for Const<280> {
+        type Output = U280;
+    }
+
+    
+    impl ToUInt for Const<281> {
+        type Output = U281;
+    }
+
+    
+    impl ToUInt for Const<282> {
+        type Output = U282;
+    }
+
+    
+    impl ToUInt for Const<283> {
+        type Output = U283;
+    }
+
+    
+    impl ToUInt for Const<284> {
+        type Output = U284;
+    }
+
+    
+    impl ToUInt for Const<285> {
+        type Output = U285;
+    }
+
+    
+    impl ToUInt for Const<286> {
+        type Output = U286;
+    }
+
+    
+    impl ToUInt for Const<287> {
+        type Output = U287;
+    }
+
+    
+    impl ToUInt for Const<288> {
+        type Output = U288;
+    }
+
+    
+    impl ToUInt for Const<289> {
+        type Output = U289;
+    }
+
+    
+    impl ToUInt for Const<290> {
+        type Output = U290;
+    }
+
+    
+    impl ToUInt for Const<291> {
+        type Output = U291;
+    }
+
+    
+    impl ToUInt for Const<292> {
+        type Output = U292;
+    }
+
+    
+    impl ToUInt for Const<293> {
+        type Output = U293;
+    }
+
+    
+    impl ToUInt for Const<294> {
+        type Output = U294;
+    }
+
+    
+    impl ToUInt for Const<295> {
+        type Output = U295;
+    }
+
+    
+    impl ToUInt for Const<296> {
+        type Output = U296;
+    }
+
+    
+    impl ToUInt for Const<297> {
+        type Output = U297;
+    }
+
+    
+    impl ToUInt for Const<298> {
+        type Output = U298;
+    }
+
+    
+    impl ToUInt for Const<299> {
+        type Output = U299;
+    }
+
+    
+    impl ToUInt for Const<300> {
+        type Output = U300;
+    }
+
+    
+    impl ToUInt for Const<301> {
+        type Output = U301;
+    }
+
+    
+    impl ToUInt for Const<302> {
+        type Output = U302;
+    }
+
+    
+    impl ToUInt for Const<303> {
+        type Output = U303;
+    }
+
+    
+    impl ToUInt for Const<304> {
+        type Output = U304;
+    }
+
+    
+    impl ToUInt for Const<305> {
+        type Output = U305;
+    }
+
+    
+    impl ToUInt for Const<306> {
+        type Output = U306;
+    }
+
+    
+    impl ToUInt for Const<307> {
+        type Output = U307;
+    }
+
+    
+    impl ToUInt for Const<308> {
+        type Output = U308;
+    }
+
+    
+    impl ToUInt for Const<309> {
+        type Output = U309;
+    }
+
+    
+    impl ToUInt for Const<310> {
+        type Output = U310;
+    }
+
+    
+    impl ToUInt for Const<311> {
+        type Output = U311;
+    }
+
+    
+    impl ToUInt for Const<312> {
+        type Output = U312;
+    }
+
+    
+    impl ToUInt for Const<313> {
+        type Output = U313;
+    }
+
+    
+    impl ToUInt for Const<314> {
+        type Output = U314;
+    }
+
+    
+    impl ToUInt for Const<315> {
+        type Output = U315;
+    }
+
+    
+    impl ToUInt for Const<316> {
+        type Output = U316;
+    }
+
+    
+    impl ToUInt for Const<317> {
+        type Output = U317;
+    }
+
+    
+    impl ToUInt for Const<318> {
+        type Output = U318;
+    }
+
+    
+    impl ToUInt for Const<319> {
+        type Output = U319;
+    }
+
+    
+    impl ToUInt for Const<320> {
+        type Output = U320;
+    }
+
+    
+    impl ToUInt for Const<321> {
+        type Output = U321;
+    }
+
+    
+    impl ToUInt for Const<322> {
+        type Output = U322;
+    }
+
+    
+    impl ToUInt for Const<323> {
+        type Output = U323;
+    }
+
+    
+    impl ToUInt for Const<324> {
+        type Output = U324;
+    }
+
+    
+    impl ToUInt for Const<325> {
+        type Output = U325;
+    }
+
+    
+    impl ToUInt for Const<326> {
+        type Output = U326;
+    }
+
+    
+    impl ToUInt for Const<327> {
+        type Output = U327;
+    }
+
+    
+    impl ToUInt for Const<328> {
+        type Output = U328;
+    }
+
+    
+    impl ToUInt for Const<329> {
+        type Output = U329;
+    }
+
+    
+    impl ToUInt for Const<330> {
+        type Output = U330;
+    }
+
+    
+    impl ToUInt for Const<331> {
+        type Output = U331;
+    }
+
+    
+    impl ToUInt for Const<332> {
+        type Output = U332;
+    }
+
+    
+    impl ToUInt for Const<333> {
+        type Output = U333;
+    }
+
+    
+    impl ToUInt for Const<334> {
+        type Output = U334;
+    }
+
+    
+    impl ToUInt for Const<335> {
+        type Output = U335;
+    }
+
+    
+    impl ToUInt for Const<336> {
+        type Output = U336;
+    }
+
+    
+    impl ToUInt for Const<337> {
+        type Output = U337;
+    }
+
+    
+    impl ToUInt for Const<338> {
+        type Output = U338;
+    }
+
+    
+    impl ToUInt for Const<339> {
+        type Output = U339;
+    }
+
+    
+    impl ToUInt for Const<340> {
+        type Output = U340;
+    }
+
+    
+    impl ToUInt for Const<341> {
+        type Output = U341;
+    }
+
+    
+    impl ToUInt for Const<342> {
+        type Output = U342;
+    }
+
+    
+    impl ToUInt for Const<343> {
+        type Output = U343;
+    }
+
+    
+    impl ToUInt for Const<344> {
+        type Output = U344;
+    }
+
+    
+    impl ToUInt for Const<345> {
+        type Output = U345;
+    }
+
+    
+    impl ToUInt for Const<346> {
+        type Output = U346;
+    }
+
+    
+    impl ToUInt for Const<347> {
+        type Output = U347;
+    }
+
+    
+    impl ToUInt for Const<348> {
+        type Output = U348;
+    }
+
+    
+    impl ToUInt for Const<349> {
+        type Output = U349;
+    }
+
+    
+    impl ToUInt for Const<350> {
+        type Output = U350;
+    }
+
+    
+    impl ToUInt for Const<351> {
+        type Output = U351;
+    }
+
+    
+    impl ToUInt for Const<352> {
+        type Output = U352;
+    }
+
+    
+    impl ToUInt for Const<353> {
+        type Output = U353;
+    }
+
+    
+    impl ToUInt for Const<354> {
+        type Output = U354;
+    }
+
+    
+    impl ToUInt for Const<355> {
+        type Output = U355;
+    }
+
+    
+    impl ToUInt for Const<356> {
+        type Output = U356;
+    }
+
+    
+    impl ToUInt for Const<357> {
+        type Output = U357;
+    }
+
+    
+    impl ToUInt for Const<358> {
+        type Output = U358;
+    }
+
+    
+    impl ToUInt for Const<359> {
+        type Output = U359;
+    }
+
+    
+    impl ToUInt for Const<360> {
+        type Output = U360;
+    }
+
+    
+    impl ToUInt for Const<361> {
+        type Output = U361;
+    }
+
+    
+    impl ToUInt for Const<362> {
+        type Output = U362;
+    }
+
+    
+    impl ToUInt for Const<363> {
+        type Output = U363;
+    }
+
+    
+    impl ToUInt for Const<364> {
+        type Output = U364;
+    }
+
+    
+    impl ToUInt for Const<365> {
+        type Output = U365;
+    }
+
+    
+    impl ToUInt for Const<366> {
+        type Output = U366;
+    }
+
+    
+    impl ToUInt for Const<367> {
+        type Output = U367;
+    }
+
+    
+    impl ToUInt for Const<368> {
+        type Output = U368;
+    }
+
+    
+    impl ToUInt for Const<369> {
+        type Output = U369;
+    }
+
+    
+    impl ToUInt for Const<370> {
+        type Output = U370;
+    }
+
+    
+    impl ToUInt for Const<371> {
+        type Output = U371;
+    }
+
+    
+    impl ToUInt for Const<372> {
+        type Output = U372;
+    }
+
+    
+    impl ToUInt for Const<373> {
+        type Output = U373;
+    }
+
+    
+    impl ToUInt for Const<374> {
+        type Output = U374;
+    }
+
+    
+    impl ToUInt for Const<375> {
+        type Output = U375;
+    }
+
+    
+    impl ToUInt for Const<376> {
+        type Output = U376;
+    }
+
+    
+    impl ToUInt for Const<377> {
+        type Output = U377;
+    }
+
+    
+    impl ToUInt for Const<378> {
+        type Output = U378;
+    }
+
+    
+    impl ToUInt for Const<379> {
+        type Output = U379;
+    }
+
+    
+    impl ToUInt for Const<380> {
+        type Output = U380;
+    }
+
+    
+    impl ToUInt for Const<381> {
+        type Output = U381;
+    }
+
+    
+    impl ToUInt for Const<382> {
+        type Output = U382;
+    }
+
+    
+    impl ToUInt for Const<383> {
+        type Output = U383;
+    }
+
+    
+    impl ToUInt for Const<384> {
+        type Output = U384;
+    }
+
+    
+    impl ToUInt for Const<385> {
+        type Output = U385;
+    }
+
+    
+    impl ToUInt for Const<386> {
+        type Output = U386;
+    }
+
+    
+    impl ToUInt for Const<387> {
+        type Output = U387;
+    }
+
+    
+    impl ToUInt for Const<388> {
+        type Output = U388;
+    }
+
+    
+    impl ToUInt for Const<389> {
+        type Output = U389;
+    }
+
+    
+    impl ToUInt for Const<390> {
+        type Output = U390;
+    }
+
+    
+    impl ToUInt for Const<391> {
+        type Output = U391;
+    }
+
+    
+    impl ToUInt for Const<392> {
+        type Output = U392;
+    }
+
+    
+    impl ToUInt for Const<393> {
+        type Output = U393;
+    }
+
+    
+    impl ToUInt for Const<394> {
+        type Output = U394;
+    }
+
+    
+    impl ToUInt for Const<395> {
+        type Output = U395;
+    }
+
+    
+    impl ToUInt for Const<396> {
+        type Output = U396;
+    }
+
+    
+    impl ToUInt for Const<397> {
+        type Output = U397;
+    }
+
+    
+    impl ToUInt for Const<398> {
+        type Output = U398;
+    }
+
+    
+    impl ToUInt for Const<399> {
+        type Output = U399;
+    }
+
+    
+    impl ToUInt for Const<400> {
+        type Output = U400;
+    }
+
+    
+    impl ToUInt for Const<401> {
+        type Output = U401;
+    }
+
+    
+    impl ToUInt for Const<402> {
+        type Output = U402;
+    }
+
+    
+    impl ToUInt for Const<403> {
+        type Output = U403;
+    }
+
+    
+    impl ToUInt for Const<404> {
+        type Output = U404;
+    }
+
+    
+    impl ToUInt for Const<405> {
+        type Output = U405;
+    }
+
+    
+    impl ToUInt for Const<406> {
+        type Output = U406;
+    }
+
+    
+    impl ToUInt for Const<407> {
+        type Output = U407;
+    }
+
+    
+    impl ToUInt for Const<408> {
+        type Output = U408;
+    }
+
+    
+    impl ToUInt for Const<409> {
+        type Output = U409;
+    }
+
+    
+    impl ToUInt for Const<410> {
+        type Output = U410;
+    }
+
+    
+    impl ToUInt for Const<411> {
+        type Output = U411;
+    }
+
+    
+    impl ToUInt for Const<412> {
+        type Output = U412;
+    }
+
+    
+    impl ToUInt for Const<413> {
+        type Output = U413;
+    }
+
+    
+    impl ToUInt for Const<414> {
+        type Output = U414;
+    }
+
+    
+    impl ToUInt for Const<415> {
+        type Output = U415;
+    }
+
+    
+    impl ToUInt for Const<416> {
+        type Output = U416;
+    }
+
+    
+    impl ToUInt for Const<417> {
+        type Output = U417;
+    }
+
+    
+    impl ToUInt for Const<418> {
+        type Output = U418;
+    }
+
+    
+    impl ToUInt for Const<419> {
+        type Output = U419;
+    }
+
+    
+    impl ToUInt for Const<420> {
+        type Output = U420;
+    }
+
+    
+    impl ToUInt for Const<421> {
+        type Output = U421;
+    }
+
+    
+    impl ToUInt for Const<422> {
+        type Output = U422;
+    }
+
+    
+    impl ToUInt for Const<423> {
+        type Output = U423;
+    }
+
+    
+    impl ToUInt for Const<424> {
+        type Output = U424;
+    }
+
+    
+    impl ToUInt for Const<425> {
+        type Output = U425;
+    }
+
+    
+    impl ToUInt for Const<426> {
+        type Output = U426;
+    }
+
+    
+    impl ToUInt for Const<427> {
+        type Output = U427;
+    }
+
+    
+    impl ToUInt for Const<428> {
+        type Output = U428;
+    }
+
+    
+    impl ToUInt for Const<429> {
+        type Output = U429;
+    }
+
+    
+    impl ToUInt for Const<430> {
+        type Output = U430;
+    }
+
+    
+    impl ToUInt for Const<431> {
+        type Output = U431;
+    }
+
+    
+    impl ToUInt for Const<432> {
+        type Output = U432;
+    }
+
+    
+    impl ToUInt for Const<433> {
+        type Output = U433;
+    }
+
+    
+    impl ToUInt for Const<434> {
+        type Output = U434;
+    }
+
+    
+    impl ToUInt for Const<435> {
+        type Output = U435;
+    }
+
+    
+    impl ToUInt for Const<436> {
+        type Output = U436;
+    }
+
+    
+    impl ToUInt for Const<437> {
+        type Output = U437;
+    }
+
+    
+    impl ToUInt for Const<438> {
+        type Output = U438;
+    }
+
+    
+    impl ToUInt for Const<439> {
+        type Output = U439;
+    }
+
+    
+    impl ToUInt for Const<440> {
+        type Output = U440;
+    }
+
+    
+    impl ToUInt for Const<441> {
+        type Output = U441;
+    }
+
+    
+    impl ToUInt for Const<442> {
+        type Output = U442;
+    }
+
+    
+    impl ToUInt for Const<443> {
+        type Output = U443;
+    }
+
+    
+    impl ToUInt for Const<444> {
+        type Output = U444;
+    }
+
+    
+    impl ToUInt for Const<445> {
+        type Output = U445;
+    }
+
+    
+    impl ToUInt for Const<446> {
+        type Output = U446;
+    }
+
+    
+    impl ToUInt for Const<447> {
+        type Output = U447;
+    }
+
+    
+    impl ToUInt for Const<448> {
+        type Output = U448;
+    }
+
+    
+    impl ToUInt for Const<449> {
+        type Output = U449;
+    }
+
+    
+    impl ToUInt for Const<450> {
+        type Output = U450;
+    }
+
+    
+    impl ToUInt for Const<451> {
+        type Output = U451;
+    }
+
+    
+    impl ToUInt for Const<452> {
+        type Output = U452;
+    }
+
+    
+    impl ToUInt for Const<453> {
+        type Output = U453;
+    }
+
+    
+    impl ToUInt for Const<454> {
+        type Output = U454;
+    }
+
+    
+    impl ToUInt for Const<455> {
+        type Output = U455;
+    }
+
+    
+    impl ToUInt for Const<456> {
+        type Output = U456;
+    }
+
+    
+    impl ToUInt for Const<457> {
+        type Output = U457;
+    }
+
+    
+    impl ToUInt for Const<458> {
+        type Output = U458;
+    }
+
+    
+    impl ToUInt for Const<459> {
+        type Output = U459;
+    }
+
+    
+    impl ToUInt for Const<460> {
+        type Output = U460;
+    }
+
+    
+    impl ToUInt for Const<461> {
+        type Output = U461;
+    }
+
+    
+    impl ToUInt for Const<462> {
+        type Output = U462;
+    }
+
+    
+    impl ToUInt for Const<463> {
+        type Output = U463;
+    }
+
+    
+    impl ToUInt for Const<464> {
+        type Output = U464;
+    }
+
+    
+    impl ToUInt for Const<465> {
+        type Output = U465;
+    }
+
+    
+    impl ToUInt for Const<466> {
+        type Output = U466;
+    }
+
+    
+    impl ToUInt for Const<467> {
+        type Output = U467;
+    }
+
+    
+    impl ToUInt for Const<468> {
+        type Output = U468;
+    }
+
+    
+    impl ToUInt for Const<469> {
+        type Output = U469;
+    }
+
+    
+    impl ToUInt for Const<470> {
+        type Output = U470;
+    }
+
+    
+    impl ToUInt for Const<471> {
+        type Output = U471;
+    }
+
+    
+    impl ToUInt for Const<472> {
+        type Output = U472;
+    }
+
+    
+    impl ToUInt for Const<473> {
+        type Output = U473;
+    }
+
+    
+    impl ToUInt for Const<474> {
+        type Output = U474;
+    }
+
+    
+    impl ToUInt for Const<475> {
+        type Output = U475;
+    }
+
+    
+    impl ToUInt for Const<476> {
+        type Output = U476;
+    }
+
+    
+    impl ToUInt for Const<477> {
+        type Output = U477;
+    }
+
+    
+    impl ToUInt for Const<478> {
+        type Output = U478;
+    }
+
+    
+    impl ToUInt for Const<479> {
+        type Output = U479;
+    }
+
+    
+    impl ToUInt for Const<480> {
+        type Output = U480;
+    }
+
+    
+    impl ToUInt for Const<481> {
+        type Output = U481;
+    }
+
+    
+    impl ToUInt for Const<482> {
+        type Output = U482;
+    }
+
+    
+    impl ToUInt for Const<483> {
+        type Output = U483;
+    }
+
+    
+    impl ToUInt for Const<484> {
+        type Output = U484;
+    }
+
+    
+    impl ToUInt for Const<485> {
+        type Output = U485;
+    }
+
+    
+    impl ToUInt for Const<486> {
+        type Output = U486;
+    }
+
+    
+    impl ToUInt for Const<487> {
+        type Output = U487;
+    }
+
+    
+    impl ToUInt for Const<488> {
+        type Output = U488;
+    }
+
+    
+    impl ToUInt for Const<489> {
+        type Output = U489;
+    }
+
+    
+    impl ToUInt for Const<490> {
+        type Output = U490;
+    }
+
+    
+    impl ToUInt for Const<491> {
+        type Output = U491;
+    }
+
+    
+    impl ToUInt for Const<492> {
+        type Output = U492;
+    }
+
+    
+    impl ToUInt for Const<493> {
+        type Output = U493;
+    }
+
+    
+    impl ToUInt for Const<494> {
+        type Output = U494;
+    }
+
+    
+    impl ToUInt for Const<495> {
+        type Output = U495;
+    }
+
+    
+    impl ToUInt for Const<496> {
+        type Output = U496;
+    }
+
+    
+    impl ToUInt for Const<497> {
+        type Output = U497;
+    }
+
+    
+    impl ToUInt for Const<498> {
+        type Output = U498;
+    }
+
+    
+    impl ToUInt for Const<499> {
+        type Output = U499;
+    }
+
+    
+    impl ToUInt for Const<500> {
+        type Output = U500;
+    }
+
+    
+    impl ToUInt for Const<501> {
+        type Output = U501;
+    }
+
+    
+    impl ToUInt for Const<502> {
+        type Output = U502;
+    }
+
+    
+    impl ToUInt for Const<503> {
+        type Output = U503;
+    }
+
+    
+    impl ToUInt for Const<504> {
+        type Output = U504;
+    }
+
+    
+    impl ToUInt for Const<505> {
+        type Output = U505;
+    }
+
+    
+    impl ToUInt for Const<506> {
+        type Output = U506;
+    }
+
+    
+    impl ToUInt for Const<507> {
+        type Output = U507;
+    }
+
+    
+    impl ToUInt for Const<508> {
+        type Output = U508;
+    }
+
+    
+    impl ToUInt for Const<509> {
+        type Output = U509;
+    }
+
+    
+    impl ToUInt for Const<510> {
+        type Output = U510;
+    }
+
+    
+    impl ToUInt for Const<511> {
+        type Output = U511;
+    }
+
+    
+    impl ToUInt for Const<512> {
+        type Output = U512;
+    }
+
+    
+    impl ToUInt for Const<513> {
+        type Output = U513;
+    }
+
+    
+    impl ToUInt for Const<514> {
+        type Output = U514;
+    }
+
+    
+    impl ToUInt for Const<515> {
+        type Output = U515;
+    }
+
+    
+    impl ToUInt for Const<516> {
+        type Output = U516;
+    }
+
+    
+    impl ToUInt for Const<517> {
+        type Output = U517;
+    }
+
+    
+    impl ToUInt for Const<518> {
+        type Output = U518;
+    }
+
+    
+    impl ToUInt for Const<519> {
+        type Output = U519;
+    }
+
+    
+    impl ToUInt for Const<520> {
+        type Output = U520;
+    }
+
+    
+    impl ToUInt for Const<521> {
+        type Output = U521;
+    }
+
+    
+    impl ToUInt for Const<522> {
+        type Output = U522;
+    }
+
+    
+    impl ToUInt for Const<523> {
+        type Output = U523;
+    }
+
+    
+    impl ToUInt for Const<524> {
+        type Output = U524;
+    }
+
+    
+    impl ToUInt for Const<525> {
+        type Output = U525;
+    }
+
+    
+    impl ToUInt for Const<526> {
+        type Output = U526;
+    }
+
+    
+    impl ToUInt for Const<527> {
+        type Output = U527;
+    }
+
+    
+    impl ToUInt for Const<528> {
+        type Output = U528;
+    }
+
+    
+    impl ToUInt for Const<529> {
+        type Output = U529;
+    }
+
+    
+    impl ToUInt for Const<530> {
+        type Output = U530;
+    }
+
+    
+    impl ToUInt for Const<531> {
+        type Output = U531;
+    }
+
+    
+    impl ToUInt for Const<532> {
+        type Output = U532;
+    }
+
+    
+    impl ToUInt for Const<533> {
+        type Output = U533;
+    }
+
+    
+    impl ToUInt for Const<534> {
+        type Output = U534;
+    }
+
+    
+    impl ToUInt for Const<535> {
+        type Output = U535;
+    }
+
+    
+    impl ToUInt for Const<536> {
+        type Output = U536;
+    }
+
+    
+    impl ToUInt for Const<537> {
+        type Output = U537;
+    }
+
+    
+    impl ToUInt for Const<538> {
+        type Output = U538;
+    }
+
+    
+    impl ToUInt for Const<539> {
+        type Output = U539;
+    }
+
+    
+    impl ToUInt for Const<540> {
+        type Output = U540;
+    }
+
+    
+    impl ToUInt for Const<541> {
+        type Output = U541;
+    }
+
+    
+    impl ToUInt for Const<542> {
+        type Output = U542;
+    }
+
+    
+    impl ToUInt for Const<543> {
+        type Output = U543;
+    }
+
+    
+    impl ToUInt for Const<544> {
+        type Output = U544;
+    }
+
+    
+    impl ToUInt for Const<545> {
+        type Output = U545;
+    }
+
+    
+    impl ToUInt for Const<546> {
+        type Output = U546;
+    }
+
+    
+    impl ToUInt for Const<547> {
+        type Output = U547;
+    }
+
+    
+    impl ToUInt for Const<548> {
+        type Output = U548;
+    }
+
+    
+    impl ToUInt for Const<549> {
+        type Output = U549;
+    }
+
+    
+    impl ToUInt for Const<550> {
+        type Output = U550;
+    }
+
+    
+    impl ToUInt for Const<551> {
+        type Output = U551;
+    }
+
+    
+    impl ToUInt for Const<552> {
+        type Output = U552;
+    }
+
+    
+    impl ToUInt for Const<553> {
+        type Output = U553;
+    }
+
+    
+    impl ToUInt for Const<554> {
+        type Output = U554;
+    }
+
+    
+    impl ToUInt for Const<555> {
+        type Output = U555;
+    }
+
+    
+    impl ToUInt for Const<556> {
+        type Output = U556;
+    }
+
+    
+    impl ToUInt for Const<557> {
+        type Output = U557;
+    }
+
+    
+    impl ToUInt for Const<558> {
+        type Output = U558;
+    }
+
+    
+    impl ToUInt for Const<559> {
+        type Output = U559;
+    }
+
+    
+    impl ToUInt for Const<560> {
+        type Output = U560;
+    }
+
+    
+    impl ToUInt for Const<561> {
+        type Output = U561;
+    }
+
+    
+    impl ToUInt for Const<562> {
+        type Output = U562;
+    }
+
+    
+    impl ToUInt for Const<563> {
+        type Output = U563;
+    }
+
+    
+    impl ToUInt for Const<564> {
+        type Output = U564;
+    }
+
+    
+    impl ToUInt for Const<565> {
+        type Output = U565;
+    }
+
+    
+    impl ToUInt for Const<566> {
+        type Output = U566;
+    }
+
+    
+    impl ToUInt for Const<567> {
+        type Output = U567;
+    }
+
+    
+    impl ToUInt for Const<568> {
+        type Output = U568;
+    }
+
+    
+    impl ToUInt for Const<569> {
+        type Output = U569;
+    }
+
+    
+    impl ToUInt for Const<570> {
+        type Output = U570;
+    }
+
+    
+    impl ToUInt for Const<571> {
+        type Output = U571;
+    }
+
+    
+    impl ToUInt for Const<572> {
+        type Output = U572;
+    }
+
+    
+    impl ToUInt for Const<573> {
+        type Output = U573;
+    }
+
+    
+    impl ToUInt for Const<574> {
+        type Output = U574;
+    }
+
+    
+    impl ToUInt for Const<575> {
+        type Output = U575;
+    }
+
+    
+    impl ToUInt for Const<576> {
+        type Output = U576;
+    }
+
+    
+    impl ToUInt for Const<577> {
+        type Output = U577;
+    }
+
+    
+    impl ToUInt for Const<578> {
+        type Output = U578;
+    }
+
+    
+    impl ToUInt for Const<579> {
+        type Output = U579;
+    }
+
+    
+    impl ToUInt for Const<580> {
+        type Output = U580;
+    }
+
+    
+    impl ToUInt for Const<581> {
+        type Output = U581;
+    }
+
+    
+    impl ToUInt for Const<582> {
+        type Output = U582;
+    }
+
+    
+    impl ToUInt for Const<583> {
+        type Output = U583;
+    }
+
+    
+    impl ToUInt for Const<584> {
+        type Output = U584;
+    }
+
+    
+    impl ToUInt for Const<585> {
+        type Output = U585;
+    }
+
+    
+    impl ToUInt for Const<586> {
+        type Output = U586;
+    }
+
+    
+    impl ToUInt for Const<587> {
+        type Output = U587;
+    }
+
+    
+    impl ToUInt for Const<588> {
+        type Output = U588;
+    }
+
+    
+    impl ToUInt for Const<589> {
+        type Output = U589;
+    }
+
+    
+    impl ToUInt for Const<590> {
+        type Output = U590;
+    }
+
+    
+    impl ToUInt for Const<591> {
+        type Output = U591;
+    }
+
+    
+    impl ToUInt for Const<592> {
+        type Output = U592;
+    }
+
+    
+    impl ToUInt for Const<593> {
+        type Output = U593;
+    }
+
+    
+    impl ToUInt for Const<594> {
+        type Output = U594;
+    }
+
+    
+    impl ToUInt for Const<595> {
+        type Output = U595;
+    }
+
+    
+    impl ToUInt for Const<596> {
+        type Output = U596;
+    }
+
+    
+    impl ToUInt for Const<597> {
+        type Output = U597;
+    }
+
+    
+    impl ToUInt for Const<598> {
+        type Output = U598;
+    }
+
+    
+    impl ToUInt for Const<599> {
+        type Output = U599;
+    }
+
+    
+    impl ToUInt for Const<600> {
+        type Output = U600;
+    }
+
+    
+    impl ToUInt for Const<601> {
+        type Output = U601;
+    }
+
+    
+    impl ToUInt for Const<602> {
+        type Output = U602;
+    }
+
+    
+    impl ToUInt for Const<603> {
+        type Output = U603;
+    }
+
+    
+    impl ToUInt for Const<604> {
+        type Output = U604;
+    }
+
+    
+    impl ToUInt for Const<605> {
+        type Output = U605;
+    }
+
+    
+    impl ToUInt for Const<606> {
+        type Output = U606;
+    }
+
+    
+    impl ToUInt for Const<607> {
+        type Output = U607;
+    }
+
+    
+    impl ToUInt for Const<608> {
+        type Output = U608;
+    }
+
+    
+    impl ToUInt for Const<609> {
+        type Output = U609;
+    }
+
+    
+    impl ToUInt for Const<610> {
+        type Output = U610;
+    }
+
+    
+    impl ToUInt for Const<611> {
+        type Output = U611;
+    }
+
+    
+    impl ToUInt for Const<612> {
+        type Output = U612;
+    }
+
+    
+    impl ToUInt for Const<613> {
+        type Output = U613;
+    }
+
+    
+    impl ToUInt for Const<614> {
+        type Output = U614;
+    }
+
+    
+    impl ToUInt for Const<615> {
+        type Output = U615;
+    }
+
+    
+    impl ToUInt for Const<616> {
+        type Output = U616;
+    }
+
+    
+    impl ToUInt for Const<617> {
+        type Output = U617;
+    }
+
+    
+    impl ToUInt for Const<618> {
+        type Output = U618;
+    }
+
+    
+    impl ToUInt for Const<619> {
+        type Output = U619;
+    }
+
+    
+    impl ToUInt for Const<620> {
+        type Output = U620;
+    }
+
+    
+    impl ToUInt for Const<621> {
+        type Output = U621;
+    }
+
+    
+    impl ToUInt for Const<622> {
+        type Output = U622;
+    }
+
+    
+    impl ToUInt for Const<623> {
+        type Output = U623;
+    }
+
+    
+    impl ToUInt for Const<624> {
+        type Output = U624;
+    }
+
+    
+    impl ToUInt for Const<625> {
+        type Output = U625;
+    }
+
+    
+    impl ToUInt for Const<626> {
+        type Output = U626;
+    }
+
+    
+    impl ToUInt for Const<627> {
+        type Output = U627;
+    }
+
+    
+    impl ToUInt for Const<628> {
+        type Output = U628;
+    }
+
+    
+    impl ToUInt for Const<629> {
+        type Output = U629;
+    }
+
+    
+    impl ToUInt for Const<630> {
+        type Output = U630;
+    }
+
+    
+    impl ToUInt for Const<631> {
+        type Output = U631;
+    }
+
+    
+    impl ToUInt for Const<632> {
+        type Output = U632;
+    }
+
+    
+    impl ToUInt for Const<633> {
+        type Output = U633;
+    }
+
+    
+    impl ToUInt for Const<634> {
+        type Output = U634;
+    }
+
+    
+    impl ToUInt for Const<635> {
+        type Output = U635;
+    }
+
+    
+    impl ToUInt for Const<636> {
+        type Output = U636;
+    }
+
+    
+    impl ToUInt for Const<637> {
+        type Output = U637;
+    }
+
+    
+    impl ToUInt for Const<638> {
+        type Output = U638;
+    }
+
+    
+    impl ToUInt for Const<639> {
+        type Output = U639;
+    }
+
+    
+    impl ToUInt for Const<640> {
+        type Output = U640;
+    }
+
+    
+    impl ToUInt for Const<641> {
+        type Output = U641;
+    }
+
+    
+    impl ToUInt for Const<642> {
+        type Output = U642;
+    }
+
+    
+    impl ToUInt for Const<643> {
+        type Output = U643;
+    }
+
+    
+    impl ToUInt for Const<644> {
+        type Output = U644;
+    }
+
+    
+    impl ToUInt for Const<645> {
+        type Output = U645;
+    }
+
+    
+    impl ToUInt for Const<646> {
+        type Output = U646;
+    }
+
+    
+    impl ToUInt for Const<647> {
+        type Output = U647;
+    }
+
+    
+    impl ToUInt for Const<648> {
+        type Output = U648;
+    }
+
+    
+    impl ToUInt for Const<649> {
+        type Output = U649;
+    }
+
+    
+    impl ToUInt for Const<650> {
+        type Output = U650;
+    }
+
+    
+    impl ToUInt for Const<651> {
+        type Output = U651;
+    }
+
+    
+    impl ToUInt for Const<652> {
+        type Output = U652;
+    }
+
+    
+    impl ToUInt for Const<653> {
+        type Output = U653;
+    }
+
+    
+    impl ToUInt for Const<654> {
+        type Output = U654;
+    }
+
+    
+    impl ToUInt for Const<655> {
+        type Output = U655;
+    }
+
+    
+    impl ToUInt for Const<656> {
+        type Output = U656;
+    }
+
+    
+    impl ToUInt for Const<657> {
+        type Output = U657;
+    }
+
+    
+    impl ToUInt for Const<658> {
+        type Output = U658;
+    }
+
+    
+    impl ToUInt for Const<659> {
+        type Output = U659;
+    }
+
+    
+    impl ToUInt for Const<660> {
+        type Output = U660;
+    }
+
+    
+    impl ToUInt for Const<661> {
+        type Output = U661;
+    }
+
+    
+    impl ToUInt for Const<662> {
+        type Output = U662;
+    }
+
+    
+    impl ToUInt for Const<663> {
+        type Output = U663;
+    }
+
+    
+    impl ToUInt for Const<664> {
+        type Output = U664;
+    }
+
+    
+    impl ToUInt for Const<665> {
+        type Output = U665;
+    }
+
+    
+    impl ToUInt for Const<666> {
+        type Output = U666;
+    }
+
+    
+    impl ToUInt for Const<667> {
+        type Output = U667;
+    }
+
+    
+    impl ToUInt for Const<668> {
+        type Output = U668;
+    }
+
+    
+    impl ToUInt for Const<669> {
+        type Output = U669;
+    }
+
+    
+    impl ToUInt for Const<670> {
+        type Output = U670;
+    }
+
+    
+    impl ToUInt for Const<671> {
+        type Output = U671;
+    }
+
+    
+    impl ToUInt for Const<672> {
+        type Output = U672;
+    }
+
+    
+    impl ToUInt for Const<673> {
+        type Output = U673;
+    }
+
+    
+    impl ToUInt for Const<674> {
+        type Output = U674;
+    }
+
+    
+    impl ToUInt for Const<675> {
+        type Output = U675;
+    }
+
+    
+    impl ToUInt for Const<676> {
+        type Output = U676;
+    }
+
+    
+    impl ToUInt for Const<677> {
+        type Output = U677;
+    }
+
+    
+    impl ToUInt for Const<678> {
+        type Output = U678;
+    }
+
+    
+    impl ToUInt for Const<679> {
+        type Output = U679;
+    }
+
+    
+    impl ToUInt for Const<680> {
+        type Output = U680;
+    }
+
+    
+    impl ToUInt for Const<681> {
+        type Output = U681;
+    }
+
+    
+    impl ToUInt for Const<682> {
+        type Output = U682;
+    }
+
+    
+    impl ToUInt for Const<683> {
+        type Output = U683;
+    }
+
+    
+    impl ToUInt for Const<684> {
+        type Output = U684;
+    }
+
+    
+    impl ToUInt for Const<685> {
+        type Output = U685;
+    }
+
+    
+    impl ToUInt for Const<686> {
+        type Output = U686;
+    }
+
+    
+    impl ToUInt for Const<687> {
+        type Output = U687;
+    }
+
+    
+    impl ToUInt for Const<688> {
+        type Output = U688;
+    }
+
+    
+    impl ToUInt for Const<689> {
+        type Output = U689;
+    }
+
+    
+    impl ToUInt for Const<690> {
+        type Output = U690;
+    }
+
+    
+    impl ToUInt for Const<691> {
+        type Output = U691;
+    }
+
+    
+    impl ToUInt for Const<692> {
+        type Output = U692;
+    }
+
+    
+    impl ToUInt for Const<693> {
+        type Output = U693;
+    }
+
+    
+    impl ToUInt for Const<694> {
+        type Output = U694;
+    }
+
+    
+    impl ToUInt for Const<695> {
+        type Output = U695;
+    }
+
+    
+    impl ToUInt for Const<696> {
+        type Output = U696;
+    }
+
+    
+    impl ToUInt for Const<697> {
+        type Output = U697;
+    }
+
+    
+    impl ToUInt for Const<698> {
+        type Output = U698;
+    }
+
+    
+    impl ToUInt for Const<699> {
+        type Output = U699;
+    }
+
+    
+    impl ToUInt for Const<700> {
+        type Output = U700;
+    }
+
+    
+    impl ToUInt for Const<701> {
+        type Output = U701;
+    }
+
+    
+    impl ToUInt for Const<702> {
+        type Output = U702;
+    }
+
+    
+    impl ToUInt for Const<703> {
+        type Output = U703;
+    }
+
+    
+    impl ToUInt for Const<704> {
+        type Output = U704;
+    }
+
+    
+    impl ToUInt for Const<705> {
+        type Output = U705;
+    }
+
+    
+    impl ToUInt for Const<706> {
+        type Output = U706;
+    }
+
+    
+    impl ToUInt for Const<707> {
+        type Output = U707;
+    }
+
+    
+    impl ToUInt for Const<708> {
+        type Output = U708;
+    }
+
+    
+    impl ToUInt for Const<709> {
+        type Output = U709;
+    }
+
+    
+    impl ToUInt for Const<710> {
+        type Output = U710;
+    }
+
+    
+    impl ToUInt for Const<711> {
+        type Output = U711;
+    }
+
+    
+    impl ToUInt for Const<712> {
+        type Output = U712;
+    }
+
+    
+    impl ToUInt for Const<713> {
+        type Output = U713;
+    }
+
+    
+    impl ToUInt for Const<714> {
+        type Output = U714;
+    }
+
+    
+    impl ToUInt for Const<715> {
+        type Output = U715;
+    }
+
+    
+    impl ToUInt for Const<716> {
+        type Output = U716;
+    }
+
+    
+    impl ToUInt for Const<717> {
+        type Output = U717;
+    }
+
+    
+    impl ToUInt for Const<718> {
+        type Output = U718;
+    }
+
+    
+    impl ToUInt for Const<719> {
+        type Output = U719;
+    }
+
+    
+    impl ToUInt for Const<720> {
+        type Output = U720;
+    }
+
+    
+    impl ToUInt for Const<721> {
+        type Output = U721;
+    }
+
+    
+    impl ToUInt for Const<722> {
+        type Output = U722;
+    }
+
+    
+    impl ToUInt for Const<723> {
+        type Output = U723;
+    }
+
+    
+    impl ToUInt for Const<724> {
+        type Output = U724;
+    }
+
+    
+    impl ToUInt for Const<725> {
+        type Output = U725;
+    }
+
+    
+    impl ToUInt for Const<726> {
+        type Output = U726;
+    }
+
+    
+    impl ToUInt for Const<727> {
+        type Output = U727;
+    }
+
+    
+    impl ToUInt for Const<728> {
+        type Output = U728;
+    }
+
+    
+    impl ToUInt for Const<729> {
+        type Output = U729;
+    }
+
+    
+    impl ToUInt for Const<730> {
+        type Output = U730;
+    }
+
+    
+    impl ToUInt for Const<731> {
+        type Output = U731;
+    }
+
+    
+    impl ToUInt for Const<732> {
+        type Output = U732;
+    }
+
+    
+    impl ToUInt for Const<733> {
+        type Output = U733;
+    }
+
+    
+    impl ToUInt for Const<734> {
+        type Output = U734;
+    }
+
+    
+    impl ToUInt for Const<735> {
+        type Output = U735;
+    }
+
+    
+    impl ToUInt for Const<736> {
+        type Output = U736;
+    }
+
+    
+    impl ToUInt for Const<737> {
+        type Output = U737;
+    }
+
+    
+    impl ToUInt for Const<738> {
+        type Output = U738;
+    }
+
+    
+    impl ToUInt for Const<739> {
+        type Output = U739;
+    }
+
+    
+    impl ToUInt for Const<740> {
+        type Output = U740;
+    }
+
+    
+    impl ToUInt for Const<741> {
+        type Output = U741;
+    }
+
+    
+    impl ToUInt for Const<742> {
+        type Output = U742;
+    }
+
+    
+    impl ToUInt for Const<743> {
+        type Output = U743;
+    }
+
+    
+    impl ToUInt for Const<744> {
+        type Output = U744;
+    }
+
+    
+    impl ToUInt for Const<745> {
+        type Output = U745;
+    }
+
+    
+    impl ToUInt for Const<746> {
+        type Output = U746;
+    }
+
+    
+    impl ToUInt for Const<747> {
+        type Output = U747;
+    }
+
+    
+    impl ToUInt for Const<748> {
+        type Output = U748;
+    }
+
+    
+    impl ToUInt for Const<749> {
+        type Output = U749;
+    }
+
+    
+    impl ToUInt for Const<750> {
+        type Output = U750;
+    }
+
+    
+    impl ToUInt for Const<751> {
+        type Output = U751;
+    }
+
+    
+    impl ToUInt for Const<752> {
+        type Output = U752;
+    }
+
+    
+    impl ToUInt for Const<753> {
+        type Output = U753;
+    }
+
+    
+    impl ToUInt for Const<754> {
+        type Output = U754;
+    }
+
+    
+    impl ToUInt for Const<755> {
+        type Output = U755;
+    }
+
+    
+    impl ToUInt for Const<756> {
+        type Output = U756;
+    }
+
+    
+    impl ToUInt for Const<757> {
+        type Output = U757;
+    }
+
+    
+    impl ToUInt for Const<758> {
+        type Output = U758;
+    }
+
+    
+    impl ToUInt for Const<759> {
+        type Output = U759;
+    }
+
+    
+    impl ToUInt for Const<760> {
+        type Output = U760;
+    }
+
+    
+    impl ToUInt for Const<761> {
+        type Output = U761;
+    }
+
+    
+    impl ToUInt for Const<762> {
+        type Output = U762;
+    }
+
+    
+    impl ToUInt for Const<763> {
+        type Output = U763;
+    }
+
+    
+    impl ToUInt for Const<764> {
+        type Output = U764;
+    }
+
+    
+    impl ToUInt for Const<765> {
+        type Output = U765;
+    }
+
+    
+    impl ToUInt for Const<766> {
+        type Output = U766;
+    }
+
+    
+    impl ToUInt for Const<767> {
+        type Output = U767;
+    }
+
+    
+    impl ToUInt for Const<768> {
+        type Output = U768;
+    }
+
+    
+    impl ToUInt for Const<769> {
+        type Output = U769;
+    }
+
+    
+    impl ToUInt for Const<770> {
+        type Output = U770;
+    }
+
+    
+    impl ToUInt for Const<771> {
+        type Output = U771;
+    }
+
+    
+    impl ToUInt for Const<772> {
+        type Output = U772;
+    }
+
+    
+    impl ToUInt for Const<773> {
+        type Output = U773;
+    }
+
+    
+    impl ToUInt for Const<774> {
+        type Output = U774;
+    }
+
+    
+    impl ToUInt for Const<775> {
+        type Output = U775;
+    }
+
+    
+    impl ToUInt for Const<776> {
+        type Output = U776;
+    }
+
+    
+    impl ToUInt for Const<777> {
+        type Output = U777;
+    }
+
+    
+    impl ToUInt for Const<778> {
+        type Output = U778;
+    }
+
+    
+    impl ToUInt for Const<779> {
+        type Output = U779;
+    }
+
+    
+    impl ToUInt for Const<780> {
+        type Output = U780;
+    }
+
+    
+    impl ToUInt for Const<781> {
+        type Output = U781;
+    }
+
+    
+    impl ToUInt for Const<782> {
+        type Output = U782;
+    }
+
+    
+    impl ToUInt for Const<783> {
+        type Output = U783;
+    }
+
+    
+    impl ToUInt for Const<784> {
+        type Output = U784;
+    }
+
+    
+    impl ToUInt for Const<785> {
+        type Output = U785;
+    }
+
+    
+    impl ToUInt for Const<786> {
+        type Output = U786;
+    }
+
+    
+    impl ToUInt for Const<787> {
+        type Output = U787;
+    }
+
+    
+    impl ToUInt for Const<788> {
+        type Output = U788;
+    }
+
+    
+    impl ToUInt for Const<789> {
+        type Output = U789;
+    }
+
+    
+    impl ToUInt for Const<790> {
+        type Output = U790;
+    }
+
+    
+    impl ToUInt for Const<791> {
+        type Output = U791;
+    }
+
+    
+    impl ToUInt for Const<792> {
+        type Output = U792;
+    }
+
+    
+    impl ToUInt for Const<793> {
+        type Output = U793;
+    }
+
+    
+    impl ToUInt for Const<794> {
+        type Output = U794;
+    }
+
+    
+    impl ToUInt for Const<795> {
+        type Output = U795;
+    }
+
+    
+    impl ToUInt for Const<796> {
+        type Output = U796;
+    }
+
+    
+    impl ToUInt for Const<797> {
+        type Output = U797;
+    }
+
+    
+    impl ToUInt for Const<798> {
+        type Output = U798;
+    }
+
+    
+    impl ToUInt for Const<799> {
+        type Output = U799;
+    }
+
+    
+    impl ToUInt for Const<800> {
+        type Output = U800;
+    }
+
+    
+    impl ToUInt for Const<801> {
+        type Output = U801;
+    }
+
+    
+    impl ToUInt for Const<802> {
+        type Output = U802;
+    }
+
+    
+    impl ToUInt for Const<803> {
+        type Output = U803;
+    }
+
+    
+    impl ToUInt for Const<804> {
+        type Output = U804;
+    }
+
+    
+    impl ToUInt for Const<805> {
+        type Output = U805;
+    }
+
+    
+    impl ToUInt for Const<806> {
+        type Output = U806;
+    }
+
+    
+    impl ToUInt for Const<807> {
+        type Output = U807;
+    }
+
+    
+    impl ToUInt for Const<808> {
+        type Output = U808;
+    }
+
+    
+    impl ToUInt for Const<809> {
+        type Output = U809;
+    }
+
+    
+    impl ToUInt for Const<810> {
+        type Output = U810;
+    }
+
+    
+    impl ToUInt for Const<811> {
+        type Output = U811;
+    }
+
+    
+    impl ToUInt for Const<812> {
+        type Output = U812;
+    }
+
+    
+    impl ToUInt for Const<813> {
+        type Output = U813;
+    }
+
+    
+    impl ToUInt for Const<814> {
+        type Output = U814;
+    }
+
+    
+    impl ToUInt for Const<815> {
+        type Output = U815;
+    }
+
+    
+    impl ToUInt for Const<816> {
+        type Output = U816;
+    }
+
+    
+    impl ToUInt for Const<817> {
+        type Output = U817;
+    }
+
+    
+    impl ToUInt for Const<818> {
+        type Output = U818;
+    }
+
+    
+    impl ToUInt for Const<819> {
+        type Output = U819;
+    }
+
+    
+    impl ToUInt for Const<820> {
+        type Output = U820;
+    }
+
+    
+    impl ToUInt for Const<821> {
+        type Output = U821;
+    }
+
+    
+    impl ToUInt for Const<822> {
+        type Output = U822;
+    }
+
+    
+    impl ToUInt for Const<823> {
+        type Output = U823;
+    }
+
+    
+    impl ToUInt for Const<824> {
+        type Output = U824;
+    }
+
+    
+    impl ToUInt for Const<825> {
+        type Output = U825;
+    }
+
+    
+    impl ToUInt for Const<826> {
+        type Output = U826;
+    }
+
+    
+    impl ToUInt for Const<827> {
+        type Output = U827;
+    }
+
+    
+    impl ToUInt for Const<828> {
+        type Output = U828;
+    }
+
+    
+    impl ToUInt for Const<829> {
+        type Output = U829;
+    }
+
+    
+    impl ToUInt for Const<830> {
+        type Output = U830;
+    }
+
+    
+    impl ToUInt for Const<831> {
+        type Output = U831;
+    }
+
+    
+    impl ToUInt for Const<832> {
+        type Output = U832;
+    }
+
+    
+    impl ToUInt for Const<833> {
+        type Output = U833;
+    }
+
+    
+    impl ToUInt for Const<834> {
+        type Output = U834;
+    }
+
+    
+    impl ToUInt for Const<835> {
+        type Output = U835;
+    }
+
+    
+    impl ToUInt for Const<836> {
+        type Output = U836;
+    }
+
+    
+    impl ToUInt for Const<837> {
+        type Output = U837;
+    }
+
+    
+    impl ToUInt for Const<838> {
+        type Output = U838;
+    }
+
+    
+    impl ToUInt for Const<839> {
+        type Output = U839;
+    }
+
+    
+    impl ToUInt for Const<840> {
+        type Output = U840;
+    }
+
+    
+    impl ToUInt for Const<841> {
+        type Output = U841;
+    }
+
+    
+    impl ToUInt for Const<842> {
+        type Output = U842;
+    }
+
+    
+    impl ToUInt for Const<843> {
+        type Output = U843;
+    }
+
+    
+    impl ToUInt for Const<844> {
+        type Output = U844;
+    }
+
+    
+    impl ToUInt for Const<845> {
+        type Output = U845;
+    }
+
+    
+    impl ToUInt for Const<846> {
+        type Output = U846;
+    }
+
+    
+    impl ToUInt for Const<847> {
+        type Output = U847;
+    }
+
+    
+    impl ToUInt for Const<848> {
+        type Output = U848;
+    }
+
+    
+    impl ToUInt for Const<849> {
+        type Output = U849;
+    }
+
+    
+    impl ToUInt for Const<850> {
+        type Output = U850;
+    }
+
+    
+    impl ToUInt for Const<851> {
+        type Output = U851;
+    }
+
+    
+    impl ToUInt for Const<852> {
+        type Output = U852;
+    }
+
+    
+    impl ToUInt for Const<853> {
+        type Output = U853;
+    }
+
+    
+    impl ToUInt for Const<854> {
+        type Output = U854;
+    }
+
+    
+    impl ToUInt for Const<855> {
+        type Output = U855;
+    }
+
+    
+    impl ToUInt for Const<856> {
+        type Output = U856;
+    }
+
+    
+    impl ToUInt for Const<857> {
+        type Output = U857;
+    }
+
+    
+    impl ToUInt for Const<858> {
+        type Output = U858;
+    }
+
+    
+    impl ToUInt for Const<859> {
+        type Output = U859;
+    }
+
+    
+    impl ToUInt for Const<860> {
+        type Output = U860;
+    }
+
+    
+    impl ToUInt for Const<861> {
+        type Output = U861;
+    }
+
+    
+    impl ToUInt for Const<862> {
+        type Output = U862;
+    }
+
+    
+    impl ToUInt for Const<863> {
+        type Output = U863;
+    }
+
+    
+    impl ToUInt for Const<864> {
+        type Output = U864;
+    }
+
+    
+    impl ToUInt for Const<865> {
+        type Output = U865;
+    }
+
+    
+    impl ToUInt for Const<866> {
+        type Output = U866;
+    }
+
+    
+    impl ToUInt for Const<867> {
+        type Output = U867;
+    }
+
+    
+    impl ToUInt for Const<868> {
+        type Output = U868;
+    }
+
+    
+    impl ToUInt for Const<869> {
+        type Output = U869;
+    }
+
+    
+    impl ToUInt for Const<870> {
+        type Output = U870;
+    }
+
+    
+    impl ToUInt for Const<871> {
+        type Output = U871;
+    }
+
+    
+    impl ToUInt for Const<872> {
+        type Output = U872;
+    }
+
+    
+    impl ToUInt for Const<873> {
+        type Output = U873;
+    }
+
+    
+    impl ToUInt for Const<874> {
+        type Output = U874;
+    }
+
+    
+    impl ToUInt for Const<875> {
+        type Output = U875;
+    }
+
+    
+    impl ToUInt for Const<876> {
+        type Output = U876;
+    }
+
+    
+    impl ToUInt for Const<877> {
+        type Output = U877;
+    }
+
+    
+    impl ToUInt for Const<878> {
+        type Output = U878;
+    }
+
+    
+    impl ToUInt for Const<879> {
+        type Output = U879;
+    }
+
+    
+    impl ToUInt for Const<880> {
+        type Output = U880;
+    }
+
+    
+    impl ToUInt for Const<881> {
+        type Output = U881;
+    }
+
+    
+    impl ToUInt for Const<882> {
+        type Output = U882;
+    }
+
+    
+    impl ToUInt for Const<883> {
+        type Output = U883;
+    }
+
+    
+    impl ToUInt for Const<884> {
+        type Output = U884;
+    }
+
+    
+    impl ToUInt for Const<885> {
+        type Output = U885;
+    }
+
+    
+    impl ToUInt for Const<886> {
+        type Output = U886;
+    }
+
+    
+    impl ToUInt for Const<887> {
+        type Output = U887;
+    }
+
+    
+    impl ToUInt for Const<888> {
+        type Output = U888;
+    }
+
+    
+    impl ToUInt for Const<889> {
+        type Output = U889;
+    }
+
+    
+    impl ToUInt for Const<890> {
+        type Output = U890;
+    }
+
+    
+    impl ToUInt for Const<891> {
+        type Output = U891;
+    }
+
+    
+    impl ToUInt for Const<892> {
+        type Output = U892;
+    }
+
+    
+    impl ToUInt for Const<893> {
+        type Output = U893;
+    }
+
+    
+    impl ToUInt for Const<894> {
+        type Output = U894;
+    }
+
+    
+    impl ToUInt for Const<895> {
+        type Output = U895;
+    }
+
+    
+    impl ToUInt for Const<896> {
+        type Output = U896;
+    }
+
+    
+    impl ToUInt for Const<897> {
+        type Output = U897;
+    }
+
+    
+    impl ToUInt for Const<898> {
+        type Output = U898;
+    }
+
+    
+    impl ToUInt for Const<899> {
+        type Output = U899;
+    }
+
+    
+    impl ToUInt for Const<900> {
+        type Output = U900;
+    }
+
+    
+    impl ToUInt for Const<901> {
+        type Output = U901;
+    }
+
+    
+    impl ToUInt for Const<902> {
+        type Output = U902;
+    }
+
+    
+    impl ToUInt for Const<903> {
+        type Output = U903;
+    }
+
+    
+    impl ToUInt for Const<904> {
+        type Output = U904;
+    }
+
+    
+    impl ToUInt for Const<905> {
+        type Output = U905;
+    }
+
+    
+    impl ToUInt for Const<906> {
+        type Output = U906;
+    }
+
+    
+    impl ToUInt for Const<907> {
+        type Output = U907;
+    }
+
+    
+    impl ToUInt for Const<908> {
+        type Output = U908;
+    }
+
+    
+    impl ToUInt for Const<909> {
+        type Output = U909;
+    }
+
+    
+    impl ToUInt for Const<910> {
+        type Output = U910;
+    }
+
+    
+    impl ToUInt for Const<911> {
+        type Output = U911;
+    }
+
+    
+    impl ToUInt for Const<912> {
+        type Output = U912;
+    }
+
+    
+    impl ToUInt for Const<913> {
+        type Output = U913;
+    }
+
+    
+    impl ToUInt for Const<914> {
+        type Output = U914;
+    }
+
+    
+    impl ToUInt for Const<915> {
+        type Output = U915;
+    }
+
+    
+    impl ToUInt for Const<916> {
+        type Output = U916;
+    }
+
+    
+    impl ToUInt for Const<917> {
+        type Output = U917;
+    }
+
+    
+    impl ToUInt for Const<918> {
+        type Output = U918;
+    }
+
+    
+    impl ToUInt for Const<919> {
+        type Output = U919;
+    }
+
+    
+    impl ToUInt for Const<920> {
+        type Output = U920;
+    }
+
+    
+    impl ToUInt for Const<921> {
+        type Output = U921;
+    }
+
+    
+    impl ToUInt for Const<922> {
+        type Output = U922;
+    }
+
+    
+    impl ToUInt for Const<923> {
+        type Output = U923;
+    }
+
+    
+    impl ToUInt for Const<924> {
+        type Output = U924;
+    }
+
+    
+    impl ToUInt for Const<925> {
+        type Output = U925;
+    }
+
+    
+    impl ToUInt for Const<926> {
+        type Output = U926;
+    }
+
+    
+    impl ToUInt for Const<927> {
+        type Output = U927;
+    }
+
+    
+    impl ToUInt for Const<928> {
+        type Output = U928;
+    }
+
+    
+    impl ToUInt for Const<929> {
+        type Output = U929;
+    }
+
+    
+    impl ToUInt for Const<930> {
+        type Output = U930;
+    }
+
+    
+    impl ToUInt for Const<931> {
+        type Output = U931;
+    }
+
+    
+    impl ToUInt for Const<932> {
+        type Output = U932;
+    }
+
+    
+    impl ToUInt for Const<933> {
+        type Output = U933;
+    }
+
+    
+    impl ToUInt for Const<934> {
+        type Output = U934;
+    }
+
+    
+    impl ToUInt for Const<935> {
+        type Output = U935;
+    }
+
+    
+    impl ToUInt for Const<936> {
+        type Output = U936;
+    }
+
+    
+    impl ToUInt for Const<937> {
+        type Output = U937;
+    }
+
+    
+    impl ToUInt for Const<938> {
+        type Output = U938;
+    }
+
+    
+    impl ToUInt for Const<939> {
+        type Output = U939;
+    }
+
+    
+    impl ToUInt for Const<940> {
+        type Output = U940;
+    }
+
+    
+    impl ToUInt for Const<941> {
+        type Output = U941;
+    }
+
+    
+    impl ToUInt for Const<942> {
+        type Output = U942;
+    }
+
+    
+    impl ToUInt for Const<943> {
+        type Output = U943;
+    }
+
+    
+    impl ToUInt for Const<944> {
+        type Output = U944;
+    }
+
+    
+    impl ToUInt for Const<945> {
+        type Output = U945;
+    }
+
+    
+    impl ToUInt for Const<946> {
+        type Output = U946;
+    }
+
+    
+    impl ToUInt for Const<947> {
+        type Output = U947;
+    }
+
+    
+    impl ToUInt for Const<948> {
+        type Output = U948;
+    }
+
+    
+    impl ToUInt for Const<949> {
+        type Output = U949;
+    }
+
+    
+    impl ToUInt for Const<950> {
+        type Output = U950;
+    }
+
+    
+    impl ToUInt for Const<951> {
+        type Output = U951;
+    }
+
+    
+    impl ToUInt for Const<952> {
+        type Output = U952;
+    }
+
+    
+    impl ToUInt for Const<953> {
+        type Output = U953;
+    }
+
+    
+    impl ToUInt for Const<954> {
+        type Output = U954;
+    }
+
+    
+    impl ToUInt for Const<955> {
+        type Output = U955;
+    }
+
+    
+    impl ToUInt for Const<956> {
+        type Output = U956;
+    }
+
+    
+    impl ToUInt for Const<957> {
+        type Output = U957;
+    }
+
+    
+    impl ToUInt for Const<958> {
+        type Output = U958;
+    }
+
+    
+    impl ToUInt for Const<959> {
+        type Output = U959;
+    }
+
+    
+    impl ToUInt for Const<960> {
+        type Output = U960;
+    }
+
+    
+    impl ToUInt for Const<961> {
+        type Output = U961;
+    }
+
+    
+    impl ToUInt for Const<962> {
+        type Output = U962;
+    }
+
+    
+    impl ToUInt for Const<963> {
+        type Output = U963;
+    }
+
+    
+    impl ToUInt for Const<964> {
+        type Output = U964;
+    }
+
+    
+    impl ToUInt for Const<965> {
+        type Output = U965;
+    }
+
+    
+    impl ToUInt for Const<966> {
+        type Output = U966;
+    }
+
+    
+    impl ToUInt for Const<967> {
+        type Output = U967;
+    }
+
+    
+    impl ToUInt for Const<968> {
+        type Output = U968;
+    }
+
+    
+    impl ToUInt for Const<969> {
+        type Output = U969;
+    }
+
+    
+    impl ToUInt for Const<970> {
+        type Output = U970;
+    }
+
+    
+    impl ToUInt for Const<971> {
+        type Output = U971;
+    }
+
+    
+    impl ToUInt for Const<972> {
+        type Output = U972;
+    }
+
+    
+    impl ToUInt for Const<973> {
+        type Output = U973;
+    }
+
+    
+    impl ToUInt for Const<974> {
+        type Output = U974;
+    }
+
+    
+    impl ToUInt for Const<975> {
+        type Output = U975;
+    }
+
+    
+    impl ToUInt for Const<976> {
+        type Output = U976;
+    }
+
+    
+    impl ToUInt for Const<977> {
+        type Output = U977;
+    }
+
+    
+    impl ToUInt for Const<978> {
+        type Output = U978;
+    }
+
+    
+    impl ToUInt for Const<979> {
+        type Output = U979;
+    }
+
+    
+    impl ToUInt for Const<980> {
+        type Output = U980;
+    }
+
+    
+    impl ToUInt for Const<981> {
+        type Output = U981;
+    }
+
+    
+    impl ToUInt for Const<982> {
+        type Output = U982;
+    }
+
+    
+    impl ToUInt for Const<983> {
+        type Output = U983;
+    }
+
+    
+    impl ToUInt for Const<984> {
+        type Output = U984;
+    }
+
+    
+    impl ToUInt for Const<985> {
+        type Output = U985;
+    }
+
+    
+    impl ToUInt for Const<986> {
+        type Output = U986;
+    }
+
+    
+    impl ToUInt for Const<987> {
+        type Output = U987;
+    }
+
+    
+    impl ToUInt for Const<988> {
+        type Output = U988;
+    }
+
+    
+    impl ToUInt for Const<989> {
+        type Output = U989;
+    }
+
+    
+    impl ToUInt for Const<990> {
+        type Output = U990;
+    }
+
+    
+    impl ToUInt for Const<991> {
+        type Output = U991;
+    }
+
+    
+    impl ToUInt for Const<992> {
+        type Output = U992;
+    }
+
+    
+    impl ToUInt for Const<993> {
+        type Output = U993;
+    }
+
+    
+    impl ToUInt for Const<994> {
+        type Output = U994;
+    }
+
+    
+    impl ToUInt for Const<995> {
+        type Output = U995;
+    }
+
+    
+    impl ToUInt for Const<996> {
+        type Output = U996;
+    }
+
+    
+    impl ToUInt for Const<997> {
+        type Output = U997;
+    }
+
+    
+    impl ToUInt for Const<998> {
+        type Output = U998;
+    }
+
+    
+    impl ToUInt for Const<999> {
+        type Output = U999;
+    }
+
+    
+    impl ToUInt for Const<1000> {
+        type Output = U1000;
+    }
+
+    
+    impl ToUInt for Const<1001> {
+        type Output = U1001;
+    }
+
+    
+    impl ToUInt for Const<1002> {
+        type Output = U1002;
+    }
+
+    
+    impl ToUInt for Const<1003> {
+        type Output = U1003;
+    }
+
+    
+    impl ToUInt for Const<1004> {
+        type Output = U1004;
+    }
+
+    
+    impl ToUInt for Const<1005> {
+        type Output = U1005;
+    }
+
+    
+    impl ToUInt for Const<1006> {
+        type Output = U1006;
+    }
+
+    
+    impl ToUInt for Const<1007> {
+        type Output = U1007;
+    }
+
+    
+    impl ToUInt for Const<1008> {
+        type Output = U1008;
+    }
+
+    
+    impl ToUInt for Const<1009> {
+        type Output = U1009;
+    }
+
+    
+    impl ToUInt for Const<1010> {
+        type Output = U1010;
+    }
+
+    
+    impl ToUInt for Const<1011> {
+        type Output = U1011;
+    }
+
+    
+    impl ToUInt for Const<1012> {
+        type Output = U1012;
+    }
+
+    
+    impl ToUInt for Const<1013> {
+        type Output = U1013;
+    }
+
+    
+    impl ToUInt for Const<1014> {
+        type Output = U1014;
+    }
+
+    
+    impl ToUInt for Const<1015> {
+        type Output = U1015;
+    }
+
+    
+    impl ToUInt for Const<1016> {
+        type Output = U1016;
+    }
+
+    
+    impl ToUInt for Const<1017> {
+        type Output = U1017;
+    }
+
+    
+    impl ToUInt for Const<1018> {
+        type Output = U1018;
+    }
+
+    
+    impl ToUInt for Const<1019> {
+        type Output = U1019;
+    }
+
+    
+    impl ToUInt for Const<1020> {
+        type Output = U1020;
+    }
+
+    
+    impl ToUInt for Const<1021> {
+        type Output = U1021;
+    }
+
+    
+    impl ToUInt for Const<1022> {
+        type Output = U1022;
+    }
+
+    
+    impl ToUInt for Const<1023> {
+        type Output = U1023;
+    }
+
+    
+    impl ToUInt for Const<1024> {
+        type Output = U1024;
+    }
+
+    
+    impl ToUInt for Const<2048> {
+        type Output = U2048;
+    }
+
+    
+    impl ToUInt for Const<4096> {
+        type Output = U4096;
+    }
+
+    
+    impl ToUInt for Const<8192> {
+        type Output = U8192;
+    }
+
+    
+    impl ToUInt for Const<16384> {
+        type Output = U16384;
+    }
+
+    
+    impl ToUInt for Const<32768> {
+        type Output = U32768;
+    }
+
+    
+    impl ToUInt for Const<65536> {
+        type Output = U65536;
+    }
+
+    
+    impl ToUInt for Const<131072> {
+        type Output = U131072;
+    }
+
+    
+    impl ToUInt for Const<262144> {
+        type Output = U262144;
+    }
+
+    
+    impl ToUInt for Const<524288> {
+        type Output = U524288;
+    }
+
+    
+    impl ToUInt for Const<1048576> {
+        type Output = U1048576;
+    }
+
+    
+    impl ToUInt for Const<2097152> {
+        type Output = U2097152;
+    }
+
+    
+    impl ToUInt for Const<4194304> {
+        type Output = U4194304;
+    }
+
+    
+    impl ToUInt for Const<8388608> {
+        type Output = U8388608;
+    }
+
+    
+    impl ToUInt for Const<16777216> {
+        type Output = U16777216;
+    }
+
+    
+    impl ToUInt for Const<33554432> {
+        type Output = U33554432;
+    }
+
+    
+    impl ToUInt for Const<67108864> {
+        type Output = U67108864;
+    }
+
+    
+    impl ToUInt for Const<134217728> {
+        type Output = U134217728;
+    }
+
+    
+    impl ToUInt for Const<268435456> {
+        type Output = U268435456;
+    }
+
+    
+    impl ToUInt for Const<536870912> {
+        type Output = U536870912;
+    }
+
+    
+    impl ToUInt for Const<1073741824> {
+        type Output = U1073741824;
+    }
+
+    
+    impl ToUInt for Const<2147483648> {
+        type Output = U2147483648;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<4294967296> {
+        type Output = U4294967296;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<8589934592> {
+        type Output = U8589934592;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<17179869184> {
+        type Output = U17179869184;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<34359738368> {
+        type Output = U34359738368;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<68719476736> {
+        type Output = U68719476736;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<137438953472> {
+        type Output = U137438953472;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<274877906944> {
+        type Output = U274877906944;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<549755813888> {
+        type Output = U549755813888;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<1099511627776> {
+        type Output = U1099511627776;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<2199023255552> {
+        type Output = U2199023255552;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<4398046511104> {
+        type Output = U4398046511104;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<8796093022208> {
+        type Output = U8796093022208;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<17592186044416> {
+        type Output = U17592186044416;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<35184372088832> {
+        type Output = U35184372088832;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<70368744177664> {
+        type Output = U70368744177664;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<140737488355328> {
+        type Output = U140737488355328;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<281474976710656> {
+        type Output = U281474976710656;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<562949953421312> {
+        type Output = U562949953421312;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<1125899906842624> {
+        type Output = U1125899906842624;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<2251799813685248> {
+        type Output = U2251799813685248;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<4503599627370496> {
+        type Output = U4503599627370496;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<9007199254740992> {
+        type Output = U9007199254740992;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<18014398509481984> {
+        type Output = U18014398509481984;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<36028797018963968> {
+        type Output = U36028797018963968;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<72057594037927936> {
+        type Output = U72057594037927936;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<144115188075855872> {
+        type Output = U144115188075855872;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<288230376151711744> {
+        type Output = U288230376151711744;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<576460752303423488> {
+        type Output = U576460752303423488;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<1152921504606846976> {
+        type Output = U1152921504606846976;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<2305843009213693952> {
+        type Output = U2305843009213693952;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<4611686018427387904> {
+        type Output = U4611686018427387904;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<9223372036854775808> {
+        type Output = U9223372036854775808;
+    }
+
+    
+    impl ToUInt for Const<10000> {
+        type Output = U10000;
+    }
+
+    
+    impl ToUInt for Const<100000> {
+        type Output = U100000;
+    }
+
+    
+    impl ToUInt for Const<1000000> {
+        type Output = U1000000;
+    }
+
+    
+    impl ToUInt for Const<10000000> {
+        type Output = U10000000;
+    }
+
+    
+    impl ToUInt for Const<100000000> {
+        type Output = U100000000;
+    }
+
+    
+    impl ToUInt for Const<1000000000> {
+        type Output = U1000000000;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<10000000000> {
+        type Output = U10000000000;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<100000000000> {
+        type Output = U100000000000;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<1000000000000> {
+        type Output = U1000000000000;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<10000000000000> {
+        type Output = U10000000000000;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<100000000000000> {
+        type Output = U100000000000000;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<1000000000000000> {
+        type Output = U1000000000000000;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<10000000000000000> {
+        type Output = U10000000000000000;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<100000000000000000> {
+        type Output = U100000000000000000;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<1000000000000000000> {
+        type Output = U1000000000000000000;
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    impl ToUInt for Const<10000000000000000000> {
+        type Output = U10000000000000000000;
+    }
+}
\ No newline at end of file
diff --git a/src/lib.rs b/src/lib.rs
index 49fb4bf..5d480d1 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -68,12 +68,19 @@
 
 use core::cmp::Ordering;
 
+#[path = "consts.rs"]
+mod consts_mod;
+mod op;
+#[cfg(feature = "const-generics")]
+#[path = "generic_const_mappings.rs"]
+mod generic_const_mappings_mod;
+
 mod generated {
-    include!(concat!(env!("OUT_DIR"), "/op.rs"));
-    include!(concat!(env!("OUT_DIR"), "/consts.rs"));
+    pub use super::op;
+    pub use super::consts_mod::consts;
 
     #[cfg(feature = "const-generics")]
-    include!(concat!(env!("OUT_DIR"), "/generic_const_mappings.rs"));
+    pub use super::generic_const_mappings_mod::generic_const_mappings;
 }
 
 pub mod bit;
diff --git a/src/op.rs b/src/op.rs
new file mode 100644
index 0000000..ce6f3e0
--- /dev/null
+++ b/src/op.rs
@@ -0,0 +1,1030 @@
+
+/**
+Convenient type operations.
+
+Any types representing values must be able to be expressed as `ident`s. That means they need to be
+in scope.
+
+For example, `P5` is okay, but `typenum::P5` is not.
+
+You may combine operators arbitrarily, although doing so excessively may require raising the
+recursion limit.
+
+# Example
+```rust
+#![recursion_limit="128"]
+#[macro_use] extern crate typenum;
+use typenum::consts::*;
+
+fn main() {
+    assert_type!(
+        op!(min((P1 - P2) * (N3 + N7), P5 * (P3 + P4)) == P10)
+    );
+}
+```
+Operators are evaluated based on the operator precedence outlined
+[here](https://doc.rust-lang.org/reference.html#operator-precedence).
+
+The full list of supported operators and functions is as follows:
+
+`*`, `/`, `%`, `+`, `-`, `<<`, `>>`, `&`, `^`, `|`, `==`, `!=`, `<=`, `>=`, `<`, `>`, `cmp`, `sqr`, `sqrt`, `abs`, `cube`, `pow`, `min`, `max`, `log2`, `gcd`
+
+They all expand to type aliases defined in the `operator_aliases` module. Here is an expanded list,
+including examples:
+
+---
+Operator `*`. Expands to `Prod`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(P2 * P3), P6);
+# }
+```
+
+---
+Operator `/`. Expands to `Quot`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(P6 / P2), P3);
+# }
+```
+
+---
+Operator `%`. Expands to `Mod`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(P5 % P3), P2);
+# }
+```
+
+---
+Operator `+`. Expands to `Sum`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(P2 + P3), P5);
+# }
+```
+
+---
+Operator `-`. Expands to `Diff`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(P2 - P3), N1);
+# }
+```
+
+---
+Operator `<<`. Expands to `Shleft`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(U1 << U5), U32);
+# }
+```
+
+---
+Operator `>>`. Expands to `Shright`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(U32 >> U5), U1);
+# }
+```
+
+---
+Operator `&`. Expands to `And`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(U5 & U3), U1);
+# }
+```
+
+---
+Operator `^`. Expands to `Xor`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(U5 ^ U3), U6);
+# }
+```
+
+---
+Operator `|`. Expands to `Or`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(U5 | U3), U7);
+# }
+```
+
+---
+Operator `==`. Expands to `Eq`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(P5 == P3 + P2), True);
+# }
+```
+
+---
+Operator `!=`. Expands to `NotEq`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(P5 != P3 + P2), False);
+# }
+```
+
+---
+Operator `<=`. Expands to `LeEq`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(P6 <= P3 + P2), False);
+# }
+```
+
+---
+Operator `>=`. Expands to `GrEq`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(P6 >= P3 + P2), True);
+# }
+```
+
+---
+Operator `<`. Expands to `Le`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(P4 < P3 + P2), True);
+# }
+```
+
+---
+Operator `>`. Expands to `Gr`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(P5 < P3 + P2), False);
+# }
+```
+
+---
+Operator `cmp`. Expands to `Compare`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(cmp(P2, P3)), Less);
+# }
+```
+
+---
+Operator `sqr`. Expands to `Square`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(sqr(P2)), P4);
+# }
+```
+
+---
+Operator `sqrt`. Expands to `Sqrt`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(sqrt(U9)), U3);
+# }
+```
+
+---
+Operator `abs`. Expands to `AbsVal`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(abs(N2)), P2);
+# }
+```
+
+---
+Operator `cube`. Expands to `Cube`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(cube(P2)), P8);
+# }
+```
+
+---
+Operator `pow`. Expands to `Exp`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(pow(P2, P3)), P8);
+# }
+```
+
+---
+Operator `min`. Expands to `Minimum`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(min(P2, P3)), P2);
+# }
+```
+
+---
+Operator `max`. Expands to `Maximum`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(max(P2, P3)), P3);
+# }
+```
+
+---
+Operator `log2`. Expands to `Log2`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(log2(U9)), U3);
+# }
+```
+
+---
+Operator `gcd`. Expands to `Gcf`.
+
+```rust
+# #[macro_use] extern crate typenum;
+# use typenum::*;
+# fn main() {
+assert_type_eq!(op!(gcd(U9, U21)), U3);
+# }
+```
+
+*/
+#[macro_export(local_inner_macros)]
+macro_rules! op {
+    ($($tail:tt)*) => ( __op_internal__!($($tail)*) );
+}
+
+    #[doc(hidden)]
+    #[macro_export(local_inner_macros)]
+    macro_rules! __op_internal__ {
+
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: cmp $($tail:tt)*) => (
+    __op_internal__!(@stack[Compare, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: sqr $($tail:tt)*) => (
+    __op_internal__!(@stack[Square, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: sqrt $($tail:tt)*) => (
+    __op_internal__!(@stack[Sqrt, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: abs $($tail:tt)*) => (
+    __op_internal__!(@stack[AbsVal, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: cube $($tail:tt)*) => (
+    __op_internal__!(@stack[Cube, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: pow $($tail:tt)*) => (
+    __op_internal__!(@stack[Exp, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: min $($tail:tt)*) => (
+    __op_internal__!(@stack[Minimum, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: max $($tail:tt)*) => (
+    __op_internal__!(@stack[Maximum, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: log2 $($tail:tt)*) => (
+    __op_internal__!(@stack[Log2, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: gcd $($tail:tt)*) => (
+    __op_internal__!(@stack[Gcf, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[LParen, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: , $($tail:tt)*) => (
+    __op_internal__!(@stack[LParen, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[$stack_top:ident, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: , $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[$stack_top, $($queue,)*] @tail: , $($tail)*)
+);
+(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: * $($tail)*)
+);
+(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: * $($tail)*)
+);
+(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: * $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) => (
+    __op_internal__!(@stack[Prod, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: / $($tail)*)
+);
+(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: / $($tail)*)
+);
+(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: / $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) => (
+    __op_internal__!(@stack[Quot, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: % $($tail)*)
+);
+(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: % $($tail)*)
+);
+(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: % $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) => (
+    __op_internal__!(@stack[Mod, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: + $($tail)*)
+);
+(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: + $($tail)*)
+);
+(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: + $($tail)*)
+);
+(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: + $($tail)*)
+);
+(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: + $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) => (
+    __op_internal__!(@stack[Sum, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: - $($tail)*)
+);
+(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: - $($tail)*)
+);
+(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: - $($tail)*)
+);
+(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: - $($tail)*)
+);
+(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: - $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) => (
+    __op_internal__!(@stack[Diff, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: << $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: << $($tail)*)
+);
+(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: << $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: << $($tail)*)
+);
+(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: << $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: << $($tail)*)
+);
+(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: << $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: << $($tail)*)
+);
+(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: << $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: << $($tail)*)
+);
+(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: << $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: << $($tail)*)
+);
+(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: << $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: << $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: << $($tail:tt)*) => (
+    __op_internal__!(@stack[Shleft, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >> $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: >> $($tail)*)
+);
+(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >> $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: >> $($tail)*)
+);
+(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >> $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: >> $($tail)*)
+);
+(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >> $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: >> $($tail)*)
+);
+(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >> $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: >> $($tail)*)
+);
+(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >> $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: >> $($tail)*)
+);
+(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >> $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: >> $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >> $($tail:tt)*) => (
+    __op_internal__!(@stack[Shright, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: & $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: & $($tail)*)
+);
+(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: & $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: & $($tail)*)
+);
+(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: & $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: & $($tail)*)
+);
+(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: & $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: & $($tail)*)
+);
+(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: & $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: & $($tail)*)
+);
+(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: & $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: & $($tail)*)
+);
+(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: & $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: & $($tail)*)
+);
+(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: & $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: & $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: & $($tail:tt)*) => (
+    __op_internal__!(@stack[And, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: ^ $($tail)*)
+);
+(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: ^ $($tail)*)
+);
+(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: ^ $($tail)*)
+);
+(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: ^ $($tail)*)
+);
+(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: ^ $($tail)*)
+);
+(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: ^ $($tail)*)
+);
+(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: ^ $($tail)*)
+);
+(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: ^ $($tail)*)
+);
+(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: ^ $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
+    __op_internal__!(@stack[Xor, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: | $($tail)*)
+);
+(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: | $($tail)*)
+);
+(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: | $($tail)*)
+);
+(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: | $($tail)*)
+);
+(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: | $($tail)*)
+);
+(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: | $($tail)*)
+);
+(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: | $($tail)*)
+);
+(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: | $($tail)*)
+);
+(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: | $($tail)*)
+);
+(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: | $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
+    __op_internal__!(@stack[Or, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: == $($tail)*)
+);
+(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: == $($tail)*)
+);
+(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: == $($tail)*)
+);
+(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: == $($tail)*)
+);
+(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: == $($tail)*)
+);
+(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: == $($tail)*)
+);
+(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: == $($tail)*)
+);
+(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: == $($tail)*)
+);
+(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: == $($tail)*)
+);
+(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: == $($tail)*)
+);
+(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: == $($tail)*)
+);
+(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: == $($tail)*)
+);
+(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: == $($tail)*)
+);
+(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: == $($tail)*)
+);
+(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: == $($tail)*)
+);
+(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: == $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
+    __op_internal__!(@stack[Eq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: != $($tail)*)
+);
+(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: != $($tail)*)
+);
+(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: != $($tail)*)
+);
+(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: != $($tail)*)
+);
+(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: != $($tail)*)
+);
+(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: != $($tail)*)
+);
+(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: != $($tail)*)
+);
+(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: != $($tail)*)
+);
+(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: != $($tail)*)
+);
+(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: != $($tail)*)
+);
+(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: != $($tail)*)
+);
+(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: != $($tail)*)
+);
+(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: != $($tail)*)
+);
+(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: != $($tail)*)
+);
+(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: != $($tail)*)
+);
+(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: != $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
+    __op_internal__!(@stack[NotEq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: <= $($tail)*)
+);
+(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: <= $($tail)*)
+);
+(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: <= $($tail)*)
+);
+(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: <= $($tail)*)
+);
+(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: <= $($tail)*)
+);
+(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: <= $($tail)*)
+);
+(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: <= $($tail)*)
+);
+(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: <= $($tail)*)
+);
+(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: <= $($tail)*)
+);
+(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: <= $($tail)*)
+);
+(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: <= $($tail)*)
+);
+(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: <= $($tail)*)
+);
+(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: <= $($tail)*)
+);
+(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: <= $($tail)*)
+);
+(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: <= $($tail)*)
+);
+(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: <= $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
+    __op_internal__!(@stack[LeEq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: >= $($tail)*)
+);
+(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: >= $($tail)*)
+);
+(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: >= $($tail)*)
+);
+(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: >= $($tail)*)
+);
+(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: >= $($tail)*)
+);
+(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: >= $($tail)*)
+);
+(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: >= $($tail)*)
+);
+(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: >= $($tail)*)
+);
+(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: >= $($tail)*)
+);
+(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: >= $($tail)*)
+);
+(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: >= $($tail)*)
+);
+(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: >= $($tail)*)
+);
+(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: >= $($tail)*)
+);
+(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: >= $($tail)*)
+);
+(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: >= $($tail)*)
+);
+(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: >= $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
+    __op_internal__!(@stack[GrEq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: < $($tail)*)
+);
+(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: < $($tail)*)
+);
+(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: < $($tail)*)
+);
+(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: < $($tail)*)
+);
+(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: < $($tail)*)
+);
+(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: < $($tail)*)
+);
+(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: < $($tail)*)
+);
+(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: < $($tail)*)
+);
+(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: < $($tail)*)
+);
+(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: < $($tail)*)
+);
+(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: < $($tail)*)
+);
+(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: < $($tail)*)
+);
+(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: < $($tail)*)
+);
+(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: < $($tail)*)
+);
+(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: < $($tail)*)
+);
+(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: < $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
+    __op_internal__!(@stack[Le, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: > $($tail)*)
+);
+(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: > $($tail)*)
+);
+(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: > $($tail)*)
+);
+(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: > $($tail)*)
+);
+(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: > $($tail)*)
+);
+(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: > $($tail)*)
+);
+(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: > $($tail)*)
+);
+(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: > $($tail)*)
+);
+(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: > $($tail)*)
+);
+(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: > $($tail)*)
+);
+(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: > $($tail)*)
+);
+(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: > $($tail)*)
+);
+(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: > $($tail)*)
+);
+(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: > $($tail)*)
+);
+(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: > $($tail)*)
+);
+(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: > $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
+    __op_internal__!(@stack[Gr, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ( $($stuff:tt)* ) $($tail:tt)* )
+ => (
+    __op_internal__!(@stack[LParen, $($stack,)*] @queue[$($queue,)*]
+                     @tail: $($stuff)* RParen $($tail)*)
+);
+(@stack[LParen, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: RParen $($tail:tt)*) => (
+    __op_internal__!(@rp3 @stack[$($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[$stack_top:ident, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: RParen $($tail:tt)*)
+ => (
+    __op_internal__!(@stack[$($stack,)*] @queue[$stack_top, $($queue,)*] @tail: RParen $($tail)*)
+);
+(@rp3 @stack[Compare, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Compare, $($queue,)*] @tail: $($tail)*)
+);
+(@rp3 @stack[Square, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Square, $($queue,)*] @tail: $($tail)*)
+);
+(@rp3 @stack[Sqrt, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Sqrt, $($queue,)*] @tail: $($tail)*)
+);
+(@rp3 @stack[AbsVal, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[AbsVal, $($queue,)*] @tail: $($tail)*)
+);
+(@rp3 @stack[Cube, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Cube, $($queue,)*] @tail: $($tail)*)
+);
+(@rp3 @stack[Exp, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Exp, $($queue,)*] @tail: $($tail)*)
+);
+(@rp3 @stack[Minimum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Minimum, $($queue,)*] @tail: $($tail)*)
+);
+(@rp3 @stack[Maximum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Maximum, $($queue,)*] @tail: $($tail)*)
+);
+(@rp3 @stack[Log2, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Log2, $($queue,)*] @tail: $($tail)*)
+);
+(@rp3 @stack[Gcf, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[Gcf, $($queue,)*] @tail: $($tail)*)
+);
+(@rp3 @stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
+);
+(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $num:ident $($tail:tt)*) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[$num, $($queue,)*] @tail: $($tail)*)
+);
+(@stack[] @queue[$($queue:ident,)*] @tail: ) => (
+    __op_internal__!(@reverse[] @input: $($queue,)*)
+);
+(@stack[$stack_top:ident, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail:) => (
+    __op_internal__!(@stack[$($stack,)*] @queue[$stack_top, $($queue,)*] @tail: )
+);
+(@reverse[$($revved:ident,)*] @input: $head:ident, $($tail:ident,)* ) => (
+    __op_internal__!(@reverse[$head, $($revved,)*] @input: $($tail,)*)
+);
+(@reverse[$($revved:ident,)*] @input: ) => (
+    __op_internal__!(@eval @stack[] @input[$($revved,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Prod, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Prod<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Quot, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Quot<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Mod, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Mod<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Sum, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Sum<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Diff, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Diff<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Shleft, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Shleft<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Shright, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Shright<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[And, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::And<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Xor, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Xor<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Or, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Or<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Eq, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Eq<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[NotEq, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::NotEq<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[LeEq, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::LeEq<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[GrEq, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::GrEq<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Le, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Le<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Gr, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Gr<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Compare, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Compare<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Exp, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Exp<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Minimum, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Minimum<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Maximum, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Maximum<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Gcf, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Gcf<$b, $a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $($stack:ty,)*] @input[Square, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Square<$a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $($stack:ty,)*] @input[Sqrt, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Sqrt<$a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $($stack:ty,)*] @input[AbsVal, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::AbsVal<$a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $($stack:ty,)*] @input[Cube, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Cube<$a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$a:ty, $($stack:ty,)*] @input[Log2, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$crate::Log2<$a>, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$($stack:ty,)*] @input[$head:ident, $($tail:ident,)*]) => (
+    __op_internal__!(@eval @stack[$head, $($stack,)*] @input[$($tail,)*])
+);
+(@eval @stack[$stack:ty,] @input[]) => (
+    $stack
+);
+($($tail:tt)* ) => (
+    __op_internal__!(@stack[] @queue[] @tail: $($tail)*)
+);
+}
\ No newline at end of file
diff --git a/src/tests.rs b/src/tests.rs
new file mode 100644
index 0000000..12616c0
--- /dev/null
+++ b/src/tests.rs
@@ -0,0 +1,20565 @@
+
+extern crate typenum;
+
+use std::ops::*;
+use std::cmp::Ordering;
+use typenum::*;
+
+#[test]
+#[allow(non_snake_case)]
+fn test_0_BitAnd_0() {
+    type A = UTerm;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_BitOr_0() {
+    type A = UTerm;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0BitOrU0 = <<A as BitOr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0BitOrU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_BitXor_0() {
+    type A = UTerm;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0BitXorU0 = <<A as BitXor<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0BitXorU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Shl_0() {
+    type A = UTerm;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0ShlU0 = <<A as Shl<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0ShlU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Shr_0() {
+    type A = UTerm;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0ShrU0 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0ShrU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Add_0() {
+    type A = UTerm;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0AddU0 = <<A as Add<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0AddU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Min_0() {
+    type A = UTerm;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Max_0() {
+    type A = UTerm;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0MaxU0 = <<A as Max<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0MaxU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Gcd_0() {
+    type A = UTerm;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0GcdU0 = <<A as Gcd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0GcdU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Sub_0() {
+    type A = UTerm;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0SubU0 = <<A as Sub<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0SubU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Mul_0() {
+    type A = UTerm;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Pow_0() {
+    type A = UTerm;
+    type B = UTerm;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U0PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Cmp_0() {
+    type A = UTerm;
+    type B = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0CmpU0 = <A as Cmp<B>>::Output;
+    assert_eq!(<U0CmpU0 as Ord>::to_ordering(), Ordering::Equal);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_BitAnd_1() {
+    type A = UTerm;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0BitAndU1 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0BitAndU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_BitOr_1() {
+    type A = UTerm;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0BitOrU1 = <<A as BitOr<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U0BitOrU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_BitXor_1() {
+    type A = UTerm;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0BitXorU1 = <<A as BitXor<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U0BitXorU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Shl_1() {
+    type A = UTerm;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0ShlU1 = <<A as Shl<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0ShlU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Shr_1() {
+    type A = UTerm;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0ShrU1 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0ShrU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Add_1() {
+    type A = UTerm;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0AddU1 = <<A as Add<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U0AddU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Min_1() {
+    type A = UTerm;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0MinU1 = <<A as Min<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0MinU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Max_1() {
+    type A = UTerm;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0MaxU1 = <<A as Max<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U0MaxU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Gcd_1() {
+    type A = UTerm;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U0GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Mul_1() {
+    type A = UTerm;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0MulU1 = <<A as Mul<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0MulU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Div_1() {
+    type A = UTerm;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0DivU1 = <<A as Div<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0DivU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Rem_1() {
+    type A = UTerm;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_PartialDiv_1() {
+    type A = UTerm;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0PartialDivU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Pow_1() {
+    type A = UTerm;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0PowU1 = <<A as Pow<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0PowU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Cmp_1() {
+    type A = UTerm;
+    type B = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0CmpU1 = <A as Cmp<B>>::Output;
+    assert_eq!(<U0CmpU1 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_BitAnd_2() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0BitAndU2 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0BitAndU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_BitOr_2() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U0BitOrU2 = <<A as BitOr<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U0BitOrU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_BitXor_2() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U0BitXorU2 = <<A as BitXor<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U0BitXorU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Shl_2() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0ShlU2 = <<A as Shl<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0ShlU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Shr_2() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0ShrU2 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0ShrU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Add_2() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U0AddU2 = <<A as Add<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U0AddU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Min_2() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0MinU2 = <<A as Min<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0MinU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Max_2() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U0MaxU2 = <<A as Max<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U0MaxU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Gcd_2() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U0GcdU2 = <<A as Gcd<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U0GcdU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Mul_2() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0MulU2 = <<A as Mul<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0MulU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Div_2() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0DivU2 = <<A as Div<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0DivU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Rem_2() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0RemU2 = <<A as Rem<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0RemU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_PartialDiv_2() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0PartialDivU2 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0PartialDivU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Pow_2() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0PowU2 = <<A as Pow<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0PowU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Cmp_2() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U0CmpU2 = <A as Cmp<B>>::Output;
+    assert_eq!(<U0CmpU2 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_BitAnd_3() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0BitAndU3 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0BitAndU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_BitOr_3() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0BitOrU3 = <<A as BitOr<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U0BitOrU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_BitXor_3() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0BitXorU3 = <<A as BitXor<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U0BitXorU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Shl_3() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0ShlU3 = <<A as Shl<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0ShlU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Shr_3() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Add_3() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0AddU3 = <<A as Add<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U0AddU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Min_3() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0MinU3 = <<A as Min<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0MinU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Max_3() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0MaxU3 = <<A as Max<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U0MaxU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Gcd_3() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0GcdU3 = <<A as Gcd<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U0GcdU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Mul_3() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0MulU3 = <<A as Mul<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0MulU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Div_3() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0DivU3 = <<A as Div<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0DivU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Rem_3() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0RemU3 = <<A as Rem<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0RemU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_PartialDiv_3() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0PartialDivU3 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0PartialDivU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Pow_3() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0PowU3 = <<A as Pow<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0PowU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Cmp_3() {
+    type A = UTerm;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0CmpU3 = <A as Cmp<B>>::Output;
+    assert_eq!(<U0CmpU3 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_BitAnd_4() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0BitAndU4 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0BitAndU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_BitOr_4() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U0BitOrU4 = <<A as BitOr<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U0BitOrU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_BitXor_4() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U0BitXorU4 = <<A as BitXor<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U0BitXorU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Shl_4() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0ShlU4 = <<A as Shl<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0ShlU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Shr_4() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Add_4() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U0AddU4 = <<A as Add<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U0AddU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Min_4() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0MinU4 = <<A as Min<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0MinU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Max_4() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U0MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U0MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Gcd_4() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U0GcdU4 = <<A as Gcd<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U0GcdU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Mul_4() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0MulU4 = <<A as Mul<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0MulU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Div_4() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0DivU4 = <<A as Div<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0DivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Rem_4() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0RemU4 = <<A as Rem<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0RemU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_PartialDiv_4() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0PartialDivU4 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0PartialDivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Pow_4() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0PowU4 = <<A as Pow<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0PowU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Cmp_4() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U0CmpU4 = <A as Cmp<B>>::Output;
+    assert_eq!(<U0CmpU4 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_BitAnd_5() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0BitAndU5 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0BitAndU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_BitOr_5() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0BitOrU5 = <<A as BitOr<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U0BitOrU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_BitXor_5() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0BitXorU5 = <<A as BitXor<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U0BitXorU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Shl_5() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0ShlU5 = <<A as Shl<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0ShlU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Shr_5() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Add_5() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0AddU5 = <<A as Add<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U0AddU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Min_5() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0MinU5 = <<A as Min<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0MinU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Max_5() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U0MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Gcd_5() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0GcdU5 = <<A as Gcd<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U0GcdU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Mul_5() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0MulU5 = <<A as Mul<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0MulU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Div_5() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Rem_5() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0RemU5 = <<A as Rem<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0RemU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_PartialDiv_5() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0PartialDivU5 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0PartialDivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Pow_5() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U0PowU5 = <<A as Pow<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U0PowU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_0_Cmp_5() {
+    type A = UTerm;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U0CmpU5 = <A as Cmp<B>>::Output;
+    assert_eq!(<U0CmpU5 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_BitAnd_0() {
+    type A = UInt<UTerm, B1>;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U1BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U1BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_BitOr_0() {
+    type A = UInt<UTerm, B1>;
+    type B = UTerm;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1BitOrU0 = <<A as BitOr<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1BitOrU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_BitXor_0() {
+    type A = UInt<UTerm, B1>;
+    type B = UTerm;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1BitXorU0 = <<A as BitXor<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1BitXorU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Shl_0() {
+    type A = UInt<UTerm, B1>;
+    type B = UTerm;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1ShlU0 = <<A as Shl<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1ShlU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Shr_0() {
+    type A = UInt<UTerm, B1>;
+    type B = UTerm;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1ShrU0 = <<A as Shr<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1ShrU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Add_0() {
+    type A = UInt<UTerm, B1>;
+    type B = UTerm;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1AddU0 = <<A as Add<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1AddU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Min_0() {
+    type A = UInt<UTerm, B1>;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U1MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U1MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Max_0() {
+    type A = UInt<UTerm, B1>;
+    type B = UTerm;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1MaxU0 = <<A as Max<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1MaxU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Gcd_0() {
+    type A = UInt<UTerm, B1>;
+    type B = UTerm;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1GcdU0 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1GcdU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Sub_0() {
+    type A = UInt<UTerm, B1>;
+    type B = UTerm;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1SubU0 = <<A as Sub<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1SubU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Mul_0() {
+    type A = UInt<UTerm, B1>;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U1MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U1MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Pow_0() {
+    type A = UInt<UTerm, B1>;
+    type B = UTerm;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Cmp_0() {
+    type A = UInt<UTerm, B1>;
+    type B = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U1CmpU0 = <A as Cmp<B>>::Output;
+    assert_eq!(<U1CmpU0 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_BitAnd_1() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1BitAndU1 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1BitAndU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_BitOr_1() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1BitOrU1 = <<A as BitOr<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1BitOrU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_BitXor_1() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U1BitXorU1 = <<A as BitXor<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U1BitXorU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Shl_1() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UTerm, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U1ShlU1 = <<A as Shl<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U1ShlU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Shr_1() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U1ShrU1 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U1ShrU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Add_1() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UTerm, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U1AddU1 = <<A as Add<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U1AddU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Min_1() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Max_1() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1MaxU1 = <<A as Max<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1MaxU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Gcd_1() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Sub_1() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U1SubU1 = <<A as Sub<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U1SubU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Mul_1() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1MulU1 = <<A as Mul<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1MulU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Div_1() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1DivU1 = <<A as Div<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1DivU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Rem_1() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U1RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U1RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_PartialDiv_1() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1PartialDivU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Pow_1() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1PowU1 = <<A as Pow<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1PowU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Cmp_1() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1CmpU1 = <A as Cmp<B>>::Output;
+    assert_eq!(<U1CmpU1 as Ord>::to_ordering(), Ordering::Equal);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_BitAnd_2() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U1BitAndU2 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U1BitAndU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_BitOr_2() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1BitOrU2 = <<A as BitOr<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U1BitOrU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_BitXor_2() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1BitXorU2 = <<A as BitXor<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U1BitXorU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Shl_2() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U1ShlU2 = <<A as Shl<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U1ShlU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Shr_2() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U1ShrU2 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U1ShrU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Add_2() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1AddU2 = <<A as Add<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U1AddU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Min_2() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1MinU2 = <<A as Min<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1MinU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Max_2() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U1MaxU2 = <<A as Max<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U1MaxU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Gcd_2() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1GcdU2 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1GcdU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Mul_2() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U1MulU2 = <<A as Mul<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U1MulU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Div_2() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U1DivU2 = <<A as Div<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U1DivU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Rem_2() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1RemU2 = <<A as Rem<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1RemU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Pow_2() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1PowU2 = <<A as Pow<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1PowU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Cmp_2() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U1CmpU2 = <A as Cmp<B>>::Output;
+    assert_eq!(<U1CmpU2 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_BitAnd_3() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1BitAndU3 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1BitAndU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_BitOr_3() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1BitOrU3 = <<A as BitOr<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U1BitOrU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_BitXor_3() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U1BitXorU3 = <<A as BitXor<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U1BitXorU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Shl_3() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U1ShlU3 = <<A as Shl<B>>::Output as Same<U8>>::Output;
+
+    assert_eq!(<U1ShlU3 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Shr_3() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U1ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U1ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Add_3() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U1AddU3 = <<A as Add<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U1AddU3 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Min_3() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1MinU3 = <<A as Min<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1MinU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Max_3() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1MaxU3 = <<A as Max<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U1MaxU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Gcd_3() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1GcdU3 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1GcdU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Mul_3() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1MulU3 = <<A as Mul<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U1MulU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Div_3() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U1DivU3 = <<A as Div<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U1DivU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Rem_3() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1RemU3 = <<A as Rem<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1RemU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Pow_3() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1PowU3 = <<A as Pow<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1PowU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Cmp_3() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1CmpU3 = <A as Cmp<B>>::Output;
+    assert_eq!(<U1CmpU3 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_BitAnd_4() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U1BitAndU4 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U1BitAndU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_BitOr_4() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1BitOrU4 = <<A as BitOr<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U1BitOrU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_BitXor_4() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1BitXorU4 = <<A as BitXor<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U1BitXorU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Shl_4() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U1ShlU4 = <<A as Shl<B>>::Output as Same<U16>>::Output;
+
+    assert_eq!(<U1ShlU4 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Shr_4() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U1ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U1ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Add_4() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1AddU4 = <<A as Add<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U1AddU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Min_4() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1MinU4 = <<A as Min<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1MinU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Max_4() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U1MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U1MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Gcd_4() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1GcdU4 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1GcdU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Mul_4() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U1MulU4 = <<A as Mul<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U1MulU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Div_4() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U1DivU4 = <<A as Div<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U1DivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Rem_4() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1RemU4 = <<A as Rem<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1RemU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Pow_4() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1PowU4 = <<A as Pow<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1PowU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Cmp_4() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U1CmpU4 = <A as Cmp<B>>::Output;
+    assert_eq!(<U1CmpU4 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_BitAnd_5() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1BitAndU5 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1BitAndU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_BitOr_5() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1BitOrU5 = <<A as BitOr<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U1BitOrU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_BitXor_5() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U1BitXorU5 = <<A as BitXor<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U1BitXorU5 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Shl_5() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U32 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U1ShlU5 = <<A as Shl<B>>::Output as Same<U32>>::Output;
+
+    assert_eq!(<U1ShlU5 as Unsigned>::to_u64(), <U32 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Shr_5() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U1ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U1ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Add_5() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U1AddU5 = <<A as Add<B>>::Output as Same<U6>>::Output;
+
+    assert_eq!(<U1AddU5 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Min_5() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1MinU5 = <<A as Min<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1MinU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Max_5() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U1MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Gcd_5() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1GcdU5 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1GcdU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Mul_5() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1MulU5 = <<A as Mul<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U1MulU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Div_5() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U1DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U1DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Rem_5() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1RemU5 = <<A as Rem<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1RemU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Pow_5() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1PowU5 = <<A as Pow<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U1PowU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_1_Cmp_5() {
+    type A = UInt<UTerm, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U1CmpU5 = <A as Cmp<B>>::Output;
+    assert_eq!(<U1CmpU5 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_BitAnd_0() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U2BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U2BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_BitOr_0() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UTerm;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2BitOrU0 = <<A as BitOr<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2BitOrU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_BitXor_0() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UTerm;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2BitXorU0 = <<A as BitXor<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2BitXorU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Shl_0() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UTerm;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2ShlU0 = <<A as Shl<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2ShlU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Shr_0() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UTerm;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2ShrU0 = <<A as Shr<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2ShrU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Add_0() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UTerm;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2AddU0 = <<A as Add<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2AddU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Min_0() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U2MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U2MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Max_0() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UTerm;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2MaxU0 = <<A as Max<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2MaxU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Gcd_0() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UTerm;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2GcdU0 = <<A as Gcd<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2GcdU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Sub_0() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UTerm;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2SubU0 = <<A as Sub<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2SubU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Mul_0() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U2MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U2MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Pow_0() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UTerm;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U2PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Cmp_0() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U2CmpU0 = <A as Cmp<B>>::Output;
+    assert_eq!(<U2CmpU0 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_BitAnd_1() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U2BitAndU1 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U2BitAndU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_BitOr_1() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2BitOrU1 = <<A as BitOr<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U2BitOrU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_BitXor_1() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2BitXorU1 = <<A as BitXor<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U2BitXorU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Shl_1() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2ShlU1 = <<A as Shl<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U2ShlU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Shr_1() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2ShrU1 = <<A as Shr<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U2ShrU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Add_1() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2AddU1 = <<A as Add<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U2AddU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Min_1() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U2MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Max_1() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2MaxU1 = <<A as Max<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2MaxU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Gcd_1() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U2GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Sub_1() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2SubU1 = <<A as Sub<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U2SubU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Mul_1() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2MulU1 = <<A as Mul<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2MulU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Div_1() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2DivU1 = <<A as Div<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2DivU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Rem_1() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U2RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U2RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_PartialDiv_1() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2PartialDivU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Pow_1() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2PowU1 = <<A as Pow<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2PowU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Cmp_1() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2CmpU1 = <A as Cmp<B>>::Output;
+    assert_eq!(<U2CmpU1 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_BitAnd_2() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2BitAndU2 = <<A as BitAnd<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2BitAndU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_BitOr_2() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2BitOrU2 = <<A as BitOr<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2BitOrU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_BitXor_2() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U2BitXorU2 = <<A as BitXor<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U2BitXorU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Shl_2() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2ShlU2 = <<A as Shl<B>>::Output as Same<U8>>::Output;
+
+    assert_eq!(<U2ShlU2 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Shr_2() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U2ShrU2 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U2ShrU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Add_2() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2AddU2 = <<A as Add<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U2AddU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Min_2() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2MinU2 = <<A as Min<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2MinU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Max_2() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2MaxU2 = <<A as Max<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2MaxU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Gcd_2() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2GcdU2 = <<A as Gcd<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2GcdU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Sub_2() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U2SubU2 = <<A as Sub<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U2SubU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Mul_2() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2MulU2 = <<A as Mul<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U2MulU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Div_2() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2DivU2 = <<A as Div<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U2DivU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Rem_2() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U2RemU2 = <<A as Rem<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U2RemU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_PartialDiv_2() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2PartialDivU2 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U2PartialDivU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Pow_2() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2PowU2 = <<A as Pow<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U2PowU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Cmp_2() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2CmpU2 = <A as Cmp<B>>::Output;
+    assert_eq!(<U2CmpU2 as Ord>::to_ordering(), Ordering::Equal);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_BitAnd_3() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2BitAndU3 = <<A as BitAnd<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2BitAndU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_BitOr_3() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2BitOrU3 = <<A as BitOr<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U2BitOrU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_BitXor_3() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2BitXorU3 = <<A as BitXor<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U2BitXorU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Shl_3() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2ShlU3 = <<A as Shl<B>>::Output as Same<U16>>::Output;
+
+    assert_eq!(<U2ShlU3 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Shr_3() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U2ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U2ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Add_3() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2AddU3 = <<A as Add<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U2AddU3 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Min_3() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2MinU3 = <<A as Min<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2MinU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Max_3() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2MaxU3 = <<A as Max<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U2MaxU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Gcd_3() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2GcdU3 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U2GcdU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Mul_3() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2MulU3 = <<A as Mul<B>>::Output as Same<U6>>::Output;
+
+    assert_eq!(<U2MulU3 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Div_3() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U2DivU3 = <<A as Div<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U2DivU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Rem_3() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2RemU3 = <<A as Rem<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2RemU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Pow_3() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2PowU3 = <<A as Pow<B>>::Output as Same<U8>>::Output;
+
+    assert_eq!(<U2PowU3 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Cmp_3() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2CmpU3 = <A as Cmp<B>>::Output;
+    assert_eq!(<U2CmpU3 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_BitAnd_4() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U2BitAndU4 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U2BitAndU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_BitOr_4() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2BitOrU4 = <<A as BitOr<B>>::Output as Same<U6>>::Output;
+
+    assert_eq!(<U2BitOrU4 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_BitXor_4() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2BitXorU4 = <<A as BitXor<B>>::Output as Same<U6>>::Output;
+
+    assert_eq!(<U2BitXorU4 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Shl_4() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U32 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2ShlU4 = <<A as Shl<B>>::Output as Same<U32>>::Output;
+
+    assert_eq!(<U2ShlU4 as Unsigned>::to_u64(), <U32 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Shr_4() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U2ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U2ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Add_4() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2AddU4 = <<A as Add<B>>::Output as Same<U6>>::Output;
+
+    assert_eq!(<U2AddU4 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Min_4() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2MinU4 = <<A as Min<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2MinU4 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Max_4() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U2MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Gcd_4() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2GcdU4 = <<A as Gcd<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2GcdU4 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Mul_4() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2MulU4 = <<A as Mul<B>>::Output as Same<U8>>::Output;
+
+    assert_eq!(<U2MulU4 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Div_4() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U2DivU4 = <<A as Div<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U2DivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Rem_4() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2RemU4 = <<A as Rem<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2RemU4 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Pow_4() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2PowU4 = <<A as Pow<B>>::Output as Same<U16>>::Output;
+
+    assert_eq!(<U2PowU4 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Cmp_4() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2CmpU4 = <A as Cmp<B>>::Output;
+    assert_eq!(<U2CmpU4 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_BitAnd_5() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U2BitAndU5 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U2BitAndU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_BitOr_5() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2BitOrU5 = <<A as BitOr<B>>::Output as Same<U7>>::Output;
+
+    assert_eq!(<U2BitOrU5 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_BitXor_5() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2BitXorU5 = <<A as BitXor<B>>::Output as Same<U7>>::Output;
+
+    assert_eq!(<U2BitXorU5 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Shl_5() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U64 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2ShlU5 = <<A as Shl<B>>::Output as Same<U64>>::Output;
+
+    assert_eq!(<U2ShlU5 as Unsigned>::to_u64(), <U64 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Shr_5() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U2ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U2ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Add_5() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2AddU5 = <<A as Add<B>>::Output as Same<U7>>::Output;
+
+    assert_eq!(<U2AddU5 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Min_5() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2MinU5 = <<A as Min<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2MinU5 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Max_5() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U2MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Gcd_5() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2GcdU5 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U2GcdU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Mul_5() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U10 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2MulU5 = <<A as Mul<B>>::Output as Same<U10>>::Output;
+
+    assert_eq!(<U2MulU5 as Unsigned>::to_u64(), <U10 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Div_5() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U2DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U2DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Rem_5() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2RemU5 = <<A as Rem<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U2RemU5 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Pow_5() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U32 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U2PowU5 = <<A as Pow<B>>::Output as Same<U32>>::Output;
+
+    assert_eq!(<U2PowU5 as Unsigned>::to_u64(), <U32 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_2_Cmp_5() {
+    type A = UInt<UInt<UTerm, B1>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U2CmpU5 = <A as Cmp<B>>::Output;
+    assert_eq!(<U2CmpU5 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_BitAnd_0() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U3BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U3BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_BitOr_0() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UTerm;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3BitOrU0 = <<A as BitOr<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3BitOrU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_BitXor_0() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UTerm;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3BitXorU0 = <<A as BitXor<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3BitXorU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Shl_0() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UTerm;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3ShlU0 = <<A as Shl<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3ShlU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Shr_0() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UTerm;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3ShrU0 = <<A as Shr<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3ShrU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Add_0() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UTerm;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3AddU0 = <<A as Add<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3AddU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Min_0() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U3MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U3MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Max_0() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UTerm;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3MaxU0 = <<A as Max<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3MaxU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Gcd_0() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UTerm;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3GcdU0 = <<A as Gcd<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3GcdU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Sub_0() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UTerm;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3SubU0 = <<A as Sub<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3SubU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Mul_0() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U3MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U3MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Pow_0() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UTerm;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U3PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Cmp_0() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U3CmpU0 = <A as Cmp<B>>::Output;
+    assert_eq!(<U3CmpU0 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_BitAnd_1() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3BitAndU1 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U3BitAndU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_BitOr_1() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3BitOrU1 = <<A as BitOr<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3BitOrU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_BitXor_1() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U3BitXorU1 = <<A as BitXor<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U3BitXorU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Shl_1() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U3ShlU1 = <<A as Shl<B>>::Output as Same<U6>>::Output;
+
+    assert_eq!(<U3ShlU1 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Shr_1() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3ShrU1 = <<A as Shr<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U3ShrU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Add_1() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U3AddU1 = <<A as Add<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U3AddU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Min_1() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U3MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Max_1() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3MaxU1 = <<A as Max<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3MaxU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Gcd_1() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U3GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Sub_1() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U3SubU1 = <<A as Sub<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U3SubU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Mul_1() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3MulU1 = <<A as Mul<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3MulU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Div_1() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3DivU1 = <<A as Div<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3DivU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Rem_1() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U3RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U3RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_PartialDiv_1() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3PartialDivU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Pow_1() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3PowU1 = <<A as Pow<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3PowU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Cmp_1() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3CmpU1 = <A as Cmp<B>>::Output;
+    assert_eq!(<U3CmpU1 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_BitAnd_2() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U3BitAndU2 = <<A as BitAnd<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U3BitAndU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_BitOr_2() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3BitOrU2 = <<A as BitOr<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3BitOrU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_BitXor_2() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3BitXorU2 = <<A as BitXor<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U3BitXorU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Shl_2() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U12 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U3ShlU2 = <<A as Shl<B>>::Output as Same<U12>>::Output;
+
+    assert_eq!(<U3ShlU2 as Unsigned>::to_u64(), <U12 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Shr_2() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U3ShrU2 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U3ShrU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Add_2() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3AddU2 = <<A as Add<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U3AddU2 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Min_2() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U3MinU2 = <<A as Min<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U3MinU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Max_2() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3MaxU2 = <<A as Max<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3MaxU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Gcd_2() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3GcdU2 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U3GcdU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Sub_2() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3SubU2 = <<A as Sub<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U3SubU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Mul_2() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U3MulU2 = <<A as Mul<B>>::Output as Same<U6>>::Output;
+
+    assert_eq!(<U3MulU2 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Div_2() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3DivU2 = <<A as Div<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U3DivU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Rem_2() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3RemU2 = <<A as Rem<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U3RemU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Pow_2() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U9 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3PowU2 = <<A as Pow<B>>::Output as Same<U9>>::Output;
+
+    assert_eq!(<U3PowU2 as Unsigned>::to_u64(), <U9 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Cmp_2() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U3CmpU2 = <A as Cmp<B>>::Output;
+    assert_eq!(<U3CmpU2 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_BitAnd_3() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3BitAndU3 = <<A as BitAnd<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3BitAndU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_BitOr_3() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3BitOrU3 = <<A as BitOr<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3BitOrU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_BitXor_3() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U3BitXorU3 = <<A as BitXor<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U3BitXorU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Shl_3() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U24 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U3ShlU3 = <<A as Shl<B>>::Output as Same<U24>>::Output;
+
+    assert_eq!(<U3ShlU3 as Unsigned>::to_u64(), <U24 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Shr_3() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U3ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U3ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Add_3() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U3AddU3 = <<A as Add<B>>::Output as Same<U6>>::Output;
+
+    assert_eq!(<U3AddU3 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Min_3() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3MinU3 = <<A as Min<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3MinU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Max_3() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3MaxU3 = <<A as Max<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3MaxU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Gcd_3() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3GcdU3 = <<A as Gcd<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3GcdU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Sub_3() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U3SubU3 = <<A as Sub<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U3SubU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Mul_3() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U9 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3MulU3 = <<A as Mul<B>>::Output as Same<U9>>::Output;
+
+    assert_eq!(<U3MulU3 as Unsigned>::to_u64(), <U9 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Div_3() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3DivU3 = <<A as Div<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U3DivU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Rem_3() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U3RemU3 = <<A as Rem<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U3RemU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_PartialDiv_3() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3PartialDivU3 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U3PartialDivU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Pow_3() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U27 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3PowU3 = <<A as Pow<B>>::Output as Same<U27>>::Output;
+
+    assert_eq!(<U3PowU3 as Unsigned>::to_u64(), <U27 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Cmp_3() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3CmpU3 = <A as Cmp<B>>::Output;
+    assert_eq!(<U3CmpU3 as Ord>::to_ordering(), Ordering::Equal);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_BitAnd_4() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U3BitAndU4 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U3BitAndU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_BitOr_4() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3BitOrU4 = <<A as BitOr<B>>::Output as Same<U7>>::Output;
+
+    assert_eq!(<U3BitOrU4 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_BitXor_4() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3BitXorU4 = <<A as BitXor<B>>::Output as Same<U7>>::Output;
+
+    assert_eq!(<U3BitXorU4 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Shl_4() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U48 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U3ShlU4 = <<A as Shl<B>>::Output as Same<U48>>::Output;
+
+    assert_eq!(<U3ShlU4 as Unsigned>::to_u64(), <U48 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Shr_4() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U3ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U3ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Add_4() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3AddU4 = <<A as Add<B>>::Output as Same<U7>>::Output;
+
+    assert_eq!(<U3AddU4 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Min_4() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3MinU4 = <<A as Min<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3MinU4 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Max_4() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U3MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U3MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Gcd_4() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3GcdU4 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U3GcdU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Mul_4() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U12 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U3MulU4 = <<A as Mul<B>>::Output as Same<U12>>::Output;
+
+    assert_eq!(<U3MulU4 as Unsigned>::to_u64(), <U12 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Div_4() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U3DivU4 = <<A as Div<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U3DivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Rem_4() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3RemU4 = <<A as Rem<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3RemU4 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Pow_4() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U81 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3PowU4 = <<A as Pow<B>>::Output as Same<U81>>::Output;
+
+    assert_eq!(<U3PowU4 as Unsigned>::to_u64(), <U81 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Cmp_4() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U3CmpU4 = <A as Cmp<B>>::Output;
+    assert_eq!(<U3CmpU4 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_BitAnd_5() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3BitAndU5 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U3BitAndU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_BitOr_5() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3BitOrU5 = <<A as BitOr<B>>::Output as Same<U7>>::Output;
+
+    assert_eq!(<U3BitOrU5 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_BitXor_5() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U3BitXorU5 = <<A as BitXor<B>>::Output as Same<U6>>::Output;
+
+    assert_eq!(<U3BitXorU5 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Shl_5() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U96 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U3ShlU5 = <<A as Shl<B>>::Output as Same<U96>>::Output;
+
+    assert_eq!(<U3ShlU5 as Unsigned>::to_u64(), <U96 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Shr_5() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U3ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U3ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Add_5() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U3AddU5 = <<A as Add<B>>::Output as Same<U8>>::Output;
+
+    assert_eq!(<U3AddU5 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Min_5() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3MinU5 = <<A as Min<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3MinU5 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Max_5() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U3MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Gcd_5() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3GcdU5 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U3GcdU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Mul_5() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U15 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3MulU5 = <<A as Mul<B>>::Output as Same<U15>>::Output;
+
+    assert_eq!(<U3MulU5 as Unsigned>::to_u64(), <U15 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Div_5() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U3DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U3DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Rem_5() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3RemU5 = <<A as Rem<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U3RemU5 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Pow_5() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U243 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3PowU5 = <<A as Pow<B>>::Output as Same<U243>>::Output;
+
+    assert_eq!(<U3PowU5 as Unsigned>::to_u64(), <U243 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_3_Cmp_5() {
+    type A = UInt<UInt<UTerm, B1>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U3CmpU5 = <A as Cmp<B>>::Output;
+    assert_eq!(<U3CmpU5 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_BitAnd_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U4BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U4BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_BitOr_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UTerm;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4BitOrU0 = <<A as BitOr<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4BitOrU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_BitXor_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UTerm;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4BitXorU0 = <<A as BitXor<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4BitXorU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Shl_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UTerm;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4ShlU0 = <<A as Shl<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4ShlU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Shr_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UTerm;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4ShrU0 = <<A as Shr<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4ShrU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Add_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UTerm;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4AddU0 = <<A as Add<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4AddU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Min_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U4MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U4MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Max_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UTerm;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4MaxU0 = <<A as Max<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4MaxU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Gcd_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UTerm;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4GcdU0 = <<A as Gcd<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4GcdU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Sub_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UTerm;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4SubU0 = <<A as Sub<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4SubU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Mul_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U4MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U4MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Pow_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UTerm;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U4PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Cmp_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U4CmpU0 = <A as Cmp<B>>::Output;
+    assert_eq!(<U4CmpU0 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_BitAnd_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U4BitAndU1 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U4BitAndU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_BitOr_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4BitOrU1 = <<A as BitOr<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U4BitOrU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_BitXor_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4BitXorU1 = <<A as BitXor<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U4BitXorU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Shl_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4ShlU1 = <<A as Shl<B>>::Output as Same<U8>>::Output;
+
+    assert_eq!(<U4ShlU1 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Shr_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4ShrU1 = <<A as Shr<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U4ShrU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Add_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4AddU1 = <<A as Add<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U4AddU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Min_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U4MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Max_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4MaxU1 = <<A as Max<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4MaxU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Gcd_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U4GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Sub_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4SubU1 = <<A as Sub<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U4SubU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Mul_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4MulU1 = <<A as Mul<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4MulU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Div_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4DivU1 = <<A as Div<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4DivU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Rem_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U4RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U4RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_PartialDiv_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4PartialDivU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Pow_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UTerm, B1>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4PowU1 = <<A as Pow<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4PowU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Cmp_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4CmpU1 = <A as Cmp<B>>::Output;
+    assert_eq!(<U4CmpU1 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_BitAnd_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U4BitAndU2 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U4BitAndU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_BitOr_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4BitOrU2 = <<A as BitOr<B>>::Output as Same<U6>>::Output;
+
+    assert_eq!(<U4BitOrU2 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_BitXor_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4BitXorU2 = <<A as BitXor<B>>::Output as Same<U6>>::Output;
+
+    assert_eq!(<U4BitXorU2 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Shl_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4ShlU2 = <<A as Shl<B>>::Output as Same<U16>>::Output;
+
+    assert_eq!(<U4ShlU2 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Shr_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4ShrU2 = <<A as Shr<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U4ShrU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Add_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4AddU2 = <<A as Add<B>>::Output as Same<U6>>::Output;
+
+    assert_eq!(<U4AddU2 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Min_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4MinU2 = <<A as Min<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U4MinU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Max_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4MaxU2 = <<A as Max<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4MaxU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Gcd_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4GcdU2 = <<A as Gcd<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U4GcdU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Sub_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4SubU2 = <<A as Sub<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U4SubU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Mul_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4MulU2 = <<A as Mul<B>>::Output as Same<U8>>::Output;
+
+    assert_eq!(<U4MulU2 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Div_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4DivU2 = <<A as Div<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U4DivU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Rem_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U4RemU2 = <<A as Rem<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U4RemU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_PartialDiv_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4PartialDivU2 = <<A as PartialDiv<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U4PartialDivU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Pow_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4PowU2 = <<A as Pow<B>>::Output as Same<U16>>::Output;
+
+    assert_eq!(<U4PowU2 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Cmp_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4CmpU2 = <A as Cmp<B>>::Output;
+    assert_eq!(<U4CmpU2 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_BitAnd_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U4BitAndU3 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U4BitAndU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_BitOr_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4BitOrU3 = <<A as BitOr<B>>::Output as Same<U7>>::Output;
+
+    assert_eq!(<U4BitOrU3 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_BitXor_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4BitXorU3 = <<A as BitXor<B>>::Output as Same<U7>>::Output;
+
+    assert_eq!(<U4BitXorU3 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Shl_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U32 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4ShlU3 = <<A as Shl<B>>::Output as Same<U32>>::Output;
+
+    assert_eq!(<U4ShlU3 as Unsigned>::to_u64(), <U32 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Shr_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U4ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U4ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Add_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4AddU3 = <<A as Add<B>>::Output as Same<U7>>::Output;
+
+    assert_eq!(<U4AddU3 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Min_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4MinU3 = <<A as Min<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U4MinU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Max_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4MaxU3 = <<A as Max<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4MaxU3 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Gcd_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4GcdU3 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U4GcdU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Sub_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4SubU3 = <<A as Sub<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U4SubU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Mul_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U12 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4MulU3 = <<A as Mul<B>>::Output as Same<U12>>::Output;
+
+    assert_eq!(<U4MulU3 as Unsigned>::to_u64(), <U12 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Div_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4DivU3 = <<A as Div<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U4DivU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Rem_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4RemU3 = <<A as Rem<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U4RemU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Pow_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U64 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4PowU3 = <<A as Pow<B>>::Output as Same<U64>>::Output;
+
+    assert_eq!(<U4PowU3 as Unsigned>::to_u64(), <U64 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Cmp_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4CmpU3 = <A as Cmp<B>>::Output;
+    assert_eq!(<U4CmpU3 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_BitAnd_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4BitAndU4 = <<A as BitAnd<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4BitAndU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_BitOr_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4BitOrU4 = <<A as BitOr<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4BitOrU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_BitXor_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U4BitXorU4 = <<A as BitXor<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U4BitXorU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Shl_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U64 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4ShlU4 = <<A as Shl<B>>::Output as Same<U64>>::Output;
+
+    assert_eq!(<U4ShlU4 as Unsigned>::to_u64(), <U64 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Shr_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U4ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U4ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Add_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4AddU4 = <<A as Add<B>>::Output as Same<U8>>::Output;
+
+    assert_eq!(<U4AddU4 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Min_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4MinU4 = <<A as Min<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4MinU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Max_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Gcd_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4GcdU4 = <<A as Gcd<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4GcdU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Sub_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U4SubU4 = <<A as Sub<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U4SubU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Mul_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4MulU4 = <<A as Mul<B>>::Output as Same<U16>>::Output;
+
+    assert_eq!(<U4MulU4 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Div_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4DivU4 = <<A as Div<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U4DivU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Rem_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U4RemU4 = <<A as Rem<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U4RemU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_PartialDiv_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4PartialDivU4 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U4PartialDivU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Pow_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U256 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4PowU4 = <<A as Pow<B>>::Output as Same<U256>>::Output;
+
+    assert_eq!(<U4PowU4 as Unsigned>::to_u64(), <U256 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Cmp_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4CmpU4 = <A as Cmp<B>>::Output;
+    assert_eq!(<U4CmpU4 as Ord>::to_ordering(), Ordering::Equal);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_BitAnd_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4BitAndU5 = <<A as BitAnd<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4BitAndU5 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_BitOr_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4BitOrU5 = <<A as BitOr<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U4BitOrU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_BitXor_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4BitXorU5 = <<A as BitXor<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U4BitXorU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Shl_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U128 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4ShlU5 = <<A as Shl<B>>::Output as Same<U128>>::Output;
+
+    assert_eq!(<U4ShlU5 as Unsigned>::to_u64(), <U128 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Shr_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U4ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U4ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Add_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U9 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4AddU5 = <<A as Add<B>>::Output as Same<U9>>::Output;
+
+    assert_eq!(<U4AddU5 as Unsigned>::to_u64(), <U9 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Min_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4MinU5 = <<A as Min<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4MinU5 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Max_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U4MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Gcd_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4GcdU5 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U4GcdU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Mul_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U20 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4MulU5 = <<A as Mul<B>>::Output as Same<U20>>::Output;
+
+    assert_eq!(<U4MulU5 as Unsigned>::to_u64(), <U20 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Div_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U4DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U4DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Rem_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4RemU5 = <<A as Rem<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U4RemU5 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Pow_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U1024 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U4PowU5 = <<A as Pow<B>>::Output as Same<U1024>>::Output;
+
+    assert_eq!(<U4PowU5 as Unsigned>::to_u64(), <U1024 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_4_Cmp_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U4CmpU5 = <A as Cmp<B>>::Output;
+    assert_eq!(<U4CmpU5 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_BitAnd_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U5BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U5BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_BitOr_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UTerm;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5BitOrU0 = <<A as BitOr<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5BitOrU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_BitXor_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UTerm;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5BitXorU0 = <<A as BitXor<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5BitXorU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Shl_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UTerm;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5ShlU0 = <<A as Shl<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5ShlU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Shr_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UTerm;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5ShrU0 = <<A as Shr<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5ShrU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Add_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UTerm;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5AddU0 = <<A as Add<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5AddU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Min_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U5MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U5MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Max_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UTerm;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5MaxU0 = <<A as Max<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5MaxU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Gcd_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UTerm;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5GcdU0 = <<A as Gcd<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5GcdU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Sub_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UTerm;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5SubU0 = <<A as Sub<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5SubU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Mul_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UTerm;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U5MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U5MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Pow_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UTerm;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U5PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Cmp_0() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U5CmpU0 = <A as Cmp<B>>::Output;
+    assert_eq!(<U5CmpU0 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_BitAnd_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5BitAndU1 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U5BitAndU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_BitOr_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5BitOrU1 = <<A as BitOr<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5BitOrU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_BitXor_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5BitXorU1 = <<A as BitXor<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U5BitXorU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Shl_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U10 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5ShlU1 = <<A as Shl<B>>::Output as Same<U10>>::Output;
+
+    assert_eq!(<U5ShlU1 as Unsigned>::to_u64(), <U10 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Shr_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5ShrU1 = <<A as Shr<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U5ShrU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Add_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5AddU1 = <<A as Add<B>>::Output as Same<U6>>::Output;
+
+    assert_eq!(<U5AddU1 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Min_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U5MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Max_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5MaxU1 = <<A as Max<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5MaxU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Gcd_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U5GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Sub_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5SubU1 = <<A as Sub<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U5SubU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Mul_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5MulU1 = <<A as Mul<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5MulU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Div_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5DivU1 = <<A as Div<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5DivU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Rem_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U5RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U5RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_PartialDiv_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5PartialDivU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Pow_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UTerm, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5PowU1 = <<A as Pow<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5PowU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Cmp_1() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5CmpU1 = <A as Cmp<B>>::Output;
+    assert_eq!(<U5CmpU1 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_BitAnd_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U5BitAndU2 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U5BitAndU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_BitOr_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5BitOrU2 = <<A as BitOr<B>>::Output as Same<U7>>::Output;
+
+    assert_eq!(<U5BitOrU2 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_BitXor_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5BitXorU2 = <<A as BitXor<B>>::Output as Same<U7>>::Output;
+
+    assert_eq!(<U5BitXorU2 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Shl_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U20 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5ShlU2 = <<A as Shl<B>>::Output as Same<U20>>::Output;
+
+    assert_eq!(<U5ShlU2 as Unsigned>::to_u64(), <U20 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Shr_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5ShrU2 = <<A as Shr<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U5ShrU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Add_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5AddU2 = <<A as Add<B>>::Output as Same<U7>>::Output;
+
+    assert_eq!(<U5AddU2 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Min_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5MinU2 = <<A as Min<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U5MinU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Max_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5MaxU2 = <<A as Max<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5MaxU2 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Gcd_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5GcdU2 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U5GcdU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Sub_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5SubU2 = <<A as Sub<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U5SubU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Mul_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U10 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5MulU2 = <<A as Mul<B>>::Output as Same<U10>>::Output;
+
+    assert_eq!(<U5MulU2 as Unsigned>::to_u64(), <U10 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Div_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5DivU2 = <<A as Div<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U5DivU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Rem_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5RemU2 = <<A as Rem<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U5RemU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Pow_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+    type U25 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5PowU2 = <<A as Pow<B>>::Output as Same<U25>>::Output;
+
+    assert_eq!(<U5PowU2 as Unsigned>::to_u64(), <U25 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Cmp_2() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5CmpU2 = <A as Cmp<B>>::Output;
+    assert_eq!(<U5CmpU2 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_BitAnd_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5BitAndU3 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U5BitAndU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_BitOr_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5BitOrU3 = <<A as BitOr<B>>::Output as Same<U7>>::Output;
+
+    assert_eq!(<U5BitOrU3 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_BitXor_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5BitXorU3 = <<A as BitXor<B>>::Output as Same<U6>>::Output;
+
+    assert_eq!(<U5BitXorU3 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Shl_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U40 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5ShlU3 = <<A as Shl<B>>::Output as Same<U40>>::Output;
+
+    assert_eq!(<U5ShlU3 as Unsigned>::to_u64(), <U40 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Shr_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U5ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U5ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Add_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5AddU3 = <<A as Add<B>>::Output as Same<U8>>::Output;
+
+    assert_eq!(<U5AddU3 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Min_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U3 = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5MinU3 = <<A as Min<B>>::Output as Same<U3>>::Output;
+
+    assert_eq!(<U5MinU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Max_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5MaxU3 = <<A as Max<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5MaxU3 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Gcd_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5GcdU3 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U5GcdU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Sub_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5SubU3 = <<A as Sub<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U5SubU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Mul_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U15 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5MulU3 = <<A as Mul<B>>::Output as Same<U15>>::Output;
+
+    assert_eq!(<U5MulU3 as Unsigned>::to_u64(), <U15 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Div_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5DivU3 = <<A as Div<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U5DivU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Rem_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U2 = UInt<UInt<UTerm, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5RemU3 = <<A as Rem<B>>::Output as Same<U2>>::Output;
+
+    assert_eq!(<U5RemU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Pow_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+    type U125 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5PowU3 = <<A as Pow<B>>::Output as Same<U125>>::Output;
+
+    assert_eq!(<U5PowU3 as Unsigned>::to_u64(), <U125 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Cmp_3() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UTerm, B1>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5CmpU3 = <A as Cmp<B>>::Output;
+    assert_eq!(<U5CmpU3 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_BitAnd_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5BitAndU4 = <<A as BitAnd<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U5BitAndU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_BitOr_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5BitOrU4 = <<A as BitOr<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5BitOrU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_BitXor_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5BitXorU4 = <<A as BitXor<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U5BitXorU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Shl_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U80 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5ShlU4 = <<A as Shl<B>>::Output as Same<U80>>::Output;
+
+    assert_eq!(<U5ShlU4 as Unsigned>::to_u64(), <U80 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Shr_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U5ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U5ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Add_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U9 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5AddU4 = <<A as Add<B>>::Output as Same<U9>>::Output;
+
+    assert_eq!(<U5AddU4 as Unsigned>::to_u64(), <U9 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Min_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5MinU4 = <<A as Min<B>>::Output as Same<U4>>::Output;
+
+    assert_eq!(<U5MinU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Max_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5MaxU4 = <<A as Max<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5MaxU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Gcd_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5GcdU4 = <<A as Gcd<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U5GcdU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Sub_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5SubU4 = <<A as Sub<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U5SubU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Mul_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U20 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5MulU4 = <<A as Mul<B>>::Output as Same<U20>>::Output;
+
+    assert_eq!(<U5MulU4 as Unsigned>::to_u64(), <U20 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Div_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5DivU4 = <<A as Div<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U5DivU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Rem_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5RemU4 = <<A as Rem<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U5RemU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Pow_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+    type U625 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5PowU4 = <<A as Pow<B>>::Output as Same<U625>>::Output;
+
+    assert_eq!(<U5PowU4 as Unsigned>::to_u64(), <U625 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Cmp_4() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5CmpU4 = <A as Cmp<B>>::Output;
+    assert_eq!(<U5CmpU4 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_BitAnd_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5BitAndU5 = <<A as BitAnd<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5BitAndU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_BitOr_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5BitOrU5 = <<A as BitOr<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5BitOrU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_BitXor_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U5BitXorU5 = <<A as BitXor<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U5BitXorU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Shl_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U160 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5ShlU5 = <<A as Shl<B>>::Output as Same<U160>>::Output;
+
+    assert_eq!(<U5ShlU5 as Unsigned>::to_u64(), <U160 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Shr_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U5ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U5ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Add_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U10 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>;
+
+    #[allow(non_camel_case_types)]
+    type U5AddU5 = <<A as Add<B>>::Output as Same<U10>>::Output;
+
+    assert_eq!(<U5AddU5 as Unsigned>::to_u64(), <U10 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Min_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5MinU5 = <<A as Min<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5MinU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Max_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Gcd_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5GcdU5 = <<A as Gcd<B>>::Output as Same<U5>>::Output;
+
+    assert_eq!(<U5GcdU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Sub_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U5SubU5 = <<A as Sub<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U5SubU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Mul_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U25 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5MulU5 = <<A as Mul<B>>::Output as Same<U25>>::Output;
+
+    assert_eq!(<U5MulU5 as Unsigned>::to_u64(), <U25 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Div_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5DivU5 = <<A as Div<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U5DivU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Rem_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U0 = UTerm;
+
+    #[allow(non_camel_case_types)]
+    type U5RemU5 = <<A as Rem<B>>::Output as Same<U0>>::Output;
+
+    assert_eq!(<U5RemU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_PartialDiv_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U1 = UInt<UTerm, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5PartialDivU5 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;
+
+    assert_eq!(<U5PartialDivU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Pow_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type U3125 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5PowU5 = <<A as Pow<B>>::Output as Same<U3125>>::Output;
+
+    assert_eq!(<U5PowU5 as Unsigned>::to_u64(), <U3125 as Unsigned>::to_u64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_5_Cmp_5() {
+    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
+
+    #[allow(non_camel_case_types)]
+    type U5CmpU5 = <A as Cmp<B>>::Output;
+    assert_eq!(<U5CmpU5 as Ord>::to_ordering(), Ordering::Equal);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Add_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5AddN5 = <<A as Add<B>>::Output as Same<N10>>::Output;
+
+    assert_eq!(<N5AddN5 as Integer>::to_i64(), <N10 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Sub_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N5SubN5 = <<A as Sub<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N5SubN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Mul_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P25 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MulN5 = <<A as Mul<B>>::Output as Same<P25>>::Output;
+
+    assert_eq!(<N5MulN5 as Integer>::to_i64(), <P25 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Min_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N5MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Max_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MaxN5 = <<A as Max<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N5MaxN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Gcd_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5GcdN5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<N5GcdN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Div_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5DivN5 = <<A as Div<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N5DivN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Rem_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N5RemN5 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N5RemN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_PartialDiv_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5PartialDivN5 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N5PartialDivN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Cmp_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5CmpN5 = <A as Cmp<B>>::Output;
+    assert_eq!(<N5CmpN5 as Ord>::to_ordering(), Ordering::Equal);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Add_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5AddN4 = <<A as Add<B>>::Output as Same<N9>>::Output;
+
+    assert_eq!(<N5AddN4 as Integer>::to_i64(), <N9 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Sub_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5SubN4 = <<A as Sub<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N5SubN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Mul_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P20 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MulN4 = <<A as Mul<B>>::Output as Same<P20>>::Output;
+
+    assert_eq!(<N5MulN4 as Integer>::to_i64(), <P20 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Min_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MinN4 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N5MinN4 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Max_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MaxN4 = <<A as Max<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N5MaxN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Gcd_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N5GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Div_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5DivN4 = <<A as Div<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N5DivN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Rem_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5RemN4 = <<A as Rem<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N5RemN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Cmp_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5CmpN4 = <A as Cmp<B>>::Output;
+    assert_eq!(<N5CmpN4 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Add_N3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5AddN3 = <<A as Add<B>>::Output as Same<N8>>::Output;
+
+    assert_eq!(<N5AddN3 as Integer>::to_i64(), <N8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Sub_N3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5SubN3 = <<A as Sub<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N5SubN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Mul_N3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P15 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MulN3 = <<A as Mul<B>>::Output as Same<P15>>::Output;
+
+    assert_eq!(<N5MulN3 as Integer>::to_i64(), <P15 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Min_N3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MinN3 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N5MinN3 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Max_N3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MaxN3 = <<A as Max<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N5MaxN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Gcd_N3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N5GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Div_N3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5DivN3 = <<A as Div<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N5DivN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Rem_N3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5RemN3 = <<A as Rem<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N5RemN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Cmp_N3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5CmpN3 = <A as Cmp<B>>::Output;
+    assert_eq!(<N5CmpN3 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Add_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5AddN2 = <<A as Add<B>>::Output as Same<N7>>::Output;
+
+    assert_eq!(<N5AddN2 as Integer>::to_i64(), <N7 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Sub_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5SubN2 = <<A as Sub<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N5SubN2 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Mul_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MulN2 = <<A as Mul<B>>::Output as Same<P10>>::Output;
+
+    assert_eq!(<N5MulN2 as Integer>::to_i64(), <P10 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Min_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MinN2 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N5MinN2 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Max_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MaxN2 = <<A as Max<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N5MaxN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Gcd_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N5GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Div_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5DivN2 = <<A as Div<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N5DivN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Rem_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5RemN2 = <<A as Rem<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N5RemN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Cmp_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5CmpN2 = <A as Cmp<B>>::Output;
+    assert_eq!(<N5CmpN2 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Add_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5AddN1 = <<A as Add<B>>::Output as Same<N6>>::Output;
+
+    assert_eq!(<N5AddN1 as Integer>::to_i64(), <N6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Sub_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5SubN1 = <<A as Sub<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N5SubN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Mul_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MulN1 = <<A as Mul<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<N5MulN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Min_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MinN1 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N5MinN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Max_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N5MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Gcd_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N5GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Div_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5DivN1 = <<A as Div<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<N5DivN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Rem_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N5RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N5RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_PartialDiv_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<N5PartialDivN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Cmp_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5CmpN1 = <A as Cmp<B>>::Output;
+    assert_eq!(<N5CmpN1 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Add__0() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = Z0;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5Add_0 = <<A as Add<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N5Add_0 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Sub__0() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = Z0;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5Sub_0 = <<A as Sub<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N5Sub_0 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Mul__0() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N5Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N5Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Min__0() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = Z0;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5Min_0 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N5Min_0 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Max__0() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N5Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N5Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Gcd__0() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = Z0;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5Gcd_0 = <<A as Gcd<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<N5Gcd_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Pow__0() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = Z0;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N5Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Cmp__0() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N5Cmp_0 = <A as Cmp<B>>::Output;
+    assert_eq!(<N5Cmp_0 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Add_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5AddP1 = <<A as Add<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N5AddP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Sub_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5SubP1 = <<A as Sub<B>>::Output as Same<N6>>::Output;
+
+    assert_eq!(<N5SubP1 as Integer>::to_i64(), <N6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Mul_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MulP1 = <<A as Mul<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N5MulP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Min_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MinP1 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N5MinP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Max_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N5MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Gcd_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N5GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Div_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5DivP1 = <<A as Div<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N5DivP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Rem_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N5RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N5RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_PartialDiv_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N5PartialDivP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Pow_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5PowP1 = <<A as Pow<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N5PowP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Cmp_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5CmpP1 = <A as Cmp<B>>::Output;
+    assert_eq!(<N5CmpP1 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Add_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5AddP2 = <<A as Add<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N5AddP2 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Sub_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5SubP2 = <<A as Sub<B>>::Output as Same<N7>>::Output;
+
+    assert_eq!(<N5SubP2 as Integer>::to_i64(), <N7 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Mul_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MulP2 = <<A as Mul<B>>::Output as Same<N10>>::Output;
+
+    assert_eq!(<N5MulP2 as Integer>::to_i64(), <N10 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Min_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MinP2 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N5MinP2 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Max_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N5MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Gcd_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N5GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Div_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5DivP2 = <<A as Div<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N5DivP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Rem_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5RemP2 = <<A as Rem<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N5RemP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Pow_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P25 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5PowP2 = <<A as Pow<B>>::Output as Same<P25>>::Output;
+
+    assert_eq!(<N5PowP2 as Integer>::to_i64(), <P25 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Cmp_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5CmpP2 = <A as Cmp<B>>::Output;
+    assert_eq!(<N5CmpP2 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Add_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5AddP3 = <<A as Add<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N5AddP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Sub_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5SubP3 = <<A as Sub<B>>::Output as Same<N8>>::Output;
+
+    assert_eq!(<N5SubP3 as Integer>::to_i64(), <N8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Mul_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N15 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MulP3 = <<A as Mul<B>>::Output as Same<N15>>::Output;
+
+    assert_eq!(<N5MulP3 as Integer>::to_i64(), <N15 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Min_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MinP3 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N5MinP3 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Max_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<N5MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Gcd_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N5GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Div_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5DivP3 = <<A as Div<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N5DivP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Rem_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5RemP3 = <<A as Rem<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N5RemP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Pow_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N125 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5PowP3 = <<A as Pow<B>>::Output as Same<N125>>::Output;
+
+    assert_eq!(<N5PowP3 as Integer>::to_i64(), <N125 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Cmp_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5CmpP3 = <A as Cmp<B>>::Output;
+    assert_eq!(<N5CmpP3 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Add_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5AddP4 = <<A as Add<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N5AddP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Sub_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5SubP4 = <<A as Sub<B>>::Output as Same<N9>>::Output;
+
+    assert_eq!(<N5SubP4 as Integer>::to_i64(), <N9 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Mul_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N20 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MulP4 = <<A as Mul<B>>::Output as Same<N20>>::Output;
+
+    assert_eq!(<N5MulP4 as Integer>::to_i64(), <N20 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Min_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MinP4 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N5MinP4 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Max_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<N5MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Gcd_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N5GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Div_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5DivP4 = <<A as Div<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N5DivP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Rem_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5RemP4 = <<A as Rem<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N5RemP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Pow_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P625 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5PowP4 = <<A as Pow<B>>::Output as Same<P625>>::Output;
+
+    assert_eq!(<N5PowP4 as Integer>::to_i64(), <P625 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Cmp_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5CmpP4 = <A as Cmp<B>>::Output;
+    assert_eq!(<N5CmpP4 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Add_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N5AddP5 = <<A as Add<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N5AddP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Sub_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N5SubP5 = <<A as Sub<B>>::Output as Same<N10>>::Output;
+
+    assert_eq!(<N5SubP5 as Integer>::to_i64(), <N10 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Mul_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N25 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MulP5 = <<A as Mul<B>>::Output as Same<N25>>::Output;
+
+    assert_eq!(<N5MulP5 as Integer>::to_i64(), <N25 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Min_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MinP5 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N5MinP5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Max_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<N5MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Gcd_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5GcdP5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<N5GcdP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Div_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5DivP5 = <<A as Div<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N5DivP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Rem_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N5RemP5 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N5RemP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_PartialDiv_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5PartialDivP5 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N5PartialDivP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Pow_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N3125 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5PowP5 = <<A as Pow<B>>::Output as Same<N3125>>::Output;
+
+    assert_eq!(<N5PowP5 as Integer>::to_i64(), <N3125 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Cmp_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N5CmpP5 = <A as Cmp<B>>::Output;
+    assert_eq!(<N5CmpP5 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Add_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4AddN5 = <<A as Add<B>>::Output as Same<N9>>::Output;
+
+    assert_eq!(<N4AddN5 as Integer>::to_i64(), <N9 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Sub_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4SubN5 = <<A as Sub<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N4SubN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Mul_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P20 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MulN5 = <<A as Mul<B>>::Output as Same<P20>>::Output;
+
+    assert_eq!(<N4MulN5 as Integer>::to_i64(), <P20 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Min_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N4MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Max_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MaxN5 = <<A as Max<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4MaxN5 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Gcd_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N4GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Div_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N4DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N4DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Rem_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4RemN5 = <<A as Rem<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4RemN5 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Cmp_N5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4CmpN5 = <A as Cmp<B>>::Output;
+    assert_eq!(<N4CmpN5 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Add_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4AddN4 = <<A as Add<B>>::Output as Same<N8>>::Output;
+
+    assert_eq!(<N4AddN4 as Integer>::to_i64(), <N8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Sub_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N4SubN4 = <<A as Sub<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N4SubN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Mul_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MulN4 = <<A as Mul<B>>::Output as Same<P16>>::Output;
+
+    assert_eq!(<N4MulN4 as Integer>::to_i64(), <P16 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Min_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Max_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MaxN4 = <<A as Max<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4MaxN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Gcd_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4GcdN4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<N4GcdN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Div_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4DivN4 = <<A as Div<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N4DivN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Rem_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N4RemN4 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N4RemN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_PartialDiv_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4PartialDivN4 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N4PartialDivN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Cmp_N4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4CmpN4 = <A as Cmp<B>>::Output;
+    assert_eq!(<N4CmpN4 as Ord>::to_ordering(), Ordering::Equal);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Add_N3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4AddN3 = <<A as Add<B>>::Output as Same<N7>>::Output;
+
+    assert_eq!(<N4AddN3 as Integer>::to_i64(), <N7 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Sub_N3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4SubN3 = <<A as Sub<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N4SubN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Mul_N3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P12 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MulN3 = <<A as Mul<B>>::Output as Same<P12>>::Output;
+
+    assert_eq!(<N4MulN3 as Integer>::to_i64(), <P12 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Min_N3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MinN3 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4MinN3 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Max_N3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MaxN3 = <<A as Max<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N4MaxN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Gcd_N3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N4GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Div_N3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4DivN3 = <<A as Div<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N4DivN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Rem_N3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4RemN3 = <<A as Rem<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N4RemN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Cmp_N3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4CmpN3 = <A as Cmp<B>>::Output;
+    assert_eq!(<N4CmpN3 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Add_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4AddN2 = <<A as Add<B>>::Output as Same<N6>>::Output;
+
+    assert_eq!(<N4AddN2 as Integer>::to_i64(), <N6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Sub_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4SubN2 = <<A as Sub<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N4SubN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Mul_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MulN2 = <<A as Mul<B>>::Output as Same<P8>>::Output;
+
+    assert_eq!(<N4MulN2 as Integer>::to_i64(), <P8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Min_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MinN2 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4MinN2 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Max_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MaxN2 = <<A as Max<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N4MaxN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Gcd_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N4GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Div_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4DivN2 = <<A as Div<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N4DivN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Rem_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N4RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N4RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_PartialDiv_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N4PartialDivN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Cmp_N2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4CmpN2 = <A as Cmp<B>>::Output;
+    assert_eq!(<N4CmpN2 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Add_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4AddN1 = <<A as Add<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N4AddN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Sub_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4SubN1 = <<A as Sub<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N4SubN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Mul_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MulN1 = <<A as Mul<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<N4MulN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Min_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MinN1 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4MinN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Max_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N4MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Gcd_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N4GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Div_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4DivN1 = <<A as Div<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<N4DivN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Rem_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N4RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N4RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_PartialDiv_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<N4PartialDivN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Cmp_N1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4CmpN1 = <A as Cmp<B>>::Output;
+    assert_eq!(<N4CmpN1 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Add__0() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = Z0;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4Add_0 = <<A as Add<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4Add_0 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Sub__0() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = Z0;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4Sub_0 = <<A as Sub<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4Sub_0 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Mul__0() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N4Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N4Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Min__0() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = Z0;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4Min_0 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4Min_0 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Max__0() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N4Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N4Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Gcd__0() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = Z0;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4Gcd_0 = <<A as Gcd<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<N4Gcd_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Pow__0() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = Z0;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N4Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Cmp__0() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N4Cmp_0 = <A as Cmp<B>>::Output;
+    assert_eq!(<N4Cmp_0 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Add_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4AddP1 = <<A as Add<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N4AddP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Sub_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4SubP1 = <<A as Sub<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N4SubP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Mul_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MulP1 = <<A as Mul<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4MulP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Min_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MinP1 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4MinP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Max_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N4MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Gcd_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N4GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Div_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4DivP1 = <<A as Div<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4DivP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Rem_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N4RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N4RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_PartialDiv_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4PartialDivP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Pow_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4PowP1 = <<A as Pow<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4PowP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Cmp_P1() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4CmpP1 = <A as Cmp<B>>::Output;
+    assert_eq!(<N4CmpP1 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Add_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4AddP2 = <<A as Add<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N4AddP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Sub_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4SubP2 = <<A as Sub<B>>::Output as Same<N6>>::Output;
+
+    assert_eq!(<N4SubP2 as Integer>::to_i64(), <N6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Mul_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MulP2 = <<A as Mul<B>>::Output as Same<N8>>::Output;
+
+    assert_eq!(<N4MulP2 as Integer>::to_i64(), <N8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Min_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MinP2 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4MinP2 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Max_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N4MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Gcd_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N4GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Div_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4DivP2 = <<A as Div<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N4DivP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Rem_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N4RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N4RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_PartialDiv_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N4PartialDivP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Pow_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4PowP2 = <<A as Pow<B>>::Output as Same<P16>>::Output;
+
+    assert_eq!(<N4PowP2 as Integer>::to_i64(), <P16 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Cmp_P2() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4CmpP2 = <A as Cmp<B>>::Output;
+    assert_eq!(<N4CmpP2 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Add_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4AddP3 = <<A as Add<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N4AddP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Sub_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4SubP3 = <<A as Sub<B>>::Output as Same<N7>>::Output;
+
+    assert_eq!(<N4SubP3 as Integer>::to_i64(), <N7 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Mul_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N12 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MulP3 = <<A as Mul<B>>::Output as Same<N12>>::Output;
+
+    assert_eq!(<N4MulP3 as Integer>::to_i64(), <N12 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Min_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MinP3 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4MinP3 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Max_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<N4MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Gcd_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N4GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Div_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4DivP3 = <<A as Div<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N4DivP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Rem_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4RemP3 = <<A as Rem<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N4RemP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Pow_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N64 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4PowP3 = <<A as Pow<B>>::Output as Same<N64>>::Output;
+
+    assert_eq!(<N4PowP3 as Integer>::to_i64(), <N64 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Cmp_P3() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4CmpP3 = <A as Cmp<B>>::Output;
+    assert_eq!(<N4CmpP3 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Add_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N4AddP4 = <<A as Add<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N4AddP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Sub_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4SubP4 = <<A as Sub<B>>::Output as Same<N8>>::Output;
+
+    assert_eq!(<N4SubP4 as Integer>::to_i64(), <N8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Mul_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N16 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MulP4 = <<A as Mul<B>>::Output as Same<N16>>::Output;
+
+    assert_eq!(<N4MulP4 as Integer>::to_i64(), <N16 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Min_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MinP4 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4MinP4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Max_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<N4MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Gcd_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4GcdP4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<N4GcdP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Div_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4DivP4 = <<A as Div<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N4DivP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Rem_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N4RemP4 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N4RemP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_PartialDiv_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4PartialDivP4 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N4PartialDivP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Pow_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P256 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4PowP4 = <<A as Pow<B>>::Output as Same<P256>>::Output;
+
+    assert_eq!(<N4PowP4 as Integer>::to_i64(), <P256 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Cmp_P4() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4CmpP4 = <A as Cmp<B>>::Output;
+    assert_eq!(<N4CmpP4 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Add_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4AddP5 = <<A as Add<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N4AddP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Sub_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4SubP5 = <<A as Sub<B>>::Output as Same<N9>>::Output;
+
+    assert_eq!(<N4SubP5 as Integer>::to_i64(), <N9 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Mul_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N20 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MulP5 = <<A as Mul<B>>::Output as Same<N20>>::Output;
+
+    assert_eq!(<N4MulP5 as Integer>::to_i64(), <N20 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Min_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MinP5 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4MinP5 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Max_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<N4MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Gcd_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N4GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Div_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N4DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N4DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Rem_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4RemP5 = <<A as Rem<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N4RemP5 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Pow_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N1024 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N4PowP5 = <<A as Pow<B>>::Output as Same<N1024>>::Output;
+
+    assert_eq!(<N4PowP5 as Integer>::to_i64(), <N1024 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Cmp_P5() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N4CmpP5 = <A as Cmp<B>>::Output;
+    assert_eq!(<N4CmpP5 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Add_N5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3AddN5 = <<A as Add<B>>::Output as Same<N8>>::Output;
+
+    assert_eq!(<N3AddN5 as Integer>::to_i64(), <N8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Sub_N5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3SubN5 = <<A as Sub<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N3SubN5 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Mul_N5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P15 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MulN5 = <<A as Mul<B>>::Output as Same<P15>>::Output;
+
+    assert_eq!(<N3MulN5 as Integer>::to_i64(), <P15 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Min_N5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N3MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Max_N5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MaxN5 = <<A as Max<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3MaxN5 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Gcd_N5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N3GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Div_N5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N3DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N3DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Rem_N5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3RemN5 = <<A as Rem<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3RemN5 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Cmp_N5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3CmpN5 = <A as Cmp<B>>::Output;
+    assert_eq!(<N3CmpN5 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Add_N4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3AddN4 = <<A as Add<B>>::Output as Same<N7>>::Output;
+
+    assert_eq!(<N3AddN4 as Integer>::to_i64(), <N7 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Sub_N4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3SubN4 = <<A as Sub<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N3SubN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Mul_N4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P12 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MulN4 = <<A as Mul<B>>::Output as Same<P12>>::Output;
+
+    assert_eq!(<N3MulN4 as Integer>::to_i64(), <P12 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Min_N4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N3MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Max_N4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MaxN4 = <<A as Max<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3MaxN4 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Gcd_N4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N3GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Div_N4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N3DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N3DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Rem_N4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3RemN4 = <<A as Rem<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3RemN4 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Cmp_N4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3CmpN4 = <A as Cmp<B>>::Output;
+    assert_eq!(<N3CmpN4 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Add_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3AddN3 = <<A as Add<B>>::Output as Same<N6>>::Output;
+
+    assert_eq!(<N3AddN3 as Integer>::to_i64(), <N6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Sub_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N3SubN3 = <<A as Sub<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N3SubN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Mul_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MulN3 = <<A as Mul<B>>::Output as Same<P9>>::Output;
+
+    assert_eq!(<N3MulN3 as Integer>::to_i64(), <P9 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Min_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Max_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MaxN3 = <<A as Max<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3MaxN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Gcd_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3GcdN3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<N3GcdN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Div_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3DivN3 = <<A as Div<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N3DivN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Rem_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N3RemN3 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N3RemN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_PartialDiv_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3PartialDivN3 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N3PartialDivN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Cmp_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3CmpN3 = <A as Cmp<B>>::Output;
+    assert_eq!(<N3CmpN3 as Ord>::to_ordering(), Ordering::Equal);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Add_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3AddN2 = <<A as Add<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N3AddN2 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Sub_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3SubN2 = <<A as Sub<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N3SubN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Mul_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MulN2 = <<A as Mul<B>>::Output as Same<P6>>::Output;
+
+    assert_eq!(<N3MulN2 as Integer>::to_i64(), <P6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Min_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MinN2 = <<A as Min<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3MinN2 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Max_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MaxN2 = <<A as Max<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N3MaxN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Gcd_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N3GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Div_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3DivN2 = <<A as Div<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N3DivN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Rem_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3RemN2 = <<A as Rem<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N3RemN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Cmp_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3CmpN2 = <A as Cmp<B>>::Output;
+    assert_eq!(<N3CmpN2 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Add_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3AddN1 = <<A as Add<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N3AddN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Sub_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3SubN1 = <<A as Sub<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N3SubN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Mul_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MulN1 = <<A as Mul<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<N3MulN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Min_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MinN1 = <<A as Min<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3MinN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Max_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N3MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Gcd_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N3GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Div_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3DivN1 = <<A as Div<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<N3DivN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Rem_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N3RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N3RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_PartialDiv_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<N3PartialDivN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Cmp_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3CmpN1 = <A as Cmp<B>>::Output;
+    assert_eq!(<N3CmpN1 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Add__0() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = Z0;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3Add_0 = <<A as Add<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3Add_0 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Sub__0() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = Z0;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3Sub_0 = <<A as Sub<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3Sub_0 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Mul__0() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N3Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N3Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Min__0() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = Z0;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3Min_0 = <<A as Min<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3Min_0 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Max__0() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N3Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N3Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Gcd__0() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = Z0;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3Gcd_0 = <<A as Gcd<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<N3Gcd_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Pow__0() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = Z0;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N3Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Cmp__0() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N3Cmp_0 = <A as Cmp<B>>::Output;
+    assert_eq!(<N3Cmp_0 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Add_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3AddP1 = <<A as Add<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N3AddP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Sub_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3SubP1 = <<A as Sub<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N3SubP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Mul_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MulP1 = <<A as Mul<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3MulP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Min_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MinP1 = <<A as Min<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3MinP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Max_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N3MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Gcd_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N3GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Div_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3DivP1 = <<A as Div<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3DivP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Rem_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N3RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N3RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_PartialDiv_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3PartialDivP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Pow_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3PowP1 = <<A as Pow<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3PowP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Cmp_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3CmpP1 = <A as Cmp<B>>::Output;
+    assert_eq!(<N3CmpP1 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Add_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3AddP2 = <<A as Add<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N3AddP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Sub_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3SubP2 = <<A as Sub<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N3SubP2 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Mul_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MulP2 = <<A as Mul<B>>::Output as Same<N6>>::Output;
+
+    assert_eq!(<N3MulP2 as Integer>::to_i64(), <N6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Min_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MinP2 = <<A as Min<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3MinP2 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Max_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N3MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Gcd_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N3GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Div_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3DivP2 = <<A as Div<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N3DivP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Rem_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3RemP2 = <<A as Rem<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N3RemP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Pow_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3PowP2 = <<A as Pow<B>>::Output as Same<P9>>::Output;
+
+    assert_eq!(<N3PowP2 as Integer>::to_i64(), <P9 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Cmp_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3CmpP2 = <A as Cmp<B>>::Output;
+    assert_eq!(<N3CmpP2 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Add_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N3AddP3 = <<A as Add<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N3AddP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Sub_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3SubP3 = <<A as Sub<B>>::Output as Same<N6>>::Output;
+
+    assert_eq!(<N3SubP3 as Integer>::to_i64(), <N6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Mul_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MulP3 = <<A as Mul<B>>::Output as Same<N9>>::Output;
+
+    assert_eq!(<N3MulP3 as Integer>::to_i64(), <N9 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Min_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MinP3 = <<A as Min<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3MinP3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Max_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<N3MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Gcd_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3GcdP3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<N3GcdP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Div_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3DivP3 = <<A as Div<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N3DivP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Rem_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N3RemP3 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N3RemP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_PartialDiv_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3PartialDivP3 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N3PartialDivP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Pow_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N27 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3PowP3 = <<A as Pow<B>>::Output as Same<N27>>::Output;
+
+    assert_eq!(<N3PowP3 as Integer>::to_i64(), <N27 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Cmp_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3CmpP3 = <A as Cmp<B>>::Output;
+    assert_eq!(<N3CmpP3 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Add_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3AddP4 = <<A as Add<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N3AddP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Sub_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3SubP4 = <<A as Sub<B>>::Output as Same<N7>>::Output;
+
+    assert_eq!(<N3SubP4 as Integer>::to_i64(), <N7 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Mul_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N12 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MulP4 = <<A as Mul<B>>::Output as Same<N12>>::Output;
+
+    assert_eq!(<N3MulP4 as Integer>::to_i64(), <N12 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Min_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MinP4 = <<A as Min<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3MinP4 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Max_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<N3MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Gcd_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N3GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Div_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N3DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N3DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Rem_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3RemP4 = <<A as Rem<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3RemP4 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Pow_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P81 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3PowP4 = <<A as Pow<B>>::Output as Same<P81>>::Output;
+
+    assert_eq!(<N3PowP4 as Integer>::to_i64(), <P81 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Cmp_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3CmpP4 = <A as Cmp<B>>::Output;
+    assert_eq!(<N3CmpP4 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Add_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3AddP5 = <<A as Add<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N3AddP5 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Sub_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N3SubP5 = <<A as Sub<B>>::Output as Same<N8>>::Output;
+
+    assert_eq!(<N3SubP5 as Integer>::to_i64(), <N8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Mul_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N15 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MulP5 = <<A as Mul<B>>::Output as Same<N15>>::Output;
+
+    assert_eq!(<N3MulP5 as Integer>::to_i64(), <N15 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Min_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MinP5 = <<A as Min<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3MinP5 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Max_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<N3MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Gcd_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N3GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Div_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N3DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N3DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Rem_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3RemP5 = <<A as Rem<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N3RemP5 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Pow_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N243 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3PowP5 = <<A as Pow<B>>::Output as Same<N243>>::Output;
+
+    assert_eq!(<N3PowP5 as Integer>::to_i64(), <N243 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Cmp_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N3CmpP5 = <A as Cmp<B>>::Output;
+    assert_eq!(<N3CmpP5 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Add_N5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2AddN5 = <<A as Add<B>>::Output as Same<N7>>::Output;
+
+    assert_eq!(<N2AddN5 as Integer>::to_i64(), <N7 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Sub_N5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2SubN5 = <<A as Sub<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<N2SubN5 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Mul_N5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MulN5 = <<A as Mul<B>>::Output as Same<P10>>::Output;
+
+    assert_eq!(<N2MulN5 as Integer>::to_i64(), <P10 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Min_N5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N2MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Max_N5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MaxN5 = <<A as Max<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2MaxN5 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Gcd_N5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N2GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Div_N5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N2DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N2DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Rem_N5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2RemN5 = <<A as Rem<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2RemN5 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Cmp_N5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2CmpN5 = <A as Cmp<B>>::Output;
+    assert_eq!(<N2CmpN5 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Add_N4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2AddN4 = <<A as Add<B>>::Output as Same<N6>>::Output;
+
+    assert_eq!(<N2AddN4 as Integer>::to_i64(), <N6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Sub_N4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2SubN4 = <<A as Sub<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N2SubN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Mul_N4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MulN4 = <<A as Mul<B>>::Output as Same<P8>>::Output;
+
+    assert_eq!(<N2MulN4 as Integer>::to_i64(), <P8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Min_N4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N2MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Max_N4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MaxN4 = <<A as Max<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2MaxN4 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Gcd_N4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2GcdN4 = <<A as Gcd<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N2GcdN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Div_N4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N2DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N2DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Rem_N4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2RemN4 = <<A as Rem<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2RemN4 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Cmp_N4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2CmpN4 = <A as Cmp<B>>::Output;
+    assert_eq!(<N2CmpN4 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Add_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2AddN3 = <<A as Add<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N2AddN3 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Sub_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2SubN3 = <<A as Sub<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N2SubN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Mul_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MulN3 = <<A as Mul<B>>::Output as Same<P6>>::Output;
+
+    assert_eq!(<N2MulN3 as Integer>::to_i64(), <P6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Min_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N2MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Max_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MaxN3 = <<A as Max<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2MaxN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Gcd_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N2GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Div_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N2DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N2DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Rem_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2RemN3 = <<A as Rem<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2RemN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Cmp_N3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2CmpN3 = <A as Cmp<B>>::Output;
+    assert_eq!(<N2CmpN3 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Add_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2AddN2 = <<A as Add<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N2AddN2 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Sub_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N2SubN2 = <<A as Sub<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N2SubN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Mul_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MulN2 = <<A as Mul<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<N2MulN2 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Min_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Max_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MaxN2 = <<A as Max<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2MaxN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Gcd_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N2GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Div_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2DivN2 = <<A as Div<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N2DivN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Rem_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N2RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N2RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_PartialDiv_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N2PartialDivN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Cmp_N2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2CmpN2 = <A as Cmp<B>>::Output;
+    assert_eq!(<N2CmpN2 as Ord>::to_ordering(), Ordering::Equal);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Add_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2AddN1 = <<A as Add<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N2AddN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Sub_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2SubN1 = <<A as Sub<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N2SubN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Mul_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MulN1 = <<A as Mul<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N2MulN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Min_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MinN1 = <<A as Min<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2MinN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Max_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N2MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Gcd_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N2GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Div_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2DivN1 = <<A as Div<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N2DivN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Rem_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N2RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N2RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_PartialDiv_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N2PartialDivN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Cmp_N1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2CmpN1 = <A as Cmp<B>>::Output;
+    assert_eq!(<N2CmpN1 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Add__0() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = Z0;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2Add_0 = <<A as Add<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2Add_0 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Sub__0() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = Z0;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2Sub_0 = <<A as Sub<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2Sub_0 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Mul__0() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N2Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N2Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Min__0() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = Z0;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2Min_0 = <<A as Min<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2Min_0 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Max__0() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N2Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N2Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Gcd__0() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = Z0;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2Gcd_0 = <<A as Gcd<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N2Gcd_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Pow__0() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = Z0;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N2Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Cmp__0() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N2Cmp_0 = <A as Cmp<B>>::Output;
+    assert_eq!(<N2Cmp_0 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Add_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2AddP1 = <<A as Add<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N2AddP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Sub_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2SubP1 = <<A as Sub<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N2SubP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Mul_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MulP1 = <<A as Mul<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2MulP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Min_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MinP1 = <<A as Min<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2MinP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Max_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N2MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Gcd_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N2GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Div_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2DivP1 = <<A as Div<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2DivP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Rem_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N2RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N2RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_PartialDiv_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2PartialDivP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Pow_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2PowP1 = <<A as Pow<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2PowP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Cmp_P1() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2CmpP1 = <A as Cmp<B>>::Output;
+    assert_eq!(<N2CmpP1 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Add_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N2AddP2 = <<A as Add<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N2AddP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Sub_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2SubP2 = <<A as Sub<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N2SubP2 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Mul_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MulP2 = <<A as Mul<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N2MulP2 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Min_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MinP2 = <<A as Min<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2MinP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Max_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N2MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Gcd_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N2GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Div_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2DivP2 = <<A as Div<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N2DivP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Rem_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N2RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N2RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_PartialDiv_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N2PartialDivP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Pow_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2PowP2 = <<A as Pow<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<N2PowP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Cmp_P2() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2CmpP2 = <A as Cmp<B>>::Output;
+    assert_eq!(<N2CmpP2 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Add_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2AddP3 = <<A as Add<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N2AddP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Sub_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2SubP3 = <<A as Sub<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N2SubP3 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Mul_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MulP3 = <<A as Mul<B>>::Output as Same<N6>>::Output;
+
+    assert_eq!(<N2MulP3 as Integer>::to_i64(), <N6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Min_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MinP3 = <<A as Min<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2MinP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Max_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<N2MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Gcd_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N2GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Div_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N2DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N2DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Rem_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2RemP3 = <<A as Rem<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2RemP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Pow_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2PowP3 = <<A as Pow<B>>::Output as Same<N8>>::Output;
+
+    assert_eq!(<N2PowP3 as Integer>::to_i64(), <N8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Cmp_P3() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2CmpP3 = <A as Cmp<B>>::Output;
+    assert_eq!(<N2CmpP3 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Add_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2AddP4 = <<A as Add<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N2AddP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Sub_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2SubP4 = <<A as Sub<B>>::Output as Same<N6>>::Output;
+
+    assert_eq!(<N2SubP4 as Integer>::to_i64(), <N6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Mul_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MulP4 = <<A as Mul<B>>::Output as Same<N8>>::Output;
+
+    assert_eq!(<N2MulP4 as Integer>::to_i64(), <N8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Min_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MinP4 = <<A as Min<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2MinP4 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Max_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<N2MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Gcd_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2GcdP4 = <<A as Gcd<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N2GcdP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Div_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N2DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N2DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Rem_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2RemP4 = <<A as Rem<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2RemP4 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Pow_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2PowP4 = <<A as Pow<B>>::Output as Same<P16>>::Output;
+
+    assert_eq!(<N2PowP4 as Integer>::to_i64(), <P16 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Cmp_P4() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2CmpP4 = <A as Cmp<B>>::Output;
+    assert_eq!(<N2CmpP4 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Add_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2AddP5 = <<A as Add<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<N2AddP5 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Sub_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2SubP5 = <<A as Sub<B>>::Output as Same<N7>>::Output;
+
+    assert_eq!(<N2SubP5 as Integer>::to_i64(), <N7 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Mul_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MulP5 = <<A as Mul<B>>::Output as Same<N10>>::Output;
+
+    assert_eq!(<N2MulP5 as Integer>::to_i64(), <N10 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Min_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MinP5 = <<A as Min<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2MinP5 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Max_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<N2MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Gcd_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N2GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Div_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N2DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N2DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Rem_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2RemP5 = <<A as Rem<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N2RemP5 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Pow_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N32 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N2PowP5 = <<A as Pow<B>>::Output as Same<N32>>::Output;
+
+    assert_eq!(<N2PowP5 as Integer>::to_i64(), <N32 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Cmp_P5() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N2CmpP5 = <A as Cmp<B>>::Output;
+    assert_eq!(<N2CmpP5 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Add_N5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1AddN5 = <<A as Add<B>>::Output as Same<N6>>::Output;
+
+    assert_eq!(<N1AddN5 as Integer>::to_i64(), <N6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Sub_N5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1SubN5 = <<A as Sub<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<N1SubN5 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Mul_N5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MulN5 = <<A as Mul<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<N1MulN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Min_N5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N1MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Max_N5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MaxN5 = <<A as Max<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1MaxN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Gcd_N5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Div_N5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N1DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N1DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Rem_N5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1RemN5 = <<A as Rem<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1RemN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Pow_N5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1PowN5 = <<A as Pow<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1PowN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Cmp_N5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1CmpN5 = <A as Cmp<B>>::Output;
+    assert_eq!(<N1CmpN5 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Add_N4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1AddN4 = <<A as Add<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N1AddN4 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Sub_N4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1SubN4 = <<A as Sub<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<N1SubN4 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Mul_N4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MulN4 = <<A as Mul<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<N1MulN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Min_N4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N1MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Max_N4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MaxN4 = <<A as Max<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1MaxN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Gcd_N4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Div_N4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N1DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N1DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Rem_N4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1RemN4 = <<A as Rem<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1RemN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Pow_N4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1PowN4 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1PowN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Cmp_N4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1CmpN4 = <A as Cmp<B>>::Output;
+    assert_eq!(<N1CmpN4 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Add_N3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1AddN3 = <<A as Add<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N1AddN3 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Sub_N3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1SubN3 = <<A as Sub<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N1SubN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Mul_N3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MulN3 = <<A as Mul<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<N1MulN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Min_N3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N1MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Max_N3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MaxN3 = <<A as Max<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1MaxN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Gcd_N3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Div_N3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N1DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N1DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Rem_N3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1RemN3 = <<A as Rem<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1RemN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Pow_N3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1PowN3 = <<A as Pow<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1PowN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Cmp_N3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1CmpN3 = <A as Cmp<B>>::Output;
+    assert_eq!(<N1CmpN3 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Add_N2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1AddN2 = <<A as Add<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N1AddN2 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Sub_N2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1SubN2 = <<A as Sub<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1SubN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Mul_N2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MulN2 = <<A as Mul<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N1MulN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Min_N2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N1MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Max_N2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MaxN2 = <<A as Max<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1MaxN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Gcd_N2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Div_N2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N1DivN2 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N1DivN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Rem_N2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1RemN2 = <<A as Rem<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1RemN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Pow_N2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1PowN2 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1PowN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Cmp_N2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1CmpN2 = <A as Cmp<B>>::Output;
+    assert_eq!(<N1CmpN2 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Add_N1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1AddN1 = <<A as Add<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N1AddN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Sub_N1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N1SubN1 = <<A as Sub<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N1SubN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Mul_N1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MulN1 = <<A as Mul<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1MulN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Min_N1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Max_N1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Gcd_N1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Div_N1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1DivN1 = <<A as Div<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1DivN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Rem_N1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N1RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N1RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_PartialDiv_N1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1PartialDivN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Pow_N1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1PowN1 = <<A as Pow<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1PowN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Cmp_N1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1CmpN1 = <A as Cmp<B>>::Output;
+    assert_eq!(<N1CmpN1 as Ord>::to_ordering(), Ordering::Equal);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Add__0() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = Z0;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1Add_0 = <<A as Add<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1Add_0 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Sub__0() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = Z0;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1Sub_0 = <<A as Sub<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1Sub_0 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Mul__0() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N1Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N1Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Min__0() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = Z0;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1Min_0 = <<A as Min<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1Min_0 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Max__0() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N1Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N1Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Gcd__0() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = Z0;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1Gcd_0 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1Gcd_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Pow__0() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = Z0;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Cmp__0() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N1Cmp_0 = <A as Cmp<B>>::Output;
+    assert_eq!(<N1Cmp_0 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Add_P1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N1AddP1 = <<A as Add<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N1AddP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Sub_P1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1SubP1 = <<A as Sub<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N1SubP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Mul_P1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MulP1 = <<A as Mul<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1MulP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Min_P1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MinP1 = <<A as Min<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1MinP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Max_P1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Gcd_P1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Div_P1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1DivP1 = <<A as Div<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1DivP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Rem_P1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N1RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N1RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_PartialDiv_P1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1PartialDivP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Pow_P1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1PowP1 = <<A as Pow<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1PowP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Cmp_P1() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1CmpP1 = <A as Cmp<B>>::Output;
+    assert_eq!(<N1CmpP1 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Add_P2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1AddP2 = <<A as Add<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1AddP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Sub_P2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1SubP2 = <<A as Sub<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N1SubP2 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Mul_P2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MulP2 = <<A as Mul<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<N1MulP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Min_P2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MinP2 = <<A as Min<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1MinP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Max_P2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N1MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Gcd_P2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Div_P2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N1DivP2 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N1DivP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Rem_P2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1RemP2 = <<A as Rem<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1RemP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Pow_P2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1PowP2 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1PowP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Cmp_P2() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1CmpP2 = <A as Cmp<B>>::Output;
+    assert_eq!(<N1CmpP2 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Add_P3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1AddP3 = <<A as Add<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<N1AddP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Sub_P3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1SubP3 = <<A as Sub<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N1SubP3 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Mul_P3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MulP3 = <<A as Mul<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<N1MulP3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Min_P3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MinP3 = <<A as Min<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1MinP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Max_P3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<N1MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Gcd_P3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Div_P3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N1DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N1DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Rem_P3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1RemP3 = <<A as Rem<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1RemP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Pow_P3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1PowP3 = <<A as Pow<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1PowP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Cmp_P3() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1CmpP3 = <A as Cmp<B>>::Output;
+    assert_eq!(<N1CmpP3 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Add_P4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1AddP4 = <<A as Add<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<N1AddP4 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Sub_P4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1SubP4 = <<A as Sub<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N1SubP4 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Mul_P4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MulP4 = <<A as Mul<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<N1MulP4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Min_P4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MinP4 = <<A as Min<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1MinP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Max_P4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<N1MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Gcd_P4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Div_P4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N1DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N1DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Rem_P4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1RemP4 = <<A as Rem<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1RemP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Pow_P4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1PowP4 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1PowP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Cmp_P4() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1CmpP4 = <A as Cmp<B>>::Output;
+    assert_eq!(<N1CmpP4 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Add_P5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1AddP5 = <<A as Add<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<N1AddP5 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Sub_P5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type N1SubP5 = <<A as Sub<B>>::Output as Same<N6>>::Output;
+
+    assert_eq!(<N1SubP5 as Integer>::to_i64(), <N6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Mul_P5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MulP5 = <<A as Mul<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<N1MulP5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Min_P5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MinP5 = <<A as Min<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1MinP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Max_P5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<N1MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Gcd_P5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<N1GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Div_P5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type N1DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<N1DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Rem_P5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1RemP5 = <<A as Rem<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1RemP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Pow_P5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1PowP5 = <<A as Pow<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<N1PowP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Cmp_P5() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type N1CmpP5 = <A as Cmp<B>>::Output;
+    assert_eq!(<N1CmpP5 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Add_N5() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0AddN5 = <<A as Add<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<_0AddN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Sub_N5() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0SubN5 = <<A as Sub<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<_0SubN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Mul_N5() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MulN5 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MulN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Min_N5() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<_0MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Max_N5() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MaxN5 = <<A as Max<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MaxN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Gcd_N5() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0GcdN5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<_0GcdN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Div_N5() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Rem_N5() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0RemN5 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0RemN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_PartialDiv_N5() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0PartialDivN5 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0PartialDivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Cmp_N5() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0CmpN5 = <A as Cmp<B>>::Output;
+    assert_eq!(<_0CmpN5 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Add_N4() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0AddN4 = <<A as Add<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<_0AddN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Sub_N4() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0SubN4 = <<A as Sub<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<_0SubN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Mul_N4() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MulN4 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MulN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Min_N4() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<_0MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Max_N4() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MaxN4 = <<A as Max<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MaxN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Gcd_N4() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0GcdN4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<_0GcdN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Div_N4() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Rem_N4() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0RemN4 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0RemN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_PartialDiv_N4() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0PartialDivN4 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0PartialDivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Cmp_N4() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0CmpN4 = <A as Cmp<B>>::Output;
+    assert_eq!(<_0CmpN4 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Add_N3() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0AddN3 = <<A as Add<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<_0AddN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Sub_N3() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0SubN3 = <<A as Sub<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<_0SubN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Mul_N3() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MulN3 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MulN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Min_N3() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<_0MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Max_N3() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MaxN3 = <<A as Max<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MaxN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Gcd_N3() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0GcdN3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<_0GcdN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Div_N3() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Rem_N3() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0RemN3 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0RemN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_PartialDiv_N3() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0PartialDivN3 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0PartialDivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Cmp_N3() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0CmpN3 = <A as Cmp<B>>::Output;
+    assert_eq!(<_0CmpN3 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Add_N2() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0AddN2 = <<A as Add<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<_0AddN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Sub_N2() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0SubN2 = <<A as Sub<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<_0SubN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Mul_N2() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MulN2 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MulN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Min_N2() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<_0MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Max_N2() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MaxN2 = <<A as Max<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MaxN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Gcd_N2() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<_0GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Div_N2() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0DivN2 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0DivN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Rem_N2() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_PartialDiv_N2() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0PartialDivN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Cmp_N2() {
+    type A = Z0;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0CmpN2 = <A as Cmp<B>>::Output;
+    assert_eq!(<_0CmpN2 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Add_N1() {
+    type A = Z0;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0AddN1 = <<A as Add<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<_0AddN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Sub_N1() {
+    type A = Z0;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0SubN1 = <<A as Sub<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<_0SubN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Mul_N1() {
+    type A = Z0;
+    type B = NInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MulN1 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MulN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Min_N1() {
+    type A = Z0;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<_0MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Max_N1() {
+    type A = Z0;
+    type B = NInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MaxN1 = <<A as Max<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MaxN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Gcd_N1() {
+    type A = Z0;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<_0GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Div_N1() {
+    type A = Z0;
+    type B = NInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0DivN1 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0DivN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Rem_N1() {
+    type A = Z0;
+    type B = NInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_PartialDiv_N1() {
+    type A = Z0;
+    type B = NInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0PartialDivN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Cmp_N1() {
+    type A = Z0;
+    type B = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0CmpN1 = <A as Cmp<B>>::Output;
+    assert_eq!(<_0CmpN1 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Add__0() {
+    type A = Z0;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0Add_0 = <<A as Add<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0Add_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Sub__0() {
+    type A = Z0;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0Sub_0 = <<A as Sub<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0Sub_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Mul__0() {
+    type A = Z0;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Min__0() {
+    type A = Z0;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Max__0() {
+    type A = Z0;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Gcd__0() {
+    type A = Z0;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0Gcd_0 = <<A as Gcd<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0Gcd_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Pow__0() {
+    type A = Z0;
+    type B = Z0;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<_0Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Cmp__0() {
+    type A = Z0;
+    type B = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0Cmp_0 = <A as Cmp<B>>::Output;
+    assert_eq!(<_0Cmp_0 as Ord>::to_ordering(), Ordering::Equal);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Add_P1() {
+    type A = Z0;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0AddP1 = <<A as Add<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<_0AddP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Sub_P1() {
+    type A = Z0;
+    type B = PInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0SubP1 = <<A as Sub<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<_0SubP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Mul_P1() {
+    type A = Z0;
+    type B = PInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MulP1 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MulP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Min_P1() {
+    type A = Z0;
+    type B = PInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MinP1 = <<A as Min<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MinP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Max_P1() {
+    type A = Z0;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<_0MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Gcd_P1() {
+    type A = Z0;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<_0GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Div_P1() {
+    type A = Z0;
+    type B = PInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0DivP1 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0DivP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Rem_P1() {
+    type A = Z0;
+    type B = PInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_PartialDiv_P1() {
+    type A = Z0;
+    type B = PInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0PartialDivP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Pow_P1() {
+    type A = Z0;
+    type B = PInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0PowP1 = <<A as Pow<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0PowP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Cmp_P1() {
+    type A = Z0;
+    type B = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0CmpP1 = <A as Cmp<B>>::Output;
+    assert_eq!(<_0CmpP1 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Add_P2() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0AddP2 = <<A as Add<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<_0AddP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Sub_P2() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0SubP2 = <<A as Sub<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<_0SubP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Mul_P2() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MulP2 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MulP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Min_P2() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MinP2 = <<A as Min<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MinP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Max_P2() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<_0MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Gcd_P2() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<_0GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Div_P2() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0DivP2 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0DivP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Rem_P2() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_PartialDiv_P2() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0PartialDivP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Pow_P2() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0PowP2 = <<A as Pow<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0PowP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Cmp_P2() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0CmpP2 = <A as Cmp<B>>::Output;
+    assert_eq!(<_0CmpP2 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Add_P3() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0AddP3 = <<A as Add<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<_0AddP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Sub_P3() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0SubP3 = <<A as Sub<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<_0SubP3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Mul_P3() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MulP3 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MulP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Min_P3() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MinP3 = <<A as Min<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MinP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Max_P3() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<_0MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Gcd_P3() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0GcdP3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<_0GcdP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Div_P3() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Rem_P3() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0RemP3 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0RemP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_PartialDiv_P3() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0PartialDivP3 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0PartialDivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Pow_P3() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0PowP3 = <<A as Pow<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0PowP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Cmp_P3() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0CmpP3 = <A as Cmp<B>>::Output;
+    assert_eq!(<_0CmpP3 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Add_P4() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0AddP4 = <<A as Add<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<_0AddP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Sub_P4() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0SubP4 = <<A as Sub<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<_0SubP4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Mul_P4() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MulP4 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MulP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Min_P4() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MinP4 = <<A as Min<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MinP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Max_P4() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<_0MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Gcd_P4() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0GcdP4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<_0GcdP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Div_P4() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Rem_P4() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0RemP4 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0RemP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_PartialDiv_P4() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0PartialDivP4 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0PartialDivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Pow_P4() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0PowP4 = <<A as Pow<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0PowP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Cmp_P4() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type _0CmpP4 = <A as Cmp<B>>::Output;
+    assert_eq!(<_0CmpP4 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Add_P5() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0AddP5 = <<A as Add<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<_0AddP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Sub_P5() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0SubP5 = <<A as Sub<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<_0SubP5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Mul_P5() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MulP5 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MulP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Min_P5() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0MinP5 = <<A as Min<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0MinP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Max_P5() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<_0MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Gcd_P5() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0GcdP5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<_0GcdP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Div_P5() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Rem_P5() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0RemP5 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0RemP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_PartialDiv_P5() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0PartialDivP5 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0PartialDivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Pow_P5() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type _0PowP5 = <<A as Pow<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<_0PowP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Cmp_P5() {
+    type A = Z0;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type _0CmpP5 = <A as Cmp<B>>::Output;
+    assert_eq!(<_0CmpP5 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Add_N5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1AddN5 = <<A as Add<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<P1AddN5 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Sub_N5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1SubN5 = <<A as Sub<B>>::Output as Same<P6>>::Output;
+
+    assert_eq!(<P1SubN5 as Integer>::to_i64(), <P6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Mul_N5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MulN5 = <<A as Mul<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<P1MulN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Min_N5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<P1MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Max_N5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MaxN5 = <<A as Max<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1MaxN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Gcd_N5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Div_N5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P1DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P1DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Rem_N5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1RemN5 = <<A as Rem<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1RemN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Pow_N5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1PowN5 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1PowN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Cmp_N5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1CmpN5 = <A as Cmp<B>>::Output;
+    assert_eq!(<P1CmpN5 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Add_N4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1AddN4 = <<A as Add<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<P1AddN4 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Sub_N4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1SubN4 = <<A as Sub<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P1SubN4 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Mul_N4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MulN4 = <<A as Mul<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<P1MulN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Min_N4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<P1MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Max_N4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MaxN4 = <<A as Max<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1MaxN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Gcd_N4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Div_N4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P1DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P1DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Rem_N4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1RemN4 = <<A as Rem<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1RemN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Pow_N4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1PowN4 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1PowN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Cmp_N4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1CmpN4 = <A as Cmp<B>>::Output;
+    assert_eq!(<P1CmpN4 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Add_N3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1AddN3 = <<A as Add<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<P1AddN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Sub_N3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1SubN3 = <<A as Sub<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P1SubN3 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Mul_N3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MulN3 = <<A as Mul<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<P1MulN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Min_N3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<P1MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Max_N3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MaxN3 = <<A as Max<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1MaxN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Gcd_N3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Div_N3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P1DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P1DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Rem_N3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1RemN3 = <<A as Rem<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1RemN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Pow_N3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1PowN3 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1PowN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Cmp_N3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1CmpN3 = <A as Cmp<B>>::Output;
+    assert_eq!(<P1CmpN3 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Add_N2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1AddN2 = <<A as Add<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P1AddN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Sub_N2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1SubN2 = <<A as Sub<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P1SubN2 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Mul_N2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MulN2 = <<A as Mul<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<P1MulN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Min_N2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<P1MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Max_N2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MaxN2 = <<A as Max<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1MaxN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Gcd_N2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Div_N2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P1DivN2 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P1DivN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Rem_N2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1RemN2 = <<A as Rem<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1RemN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Pow_N2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1PowN2 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1PowN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Cmp_N2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1CmpN2 = <A as Cmp<B>>::Output;
+    assert_eq!(<P1CmpN2 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Add_N1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P1AddN1 = <<A as Add<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P1AddN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Sub_N1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1SubN1 = <<A as Sub<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P1SubN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Mul_N1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MulN1 = <<A as Mul<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P1MulN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Min_N1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P1MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Max_N1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MaxN1 = <<A as Max<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1MaxN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Gcd_N1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Div_N1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1DivN1 = <<A as Div<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P1DivN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Rem_N1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P1RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P1RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_PartialDiv_N1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P1PartialDivN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Pow_N1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1PowN1 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1PowN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Cmp_N1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1CmpN1 = <A as Cmp<B>>::Output;
+    assert_eq!(<P1CmpN1 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Add__0() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = Z0;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1Add_0 = <<A as Add<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1Add_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Sub__0() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = Z0;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1Sub_0 = <<A as Sub<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1Sub_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Mul__0() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P1Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P1Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Min__0() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P1Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P1Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Max__0() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = Z0;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1Max_0 = <<A as Max<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1Max_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Gcd__0() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = Z0;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1Gcd_0 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1Gcd_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Pow__0() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = Z0;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Cmp__0() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P1Cmp_0 = <A as Cmp<B>>::Output;
+    assert_eq!(<P1Cmp_0 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Add_P1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1AddP1 = <<A as Add<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P1AddP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Sub_P1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P1SubP1 = <<A as Sub<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P1SubP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Mul_P1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MulP1 = <<A as Mul<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1MulP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Min_P1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Max_P1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Gcd_P1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Div_P1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1DivP1 = <<A as Div<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1DivP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Rem_P1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P1RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P1RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_PartialDiv_P1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1PartialDivP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Pow_P1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1PowP1 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1PowP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Cmp_P1() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1CmpP1 = <A as Cmp<B>>::Output;
+    assert_eq!(<P1CmpP1 as Ord>::to_ordering(), Ordering::Equal);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Add_P2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1AddP2 = <<A as Add<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P1AddP2 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Sub_P2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1SubP2 = <<A as Sub<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P1SubP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Mul_P2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MulP2 = <<A as Mul<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P1MulP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Min_P2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MinP2 = <<A as Min<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1MinP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Max_P2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P1MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Gcd_P2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Div_P2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P1DivP2 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P1DivP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Rem_P2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1RemP2 = <<A as Rem<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1RemP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Pow_P2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1PowP2 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1PowP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Cmp_P2() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1CmpP2 = <A as Cmp<B>>::Output;
+    assert_eq!(<P1CmpP2 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Add_P3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1AddP3 = <<A as Add<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P1AddP3 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Sub_P3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1SubP3 = <<A as Sub<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<P1SubP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Mul_P3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MulP3 = <<A as Mul<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P1MulP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Min_P3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MinP3 = <<A as Min<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1MinP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Max_P3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P1MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Gcd_P3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Div_P3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P1DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P1DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Rem_P3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1RemP3 = <<A as Rem<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1RemP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Pow_P3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1PowP3 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1PowP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Cmp_P3() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1CmpP3 = <A as Cmp<B>>::Output;
+    assert_eq!(<P1CmpP3 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Add_P4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1AddP4 = <<A as Add<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P1AddP4 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Sub_P4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1SubP4 = <<A as Sub<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<P1SubP4 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Mul_P4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MulP4 = <<A as Mul<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P1MulP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Min_P4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MinP4 = <<A as Min<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1MinP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Max_P4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P1MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Gcd_P4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Div_P4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P1DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P1DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Rem_P4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1RemP4 = <<A as Rem<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1RemP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Pow_P4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1PowP4 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1PowP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Cmp_P4() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1CmpP4 = <A as Cmp<B>>::Output;
+    assert_eq!(<P1CmpP4 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Add_P5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1AddP5 = <<A as Add<B>>::Output as Same<P6>>::Output;
+
+    assert_eq!(<P1AddP5 as Integer>::to_i64(), <P6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Sub_P5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P1SubP5 = <<A as Sub<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<P1SubP5 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Mul_P5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MulP5 = <<A as Mul<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P1MulP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Min_P5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MinP5 = <<A as Min<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1MinP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Max_P5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P1MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Gcd_P5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Div_P5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P1DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P1DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Rem_P5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1RemP5 = <<A as Rem<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1RemP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Pow_P5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1PowP5 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P1PowP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Cmp_P5() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P1CmpP5 = <A as Cmp<B>>::Output;
+    assert_eq!(<P1CmpP5 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Add_N5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2AddN5 = <<A as Add<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<P2AddN5 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Sub_N5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2SubN5 = <<A as Sub<B>>::Output as Same<P7>>::Output;
+
+    assert_eq!(<P2SubN5 as Integer>::to_i64(), <P7 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Mul_N5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MulN5 = <<A as Mul<B>>::Output as Same<N10>>::Output;
+
+    assert_eq!(<P2MulN5 as Integer>::to_i64(), <N10 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Min_N5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<P2MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Max_N5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MaxN5 = <<A as Max<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2MaxN5 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Gcd_N5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P2GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Div_N5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P2DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P2DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Rem_N5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2RemN5 = <<A as Rem<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2RemN5 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Cmp_N5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2CmpN5 = <A as Cmp<B>>::Output;
+    assert_eq!(<P2CmpN5 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Add_N4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2AddN4 = <<A as Add<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<P2AddN4 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Sub_N4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2SubN4 = <<A as Sub<B>>::Output as Same<P6>>::Output;
+
+    assert_eq!(<P2SubN4 as Integer>::to_i64(), <P6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Mul_N4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MulN4 = <<A as Mul<B>>::Output as Same<N8>>::Output;
+
+    assert_eq!(<P2MulN4 as Integer>::to_i64(), <N8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Min_N4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<P2MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Max_N4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MaxN4 = <<A as Max<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2MaxN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Gcd_N4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2GcdN4 = <<A as Gcd<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2GcdN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Div_N4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P2DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P2DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Rem_N4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2RemN4 = <<A as Rem<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2RemN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Cmp_N4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2CmpN4 = <A as Cmp<B>>::Output;
+    assert_eq!(<P2CmpN4 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Add_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2AddN3 = <<A as Add<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P2AddN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Sub_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2SubN3 = <<A as Sub<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P2SubN3 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Mul_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MulN3 = <<A as Mul<B>>::Output as Same<N6>>::Output;
+
+    assert_eq!(<P2MulN3 as Integer>::to_i64(), <N6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Min_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<P2MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Max_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MaxN3 = <<A as Max<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2MaxN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Gcd_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P2GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Div_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P2DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P2DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Rem_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2RemN3 = <<A as Rem<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2RemN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Cmp_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2CmpN3 = <A as Cmp<B>>::Output;
+    assert_eq!(<P2CmpN3 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Add_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P2AddN2 = <<A as Add<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P2AddN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Sub_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2SubN2 = <<A as Sub<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P2SubN2 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Mul_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MulN2 = <<A as Mul<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<P2MulN2 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Min_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<P2MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Max_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MaxN2 = <<A as Max<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2MaxN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Gcd_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Div_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2DivN2 = <<A as Div<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P2DivN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Rem_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P2RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P2RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_PartialDiv_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P2PartialDivN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Cmp_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2CmpN2 = <A as Cmp<B>>::Output;
+    assert_eq!(<P2CmpN2 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Add_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2AddN1 = <<A as Add<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P2AddN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Sub_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2SubN1 = <<A as Sub<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P2SubN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Mul_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MulN1 = <<A as Mul<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<P2MulN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Min_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P2MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Max_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MaxN1 = <<A as Max<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2MaxN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Gcd_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P2GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Div_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2DivN1 = <<A as Div<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<P2DivN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Rem_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P2RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P2RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_PartialDiv_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<P2PartialDivN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Cmp_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2CmpN1 = <A as Cmp<B>>::Output;
+    assert_eq!(<P2CmpN1 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Add__0() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = Z0;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2Add_0 = <<A as Add<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2Add_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Sub__0() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = Z0;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2Sub_0 = <<A as Sub<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2Sub_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Mul__0() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P2Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P2Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Min__0() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P2Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P2Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Max__0() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = Z0;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2Max_0 = <<A as Max<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2Max_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Gcd__0() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = Z0;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2Gcd_0 = <<A as Gcd<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2Gcd_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Pow__0() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = Z0;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P2Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Cmp__0() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P2Cmp_0 = <A as Cmp<B>>::Output;
+    assert_eq!(<P2Cmp_0 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Add_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2AddP1 = <<A as Add<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P2AddP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Sub_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2SubP1 = <<A as Sub<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P2SubP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Mul_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MulP1 = <<A as Mul<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2MulP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Min_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P2MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Max_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MaxP1 = <<A as Max<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2MaxP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Gcd_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P2GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Div_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2DivP1 = <<A as Div<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2DivP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Rem_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P2RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P2RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_PartialDiv_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2PartialDivP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Pow_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2PowP1 = <<A as Pow<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2PowP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Cmp_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2CmpP1 = <A as Cmp<B>>::Output;
+    assert_eq!(<P2CmpP1 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Add_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2AddP2 = <<A as Add<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P2AddP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Sub_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P2SubP2 = <<A as Sub<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P2SubP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Mul_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MulP2 = <<A as Mul<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P2MulP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Min_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MinP2 = <<A as Min<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2MinP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Max_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Gcd_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Div_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2DivP2 = <<A as Div<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P2DivP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Rem_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P2RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P2RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_PartialDiv_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P2PartialDivP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Pow_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2PowP2 = <<A as Pow<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P2PowP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Cmp_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2CmpP2 = <A as Cmp<B>>::Output;
+    assert_eq!(<P2CmpP2 as Ord>::to_ordering(), Ordering::Equal);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Add_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2AddP3 = <<A as Add<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P2AddP3 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Sub_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2SubP3 = <<A as Sub<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P2SubP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Mul_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MulP3 = <<A as Mul<B>>::Output as Same<P6>>::Output;
+
+    assert_eq!(<P2MulP3 as Integer>::to_i64(), <P6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Min_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MinP3 = <<A as Min<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2MinP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Max_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P2MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Gcd_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P2GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Div_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P2DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P2DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Rem_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2RemP3 = <<A as Rem<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2RemP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Pow_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2PowP3 = <<A as Pow<B>>::Output as Same<P8>>::Output;
+
+    assert_eq!(<P2PowP3 as Integer>::to_i64(), <P8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Cmp_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2CmpP3 = <A as Cmp<B>>::Output;
+    assert_eq!(<P2CmpP3 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Add_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2AddP4 = <<A as Add<B>>::Output as Same<P6>>::Output;
+
+    assert_eq!(<P2AddP4 as Integer>::to_i64(), <P6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Sub_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2SubP4 = <<A as Sub<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<P2SubP4 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Mul_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MulP4 = <<A as Mul<B>>::Output as Same<P8>>::Output;
+
+    assert_eq!(<P2MulP4 as Integer>::to_i64(), <P8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Min_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MinP4 = <<A as Min<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2MinP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Max_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P2MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Gcd_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2GcdP4 = <<A as Gcd<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2GcdP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Div_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P2DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P2DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Rem_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2RemP4 = <<A as Rem<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2RemP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Pow_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2PowP4 = <<A as Pow<B>>::Output as Same<P16>>::Output;
+
+    assert_eq!(<P2PowP4 as Integer>::to_i64(), <P16 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Cmp_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2CmpP4 = <A as Cmp<B>>::Output;
+    assert_eq!(<P2CmpP4 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Add_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2AddP5 = <<A as Add<B>>::Output as Same<P7>>::Output;
+
+    assert_eq!(<P2AddP5 as Integer>::to_i64(), <P7 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Sub_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2SubP5 = <<A as Sub<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<P2SubP5 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Mul_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MulP5 = <<A as Mul<B>>::Output as Same<P10>>::Output;
+
+    assert_eq!(<P2MulP5 as Integer>::to_i64(), <P10 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Min_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MinP5 = <<A as Min<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2MinP5 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Max_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P2MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Gcd_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P2GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Div_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P2DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P2DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Rem_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2RemP5 = <<A as Rem<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P2RemP5 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Pow_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P32 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P2PowP5 = <<A as Pow<B>>::Output as Same<P32>>::Output;
+
+    assert_eq!(<P2PowP5 as Integer>::to_i64(), <P32 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Cmp_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P2CmpP5 = <A as Cmp<B>>::Output;
+    assert_eq!(<P2CmpP5 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Add_N5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3AddN5 = <<A as Add<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<P3AddN5 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Sub_N5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3SubN5 = <<A as Sub<B>>::Output as Same<P8>>::Output;
+
+    assert_eq!(<P3SubN5 as Integer>::to_i64(), <P8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Mul_N5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N15 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MulN5 = <<A as Mul<B>>::Output as Same<N15>>::Output;
+
+    assert_eq!(<P3MulN5 as Integer>::to_i64(), <N15 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Min_N5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<P3MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Max_N5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MaxN5 = <<A as Max<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3MaxN5 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Gcd_N5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P3GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Div_N5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P3DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P3DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Rem_N5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3RemN5 = <<A as Rem<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3RemN5 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Cmp_N5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3CmpN5 = <A as Cmp<B>>::Output;
+    assert_eq!(<P3CmpN5 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Add_N4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3AddN4 = <<A as Add<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P3AddN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Sub_N4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3SubN4 = <<A as Sub<B>>::Output as Same<P7>>::Output;
+
+    assert_eq!(<P3SubN4 as Integer>::to_i64(), <P7 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Mul_N4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N12 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MulN4 = <<A as Mul<B>>::Output as Same<N12>>::Output;
+
+    assert_eq!(<P3MulN4 as Integer>::to_i64(), <N12 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Min_N4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<P3MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Max_N4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MaxN4 = <<A as Max<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3MaxN4 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Gcd_N4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P3GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Div_N4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P3DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P3DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Rem_N4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3RemN4 = <<A as Rem<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3RemN4 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Cmp_N4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3CmpN4 = <A as Cmp<B>>::Output;
+    assert_eq!(<P3CmpN4 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Add_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P3AddN3 = <<A as Add<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P3AddN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Sub_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3SubN3 = <<A as Sub<B>>::Output as Same<P6>>::Output;
+
+    assert_eq!(<P3SubN3 as Integer>::to_i64(), <P6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Mul_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MulN3 = <<A as Mul<B>>::Output as Same<N9>>::Output;
+
+    assert_eq!(<P3MulN3 as Integer>::to_i64(), <N9 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Min_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<P3MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Max_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MaxN3 = <<A as Max<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3MaxN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Gcd_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3GcdN3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3GcdN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Div_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3DivN3 = <<A as Div<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P3DivN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Rem_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P3RemN3 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P3RemN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_PartialDiv_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3PartialDivN3 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P3PartialDivN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Cmp_N3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3CmpN3 = <A as Cmp<B>>::Output;
+    assert_eq!(<P3CmpN3 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Add_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3AddN2 = <<A as Add<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P3AddN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Sub_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3SubN2 = <<A as Sub<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P3SubN2 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Mul_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MulN2 = <<A as Mul<B>>::Output as Same<N6>>::Output;
+
+    assert_eq!(<P3MulN2 as Integer>::to_i64(), <N6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Min_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<P3MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Max_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MaxN2 = <<A as Max<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3MaxN2 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Gcd_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P3GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Div_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3DivN2 = <<A as Div<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P3DivN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Rem_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3RemN2 = <<A as Rem<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P3RemN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Cmp_N2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3CmpN2 = <A as Cmp<B>>::Output;
+    assert_eq!(<P3CmpN2 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Add_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3AddN1 = <<A as Add<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P3AddN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Sub_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3SubN1 = <<A as Sub<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P3SubN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Mul_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MulN1 = <<A as Mul<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<P3MulN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Min_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P3MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Max_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MaxN1 = <<A as Max<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3MaxN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Gcd_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P3GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Div_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3DivN1 = <<A as Div<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<P3DivN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Rem_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P3RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P3RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_PartialDiv_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<P3PartialDivN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Cmp_N1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3CmpN1 = <A as Cmp<B>>::Output;
+    assert_eq!(<P3CmpN1 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Add__0() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = Z0;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3Add_0 = <<A as Add<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3Add_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Sub__0() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = Z0;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3Sub_0 = <<A as Sub<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3Sub_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Mul__0() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P3Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P3Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Min__0() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P3Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P3Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Max__0() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = Z0;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3Max_0 = <<A as Max<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3Max_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Gcd__0() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = Z0;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3Gcd_0 = <<A as Gcd<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3Gcd_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Pow__0() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = Z0;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P3Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Cmp__0() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P3Cmp_0 = <A as Cmp<B>>::Output;
+    assert_eq!(<P3Cmp_0 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Add_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3AddP1 = <<A as Add<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P3AddP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Sub_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3SubP1 = <<A as Sub<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P3SubP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Mul_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MulP1 = <<A as Mul<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3MulP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Min_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P3MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Max_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MaxP1 = <<A as Max<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3MaxP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Gcd_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P3GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Div_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3DivP1 = <<A as Div<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3DivP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Rem_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P3RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P3RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_PartialDiv_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3PartialDivP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Pow_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3PowP1 = <<A as Pow<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3PowP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Cmp_P1() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3CmpP1 = <A as Cmp<B>>::Output;
+    assert_eq!(<P3CmpP1 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Add_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3AddP2 = <<A as Add<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P3AddP2 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Sub_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3SubP2 = <<A as Sub<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P3SubP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Mul_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MulP2 = <<A as Mul<B>>::Output as Same<P6>>::Output;
+
+    assert_eq!(<P3MulP2 as Integer>::to_i64(), <P6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Min_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MinP2 = <<A as Min<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P3MinP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Max_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MaxP2 = <<A as Max<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3MaxP2 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Gcd_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P3GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Div_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3DivP2 = <<A as Div<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P3DivP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Rem_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3RemP2 = <<A as Rem<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P3RemP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Pow_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3PowP2 = <<A as Pow<B>>::Output as Same<P9>>::Output;
+
+    assert_eq!(<P3PowP2 as Integer>::to_i64(), <P9 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Cmp_P2() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3CmpP2 = <A as Cmp<B>>::Output;
+    assert_eq!(<P3CmpP2 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Add_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3AddP3 = <<A as Add<B>>::Output as Same<P6>>::Output;
+
+    assert_eq!(<P3AddP3 as Integer>::to_i64(), <P6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Sub_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P3SubP3 = <<A as Sub<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P3SubP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Mul_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MulP3 = <<A as Mul<B>>::Output as Same<P9>>::Output;
+
+    assert_eq!(<P3MulP3 as Integer>::to_i64(), <P9 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Min_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MinP3 = <<A as Min<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3MinP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Max_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Gcd_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3GcdP3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3GcdP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Div_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3DivP3 = <<A as Div<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P3DivP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Rem_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P3RemP3 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P3RemP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_PartialDiv_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3PartialDivP3 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P3PartialDivP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Pow_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P27 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3PowP3 = <<A as Pow<B>>::Output as Same<P27>>::Output;
+
+    assert_eq!(<P3PowP3 as Integer>::to_i64(), <P27 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Cmp_P3() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3CmpP3 = <A as Cmp<B>>::Output;
+    assert_eq!(<P3CmpP3 as Ord>::to_ordering(), Ordering::Equal);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Add_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3AddP4 = <<A as Add<B>>::Output as Same<P7>>::Output;
+
+    assert_eq!(<P3AddP4 as Integer>::to_i64(), <P7 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Sub_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3SubP4 = <<A as Sub<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P3SubP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Mul_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P12 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MulP4 = <<A as Mul<B>>::Output as Same<P12>>::Output;
+
+    assert_eq!(<P3MulP4 as Integer>::to_i64(), <P12 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Min_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MinP4 = <<A as Min<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3MinP4 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Max_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P3MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Gcd_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P3GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Div_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P3DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P3DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Rem_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3RemP4 = <<A as Rem<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3RemP4 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Pow_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P81 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3PowP4 = <<A as Pow<B>>::Output as Same<P81>>::Output;
+
+    assert_eq!(<P3PowP4 as Integer>::to_i64(), <P81 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Cmp_P4() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3CmpP4 = <A as Cmp<B>>::Output;
+    assert_eq!(<P3CmpP4 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Add_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3AddP5 = <<A as Add<B>>::Output as Same<P8>>::Output;
+
+    assert_eq!(<P3AddP5 as Integer>::to_i64(), <P8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Sub_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P3SubP5 = <<A as Sub<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<P3SubP5 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Mul_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P15 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MulP5 = <<A as Mul<B>>::Output as Same<P15>>::Output;
+
+    assert_eq!(<P3MulP5 as Integer>::to_i64(), <P15 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Min_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MinP5 = <<A as Min<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3MinP5 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Max_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P3MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Gcd_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P3GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Div_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P3DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P3DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Rem_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3RemP5 = <<A as Rem<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P3RemP5 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Pow_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P243 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3PowP5 = <<A as Pow<B>>::Output as Same<P243>>::Output;
+
+    assert_eq!(<P3PowP5 as Integer>::to_i64(), <P243 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Cmp_P5() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P3CmpP5 = <A as Cmp<B>>::Output;
+    assert_eq!(<P3CmpP5 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Add_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4AddN5 = <<A as Add<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P4AddN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Sub_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4SubN5 = <<A as Sub<B>>::Output as Same<P9>>::Output;
+
+    assert_eq!(<P4SubN5 as Integer>::to_i64(), <P9 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Mul_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N20 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MulN5 = <<A as Mul<B>>::Output as Same<N20>>::Output;
+
+    assert_eq!(<P4MulN5 as Integer>::to_i64(), <N20 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Min_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<P4MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Max_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MaxN5 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4MaxN5 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Gcd_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P4GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Div_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P4DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P4DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Rem_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4RemN5 = <<A as Rem<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4RemN5 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Cmp_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4CmpN5 = <A as Cmp<B>>::Output;
+    assert_eq!(<P4CmpN5 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Add_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P4AddN4 = <<A as Add<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P4AddN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Sub_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4SubN4 = <<A as Sub<B>>::Output as Same<P8>>::Output;
+
+    assert_eq!(<P4SubN4 as Integer>::to_i64(), <P8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Mul_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N16 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MulN4 = <<A as Mul<B>>::Output as Same<N16>>::Output;
+
+    assert_eq!(<P4MulN4 as Integer>::to_i64(), <N16 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Min_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<P4MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Max_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MaxN4 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4MaxN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Gcd_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4GcdN4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4GcdN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Div_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4DivN4 = <<A as Div<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P4DivN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Rem_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P4RemN4 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P4RemN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_PartialDiv_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4PartialDivN4 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P4PartialDivN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Cmp_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4CmpN4 = <A as Cmp<B>>::Output;
+    assert_eq!(<P4CmpN4 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Add_N3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4AddN3 = <<A as Add<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P4AddN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Sub_N3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4SubN3 = <<A as Sub<B>>::Output as Same<P7>>::Output;
+
+    assert_eq!(<P4SubN3 as Integer>::to_i64(), <P7 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Mul_N3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N12 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MulN3 = <<A as Mul<B>>::Output as Same<N12>>::Output;
+
+    assert_eq!(<P4MulN3 as Integer>::to_i64(), <N12 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Min_N3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<P4MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Max_N3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MaxN3 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4MaxN3 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Gcd_N3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P4GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Div_N3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4DivN3 = <<A as Div<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P4DivN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Rem_N3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4RemN3 = <<A as Rem<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P4RemN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Cmp_N3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4CmpN3 = <A as Cmp<B>>::Output;
+    assert_eq!(<P4CmpN3 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Add_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4AddN2 = <<A as Add<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P4AddN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Sub_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4SubN2 = <<A as Sub<B>>::Output as Same<P6>>::Output;
+
+    assert_eq!(<P4SubN2 as Integer>::to_i64(), <P6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Mul_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MulN2 = <<A as Mul<B>>::Output as Same<N8>>::Output;
+
+    assert_eq!(<P4MulN2 as Integer>::to_i64(), <N8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Min_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<P4MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Max_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MaxN2 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4MaxN2 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Gcd_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P4GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Div_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4DivN2 = <<A as Div<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<P4DivN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Rem_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P4RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P4RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_PartialDiv_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<P4PartialDivN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Cmp_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4CmpN2 = <A as Cmp<B>>::Output;
+    assert_eq!(<P4CmpN2 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Add_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4AddN1 = <<A as Add<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P4AddN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Sub_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4SubN1 = <<A as Sub<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P4SubN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Mul_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MulN1 = <<A as Mul<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<P4MulN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Min_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P4MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Max_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MaxN1 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4MaxN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Gcd_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P4GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Div_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4DivN1 = <<A as Div<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<P4DivN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Rem_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P4RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P4RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_PartialDiv_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<P4PartialDivN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Cmp_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4CmpN1 = <A as Cmp<B>>::Output;
+    assert_eq!(<P4CmpN1 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Add__0() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = Z0;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4Add_0 = <<A as Add<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4Add_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Sub__0() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = Z0;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4Sub_0 = <<A as Sub<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4Sub_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Mul__0() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P4Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P4Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Min__0() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P4Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P4Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Max__0() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = Z0;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4Max_0 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4Max_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Gcd__0() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = Z0;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4Gcd_0 = <<A as Gcd<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4Gcd_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Pow__0() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = Z0;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P4Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Cmp__0() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P4Cmp_0 = <A as Cmp<B>>::Output;
+    assert_eq!(<P4Cmp_0 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Add_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4AddP1 = <<A as Add<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P4AddP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Sub_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4SubP1 = <<A as Sub<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P4SubP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Mul_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MulP1 = <<A as Mul<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4MulP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Min_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P4MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Max_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MaxP1 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4MaxP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Gcd_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P4GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Div_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4DivP1 = <<A as Div<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4DivP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Rem_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P4RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P4RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_PartialDiv_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4PartialDivP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Pow_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4PowP1 = <<A as Pow<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4PowP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Cmp_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4CmpP1 = <A as Cmp<B>>::Output;
+    assert_eq!(<P4CmpP1 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Add_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4AddP2 = <<A as Add<B>>::Output as Same<P6>>::Output;
+
+    assert_eq!(<P4AddP2 as Integer>::to_i64(), <P6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Sub_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4SubP2 = <<A as Sub<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P4SubP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Mul_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MulP2 = <<A as Mul<B>>::Output as Same<P8>>::Output;
+
+    assert_eq!(<P4MulP2 as Integer>::to_i64(), <P8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Min_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MinP2 = <<A as Min<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P4MinP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Max_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MaxP2 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4MaxP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Gcd_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P4GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Div_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4DivP2 = <<A as Div<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P4DivP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Rem_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P4RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P4RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_PartialDiv_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P4PartialDivP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Pow_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4PowP2 = <<A as Pow<B>>::Output as Same<P16>>::Output;
+
+    assert_eq!(<P4PowP2 as Integer>::to_i64(), <P16 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Cmp_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4CmpP2 = <A as Cmp<B>>::Output;
+    assert_eq!(<P4CmpP2 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Add_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4AddP3 = <<A as Add<B>>::Output as Same<P7>>::Output;
+
+    assert_eq!(<P4AddP3 as Integer>::to_i64(), <P7 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Sub_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4SubP3 = <<A as Sub<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P4SubP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Mul_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P12 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MulP3 = <<A as Mul<B>>::Output as Same<P12>>::Output;
+
+    assert_eq!(<P4MulP3 as Integer>::to_i64(), <P12 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Min_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MinP3 = <<A as Min<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P4MinP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Max_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MaxP3 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4MaxP3 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Gcd_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P4GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Div_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4DivP3 = <<A as Div<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P4DivP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Rem_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4RemP3 = <<A as Rem<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P4RemP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Pow_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P64 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4PowP3 = <<A as Pow<B>>::Output as Same<P64>>::Output;
+
+    assert_eq!(<P4PowP3 as Integer>::to_i64(), <P64 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Cmp_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4CmpP3 = <A as Cmp<B>>::Output;
+    assert_eq!(<P4CmpP3 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Add_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4AddP4 = <<A as Add<B>>::Output as Same<P8>>::Output;
+
+    assert_eq!(<P4AddP4 as Integer>::to_i64(), <P8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Sub_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P4SubP4 = <<A as Sub<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P4SubP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Mul_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MulP4 = <<A as Mul<B>>::Output as Same<P16>>::Output;
+
+    assert_eq!(<P4MulP4 as Integer>::to_i64(), <P16 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Min_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MinP4 = <<A as Min<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4MinP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Max_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Gcd_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4GcdP4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4GcdP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Div_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4DivP4 = <<A as Div<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P4DivP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Rem_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P4RemP4 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P4RemP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_PartialDiv_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4PartialDivP4 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P4PartialDivP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Pow_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P256 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4PowP4 = <<A as Pow<B>>::Output as Same<P256>>::Output;
+
+    assert_eq!(<P4PowP4 as Integer>::to_i64(), <P256 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Cmp_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4CmpP4 = <A as Cmp<B>>::Output;
+    assert_eq!(<P4CmpP4 as Ord>::to_ordering(), Ordering::Equal);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Add_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4AddP5 = <<A as Add<B>>::Output as Same<P9>>::Output;
+
+    assert_eq!(<P4AddP5 as Integer>::to_i64(), <P9 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Sub_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4SubP5 = <<A as Sub<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P4SubP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Mul_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P20 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MulP5 = <<A as Mul<B>>::Output as Same<P20>>::Output;
+
+    assert_eq!(<P4MulP5 as Integer>::to_i64(), <P20 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Min_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MinP5 = <<A as Min<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4MinP5 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Max_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P4MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Gcd_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P4GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Div_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P4DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P4DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Rem_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4RemP5 = <<A as Rem<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P4RemP5 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Pow_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1024 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P4PowP5 = <<A as Pow<B>>::Output as Same<P1024>>::Output;
+
+    assert_eq!(<P4PowP5 as Integer>::to_i64(), <P1024 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Cmp_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P4CmpP5 = <A as Cmp<B>>::Output;
+    assert_eq!(<P4CmpP5 as Ord>::to_ordering(), Ordering::Less);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Add_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P5AddN5 = <<A as Add<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P5AddN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Sub_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5SubN5 = <<A as Sub<B>>::Output as Same<P10>>::Output;
+
+    assert_eq!(<P5SubN5 as Integer>::to_i64(), <P10 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Mul_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N25 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MulN5 = <<A as Mul<B>>::Output as Same<N25>>::Output;
+
+    assert_eq!(<P5MulN5 as Integer>::to_i64(), <N25 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Min_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<P5MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Max_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MaxN5 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5MaxN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Gcd_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5GcdN5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5GcdN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Div_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5DivN5 = <<A as Div<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P5DivN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Rem_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P5RemN5 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P5RemN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_PartialDiv_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5PartialDivN5 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P5PartialDivN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Cmp_N5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5CmpN5 = <A as Cmp<B>>::Output;
+    assert_eq!(<P5CmpN5 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Add_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5AddN4 = <<A as Add<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5AddN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Sub_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5SubN4 = <<A as Sub<B>>::Output as Same<P9>>::Output;
+
+    assert_eq!(<P5SubN4 as Integer>::to_i64(), <P9 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Mul_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N20 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MulN4 = <<A as Mul<B>>::Output as Same<N20>>::Output;
+
+    assert_eq!(<P5MulN4 as Integer>::to_i64(), <N20 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Min_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;
+
+    assert_eq!(<P5MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Max_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MaxN4 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5MaxN4 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Gcd_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Div_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5DivN4 = <<A as Div<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P5DivN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Rem_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5RemN4 = <<A as Rem<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5RemN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Cmp_N4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5CmpN4 = <A as Cmp<B>>::Output;
+    assert_eq!(<P5CmpN4 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Add_N3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5AddN3 = <<A as Add<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P5AddN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Sub_N3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5SubN3 = <<A as Sub<B>>::Output as Same<P8>>::Output;
+
+    assert_eq!(<P5SubN3 as Integer>::to_i64(), <P8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Mul_N3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N15 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MulN3 = <<A as Mul<B>>::Output as Same<N15>>::Output;
+
+    assert_eq!(<P5MulN3 as Integer>::to_i64(), <N15 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Min_N3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;
+
+    assert_eq!(<P5MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Max_N3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MaxN3 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5MaxN3 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Gcd_N3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Div_N3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5DivN3 = <<A as Div<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P5DivN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Rem_N3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5RemN3 = <<A as Rem<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P5RemN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Cmp_N3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5CmpN3 = <A as Cmp<B>>::Output;
+    assert_eq!(<P5CmpN3 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Add_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5AddN2 = <<A as Add<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P5AddN2 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Sub_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5SubN2 = <<A as Sub<B>>::Output as Same<P7>>::Output;
+
+    assert_eq!(<P5SubN2 as Integer>::to_i64(), <P7 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Mul_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MulN2 = <<A as Mul<B>>::Output as Same<N10>>::Output;
+
+    assert_eq!(<P5MulN2 as Integer>::to_i64(), <N10 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Min_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<P5MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Max_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MaxN2 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5MaxN2 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Gcd_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Div_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5DivN2 = <<A as Div<B>>::Output as Same<N2>>::Output;
+
+    assert_eq!(<P5DivN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Rem_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5RemN2 = <<A as Rem<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5RemN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Cmp_N2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5CmpN2 = <A as Cmp<B>>::Output;
+    assert_eq!(<P5CmpN2 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Add_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5AddN1 = <<A as Add<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P5AddN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Sub_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5SubN1 = <<A as Sub<B>>::Output as Same<P6>>::Output;
+
+    assert_eq!(<P5SubN1 as Integer>::to_i64(), <P6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Mul_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MulN1 = <<A as Mul<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<P5MulN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Min_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;
+
+    assert_eq!(<P5MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Max_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MaxN1 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5MaxN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Gcd_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Div_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5DivN1 = <<A as Div<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<P5DivN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Rem_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P5RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P5RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_PartialDiv_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N5>>::Output;
+
+    assert_eq!(<P5PartialDivN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Cmp_N1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5CmpN1 = <A as Cmp<B>>::Output;
+    assert_eq!(<P5CmpN1 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Add__0() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = Z0;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5Add_0 = <<A as Add<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5Add_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Sub__0() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = Z0;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5Sub_0 = <<A as Sub<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5Sub_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Mul__0() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P5Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P5Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Min__0() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P5Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P5Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Max__0() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = Z0;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5Max_0 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5Max_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Gcd__0() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = Z0;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5Gcd_0 = <<A as Gcd<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5Gcd_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Pow__0() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = Z0;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Cmp__0() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P5Cmp_0 = <A as Cmp<B>>::Output;
+    assert_eq!(<P5Cmp_0 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Add_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5AddP1 = <<A as Add<B>>::Output as Same<P6>>::Output;
+
+    assert_eq!(<P5AddP1 as Integer>::to_i64(), <P6 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Sub_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5SubP1 = <<A as Sub<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P5SubP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Mul_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MulP1 = <<A as Mul<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5MulP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Min_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Max_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MaxP1 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5MaxP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Gcd_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Div_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5DivP1 = <<A as Div<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5DivP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Rem_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P5RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P5RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_PartialDiv_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5PartialDivP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Pow_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5PowP1 = <<A as Pow<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5PowP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Cmp_P1() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5CmpP1 = <A as Cmp<B>>::Output;
+    assert_eq!(<P5CmpP1 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Add_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5AddP2 = <<A as Add<B>>::Output as Same<P7>>::Output;
+
+    assert_eq!(<P5AddP2 as Integer>::to_i64(), <P7 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Sub_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5SubP2 = <<A as Sub<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P5SubP2 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Mul_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MulP2 = <<A as Mul<B>>::Output as Same<P10>>::Output;
+
+    assert_eq!(<P5MulP2 as Integer>::to_i64(), <P10 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Min_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MinP2 = <<A as Min<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P5MinP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Max_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MaxP2 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5MaxP2 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Gcd_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Div_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5DivP2 = <<A as Div<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P5DivP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Rem_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5RemP2 = <<A as Rem<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5RemP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Pow_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P25 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5PowP2 = <<A as Pow<B>>::Output as Same<P25>>::Output;
+
+    assert_eq!(<P5PowP2 as Integer>::to_i64(), <P25 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Cmp_P2() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5CmpP2 = <A as Cmp<B>>::Output;
+    assert_eq!(<P5CmpP2 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Add_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5AddP3 = <<A as Add<B>>::Output as Same<P8>>::Output;
+
+    assert_eq!(<P5AddP3 as Integer>::to_i64(), <P8 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Sub_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5SubP3 = <<A as Sub<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P5SubP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Mul_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P15 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MulP3 = <<A as Mul<B>>::Output as Same<P15>>::Output;
+
+    assert_eq!(<P5MulP3 as Integer>::to_i64(), <P15 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Min_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MinP3 = <<A as Min<B>>::Output as Same<P3>>::Output;
+
+    assert_eq!(<P5MinP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Max_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MaxP3 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5MaxP3 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Gcd_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Div_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5DivP3 = <<A as Div<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5DivP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Rem_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5RemP3 = <<A as Rem<B>>::Output as Same<P2>>::Output;
+
+    assert_eq!(<P5RemP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Pow_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P125 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5PowP3 = <<A as Pow<B>>::Output as Same<P125>>::Output;
+
+    assert_eq!(<P5PowP3 as Integer>::to_i64(), <P125 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Cmp_P3() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5CmpP3 = <A as Cmp<B>>::Output;
+    assert_eq!(<P5CmpP3 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Add_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5AddP4 = <<A as Add<B>>::Output as Same<P9>>::Output;
+
+    assert_eq!(<P5AddP4 as Integer>::to_i64(), <P9 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Sub_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5SubP4 = <<A as Sub<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5SubP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Mul_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P20 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MulP4 = <<A as Mul<B>>::Output as Same<P20>>::Output;
+
+    assert_eq!(<P5MulP4 as Integer>::to_i64(), <P20 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Min_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MinP4 = <<A as Min<B>>::Output as Same<P4>>::Output;
+
+    assert_eq!(<P5MinP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Max_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MaxP4 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5MaxP4 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Gcd_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Div_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5DivP4 = <<A as Div<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5DivP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Rem_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5RemP4 = <<A as Rem<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5RemP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Pow_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P625 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5PowP4 = <<A as Pow<B>>::Output as Same<P625>>::Output;
+
+    assert_eq!(<P5PowP4 as Integer>::to_i64(), <P625 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Cmp_P4() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5CmpP4 = <A as Cmp<B>>::Output;
+    assert_eq!(<P5CmpP4 as Ord>::to_ordering(), Ordering::Greater);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Add_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type P5AddP5 = <<A as Add<B>>::Output as Same<P10>>::Output;
+
+    assert_eq!(<P5AddP5 as Integer>::to_i64(), <P10 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Sub_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P5SubP5 = <<A as Sub<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P5SubP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Mul_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P25 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MulP5 = <<A as Mul<B>>::Output as Same<P25>>::Output;
+
+    assert_eq!(<P5MulP5 as Integer>::to_i64(), <P25 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Min_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MinP5 = <<A as Min<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5MinP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Max_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Gcd_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5GcdP5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;
+
+    assert_eq!(<P5GcdP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Div_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5DivP5 = <<A as Div<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5DivP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Rem_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type P5RemP5 = <<A as Rem<B>>::Output as Same<_0>>::Output;
+
+    assert_eq!(<P5RemP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_PartialDiv_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5PartialDivP5 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;
+
+    assert_eq!(<P5PartialDivP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Pow_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P3125 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5PowP5 = <<A as Pow<B>>::Output as Same<P3125>>::Output;
+
+    assert_eq!(<P5PowP5 as Integer>::to_i64(), <P3125 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Cmp_P5() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type P5CmpP5 = <A as Cmp<B>>::Output;
+    assert_eq!(<P5CmpP5 as Ord>::to_ordering(), Ordering::Equal);
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Neg() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type NegN5 = <<A as Neg>::Output as Same<P5>>::Output;
+    assert_eq!(<NegN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N5_Abs() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type AbsN5 = <<A as Abs>::Output as Same<P5>>::Output;
+    assert_eq!(<AbsN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Neg() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type NegN4 = <<A as Neg>::Output as Same<P4>>::Output;
+    assert_eq!(<NegN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N4_Abs() {
+    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type AbsN4 = <<A as Abs>::Output as Same<P4>>::Output;
+    assert_eq!(<AbsN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Neg() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type NegN3 = <<A as Neg>::Output as Same<P3>>::Output;
+    assert_eq!(<NegN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N3_Abs() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type AbsN3 = <<A as Abs>::Output as Same<P3>>::Output;
+    assert_eq!(<AbsN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Neg() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type NegN2 = <<A as Neg>::Output as Same<P2>>::Output;
+    assert_eq!(<NegN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N2_Abs() {
+    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type AbsN2 = <<A as Abs>::Output as Same<P2>>::Output;
+    assert_eq!(<AbsN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Neg() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type NegN1 = <<A as Neg>::Output as Same<P1>>::Output;
+    assert_eq!(<NegN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_N1_Abs() {
+    type A = NInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type AbsN1 = <<A as Abs>::Output as Same<P1>>::Output;
+    assert_eq!(<AbsN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Neg() {
+    type A = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type Neg_0 = <<A as Neg>::Output as Same<_0>>::Output;
+    assert_eq!(<Neg_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test__0_Abs() {
+    type A = Z0;
+    type _0 = Z0;
+
+    #[allow(non_camel_case_types)]
+    type Abs_0 = <<A as Abs>::Output as Same<_0>>::Output;
+    assert_eq!(<Abs_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Neg() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type N1 = NInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type NegP1 = <<A as Neg>::Output as Same<N1>>::Output;
+    assert_eq!(<NegP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P1_Abs() {
+    type A = PInt<UInt<UTerm, B1>>;
+    type P1 = PInt<UInt<UTerm, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type AbsP1 = <<A as Abs>::Output as Same<P1>>::Output;
+    assert_eq!(<AbsP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Neg() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type NegP2 = <<A as Neg>::Output as Same<N2>>::Output;
+    assert_eq!(<NegP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P2_Abs() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
+    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type AbsP2 = <<A as Abs>::Output as Same<P2>>::Output;
+    assert_eq!(<AbsP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Neg() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type NegP3 = <<A as Neg>::Output as Same<N3>>::Output;
+    assert_eq!(<NegP3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P3_Abs() {
+    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
+    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type AbsP3 = <<A as Abs>::Output as Same<P3>>::Output;
+    assert_eq!(<AbsP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Neg() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type NegP4 = <<A as Neg>::Output as Same<N4>>::Output;
+    assert_eq!(<NegP4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P4_Abs() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
+
+    #[allow(non_camel_case_types)]
+    type AbsP4 = <<A as Abs>::Output as Same<P4>>::Output;
+    assert_eq!(<AbsP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Neg() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type NegP5 = <<A as Neg>::Output as Same<N5>>::Output;
+    assert_eq!(<NegP5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
+}
+#[test]
+#[allow(non_snake_case)]
+fn test_P5_Abs() {
+    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
+
+    #[allow(non_camel_case_types)]
+    type AbsP5 = <<A as Abs>::Output as Same<P5>>::Output;
+    assert_eq!(<AbsP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
+}
\ No newline at end of file
-- 
2.43.0

From b70b24945ca2bae0a3d25e357c80e13b2e80ae9a Mon Sep 17 00:00:00 2001
From: Matthew Waters <matthew@centricular.com>
Date: Thu, 15 Feb 2024 14:35:25 +1100
Subject: [PATCH 2/2] add meson build

---
 meson.build | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)
 create mode 100644 meson.build

diff --git a/meson.build b/meson.build
new file mode 100644
index 0000000..9a78408
--- /dev/null
+++ b/meson.build
@@ -0,0 +1,22 @@
+project('typenum-rs', 'rust',
+  version : '1.17.0',
+  meson_version : '>= 1.3.1',
+  default_options : ['buildtype=debugoptimized',
+                     'rust_std=2018'
+                    ]
+)
+
+rustc = meson.get_compiler('rust')
+
+lib = static_library(
+  'typenum',
+  'src/lib.rs',
+  rust_dependency_map : {}
+)
+
+dep = declare_dependency(
+  link_with : lib,
+  variables : { 'features' : 'default' },
+)
+meson.override_dependency('typenum-rs', dep)
+
-- 
2.43.0

From 4f415753aafaf2220907073abc787267ce000774 Mon Sep 17 00:00:00 2001
From: Matthew Waters <matthew@centricular.com>
Date: Thu, 15 Feb 2024 14:33:44 +1100
Subject: add meson_options.txt

diff --git a/meson_options.txt b/meson_options.txt
new file mode 100644
index 0000000..cbbb546
--- /dev/null
+++ b/meson_options.txt
@@ -0,0 +1,1 @@
+option('feature-default', type: 'boolean', value: true)
